import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  CharacterData: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Date: { input: any; output: any; }
  Datetime: { input: any; output: any; }
  JSON: { input: any; output: any; }
  SqlIdentifier: { input: any; output: any; }
  YesOrNo: { input: any; output: any; }
};

export type ActionPlugin = Node & {
  __typename?: 'ActionPlugin';
  code?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  optionalParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  outputProperties?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  path?: Maybe<Scalars['String']['output']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A condition to be used against `ActionPlugin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ActionPluginCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `optionalParameters` field. */
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `outputProperties` field. */
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A filter to be used against `ActionPlugin` object types. All fields are combined with a logical ‘and.’ */
export type ActionPluginFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActionPluginFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActionPluginFilter>;
  /** Filter by the object’s `optionalParameters` field. */
  optionalParameters?: InputMaybe<StringListFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActionPluginFilter>>;
  /** Filter by the object’s `outputProperties` field. */
  outputProperties?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<StringListFilter>;
};

/** An input for mutations affecting `ActionPlugin` */
export type ActionPluginInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Represents an update to a `ActionPlugin`. Fields that are set will be updated. */
export type ActionPluginPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `ActionPlugin` values. */
export type ActionPluginsConnection = {
  __typename?: 'ActionPluginsConnection';
  /** A list of edges which contains the `ActionPlugin` and cursor to aid in pagination. */
  edges: Array<ActionPluginsEdge>;
  /** A list of `ActionPlugin` objects. */
  nodes: Array<Maybe<ActionPlugin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionPlugin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActionPlugin` edge in the connection. */
export type ActionPluginsEdge = {
  __typename?: 'ActionPluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActionPlugin` at the end of the edge. */
  node?: Maybe<ActionPlugin>;
};

/** Methods to use when ordering `ActionPlugin`. */
export enum ActionPluginsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OptionalParametersAsc = 'OPTIONAL_PARAMETERS_ASC',
  OptionalParametersDesc = 'OPTIONAL_PARAMETERS_DESC',
  OutputPropertiesAsc = 'OUTPUT_PROPERTIES_ASC',
  OutputPropertiesDesc = 'OUTPUT_PROPERTIES_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC'
}

export type ActionQueue = Node & {
  __typename?: 'ActionQueue';
  actionCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  conditionExpression?: Maybe<Scalars['JSON']['output']>;
  errorLog?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  output?: Maybe<Scalars['JSON']['output']>;
  parameterQueries?: Maybe<Scalars['JSON']['output']>;
  parametersEvaluated?: Maybe<Scalars['JSON']['output']>;
  sequence?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ActionQueueStatus>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  timeCompleted?: Maybe<Scalars['Datetime']['output']>;
  timeQueued?: Maybe<Scalars['Datetime']['output']>;
  triggerEvent?: Maybe<Scalars['Int']['output']>;
  triggerPayload?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};

/** The fields on `actionQueue` to look up the row to connect. */
export type ActionQueueActionQueuePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `actionQueue` to look up the row to delete. */
export type ActionQueueActionQueuePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueApplicationIdFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** The `application` to be created by this mutation. */
export type ActionQueueApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ActionQueueInput` mutation. */
export type ActionQueueApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `ApplicationInput` mutation. */
export type ActionQueueApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueApplicationIdFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate>>;
};

/** A condition to be used against `ActionQueue` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ActionQueueCondition = {
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `conditionExpression` field. */
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `errorLog` field. */
  errorLog?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `output` field. */
  output?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parametersEvaluated` field. */
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ActionQueueStatus>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCompleted` field. */
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeQueued` field. */
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `triggerEvent` field. */
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `triggerPayload` field. */
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type ActionQueueFilter = {
  /** Filter by the object’s `actionCode` field. */
  actionCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActionQueueFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `conditionExpression` field. */
  conditionExpression?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `errorLog` field. */
  errorLog?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActionQueueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActionQueueFilter>>;
  /** Filter by the object’s `output` field. */
  output?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersEvaluated` field. */
  parametersEvaluated?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ActionQueueStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCompleted` field. */
  timeCompleted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeQueued` field. */
  timeQueued?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `triggerEvent` field. */
  triggerEvent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `triggerPayload` field. */
  triggerPayload?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `triggerQueueByTriggerEvent` relation. */
  triggerQueueByTriggerEvent?: InputMaybe<TriggerQueueFilter>;
  /** A related `triggerQueueByTriggerEvent` exists. */
  triggerQueueByTriggerEventExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `ActionQueue` */
export type ActionQueueInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ActionQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ActionQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
};

/** Represents an update to a `ActionQueue`. Fields that are set will be updated. */
export type ActionQueuePatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** A connection to a list of `ActionQueue` values. */
export type ActionQueuesConnection = {
  __typename?: 'ActionQueuesConnection';
  /** A list of edges which contains the `ActionQueue` and cursor to aid in pagination. */
  edges: Array<ActionQueuesEdge>;
  /** A list of `ActionQueue` objects. */
  nodes: Array<Maybe<ActionQueue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionQueue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActionQueue` edge in the connection. */
export type ActionQueuesEdge = {
  __typename?: 'ActionQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActionQueue` at the end of the edge. */
  node?: Maybe<ActionQueue>;
};

/** Methods to use when ordering `ActionQueue`. */
export enum ActionQueuesOrderBy {
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ConditionExpressionAsc = 'CONDITION_EXPRESSION_ASC',
  ConditionExpressionDesc = 'CONDITION_EXPRESSION_DESC',
  ErrorLogAsc = 'ERROR_LOG_ASC',
  ErrorLogDesc = 'ERROR_LOG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OutputAsc = 'OUTPUT_ASC',
  OutputDesc = 'OUTPUT_DESC',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  ParametersEvaluatedAsc = 'PARAMETERS_EVALUATED_ASC',
  ParametersEvaluatedDesc = 'PARAMETERS_EVALUATED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeCompletedAsc = 'TIME_COMPLETED_ASC',
  TimeCompletedDesc = 'TIME_COMPLETED_DESC',
  TimeQueuedAsc = 'TIME_QUEUED_ASC',
  TimeQueuedDesc = 'TIME_QUEUED_DESC',
  TriggerEventAsc = 'TRIGGER_EVENT_ASC',
  TriggerEventDesc = 'TRIGGER_EVENT_DESC',
  TriggerPayloadAsc = 'TRIGGER_PAYLOAD_ASC',
  TriggerPayloadDesc = 'TRIGGER_PAYLOAD_DESC'
}

export enum ActionQueueStatus {
  ConditionNotMet = 'CONDITION_NOT_MET',
  Fail = 'FAIL',
  Processing = 'PROCESSING',
  Queued = 'QUEUED',
  Success = 'SUCCESS'
}

/** A filter to be used against ActionQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type ActionQueueStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ActionQueueStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ActionQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ActionQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ActionQueueStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ActionQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ActionQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ActionQueueStatus>>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** Input for the nested mutation of `template` in the `ActionQueueInput` mutation. */
export type ActionQueueTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `TemplateInput` mutation. */
export type ActionQueueTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueTemplateIdFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** Input for the nested mutation of `triggerQueue` in the `ActionQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInput = {
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectById?: InputMaybe<TriggerQueueTriggerQueuePkeyConnect>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TriggerQueueNodeIdConnect>;
  /** A `TriggerQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueTriggerEventFkeyTriggerQueueCreateInput>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<TriggerQueueTriggerQueuePkeyDelete>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TriggerQueueNodeIdDelete>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateById?: InputMaybe<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `TriggerQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueTriggerEventFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>>;
};

/** The `triggerQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyTriggerQueueCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

export type ActivityLog = Node & {
  __typename?: 'ActivityLog';
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  details: Scalars['JSON']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  recordId?: Maybe<Scalars['Int']['output']>;
  table: Scalars['String']['output'];
  timestamp: Scalars['Datetime']['output'];
  type: EventType;
  value: Scalars['String']['output'];
};

/** The fields on `activityLog` to look up the row to connect. */
export type ActivityLogActivityLogPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `activityLog` to look up the row to delete. */
export type ActivityLogActivityLogPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The `activityLog` to be created by this mutation. */
export type ActivityLogApplicationIdFkeyActivityLogCreateInput = {
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type: EventType;
  value: Scalars['String']['input'];
};

/** The `application` to be created by this mutation. */
export type ActivityLogApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ActivityLogInput` mutation. */
export type ActivityLogApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActivityLogApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `activityLog` in the `ApplicationInput` mutation. */
export type ActivityLogApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActivityLogActivityLogPkeyConnect>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActivityLogNodeIdConnect>>;
  /** A `ActivityLogInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActivityLogApplicationIdFkeyActivityLogCreateInput>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActivityLogActivityLogPkeyDelete>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActivityLogNodeIdDelete>>;
  /** Flag indicating whether all other `activityLog` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `activityLog` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate>>;
  /** The primary key(s) and patch data for `activityLog` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate>>;
};

/** A condition to be used against `ActivityLog` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ActivityLogCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `table` field. */
  table?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<EventType>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ActivityLog` object types. All fields are combined with a logical ‘and.’ */
export type ActivityLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActivityLogFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActivityLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActivityLogFilter>>;
  /** Filter by the object’s `recordId` field. */
  recordId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `table` field. */
  table?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<EventTypeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ActivityLog` */
export type ActivityLogInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type: EventType;
  value: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ActivityLogNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `activityLog` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ActivityLogNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `activityLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `activityLog` to look up the row to update. */
export type ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `activityLog` being updated. */
  patch: UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** Represents an update to a `ActivityLog`. Fields that are set will be updated. */
export type ActivityLogPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type?: InputMaybe<EventType>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `ActivityLog` values. */
export type ActivityLogsConnection = {
  __typename?: 'ActivityLogsConnection';
  /** A list of edges which contains the `ActivityLog` and cursor to aid in pagination. */
  edges: Array<ActivityLogsEdge>;
  /** A list of `ActivityLog` objects. */
  nodes: Array<Maybe<ActivityLog>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActivityLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActivityLog` edge in the connection. */
export type ActivityLogsEdge = {
  __typename?: 'ActivityLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActivityLog` at the end of the edge. */
  node?: Maybe<ActivityLog>;
};

/** Methods to use when ordering `ActivityLog`. */
export enum ActivityLogsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  TableAsc = 'TABLE_ASC',
  TableDesc = 'TABLE_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type Application = Node & {
  __typename?: 'Application';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues: ActionQueuesConnection;
  /** Reads and enables pagination through a set of `ActivityLog`. */
  activityLogs: ActivityLogsConnection;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotes: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories: ApplicationStageHistoriesConnection;
  /** Reads and enables pagination through a set of `DataTableProductApplicationJoin`. */
  dataTableProductApplicationJoins: DataTableProductApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `File`. */
  filesByApplicationSerial: FilesConnection;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isConfig?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins: OrganisationApplicationJoinsConnection;
  orgId?: Maybe<Scalars['Int']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  outcomeRegistration?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ProductApplicationJoin`. */
  productApplicationJoins: ProductApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `Review`. */
  reviews: ReviewsConnection;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  trigger?: Maybe<Trigger>;
  /** Reads and enables pagination through a set of `TriggerQueue`. */
  triggerQueues: TriggerQueuesConnection;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules: TriggerSchedulesConnection;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
  /** Reads and enables pagination through a set of `UserApplicationJoin`. */
  userApplicationJoins: UserApplicationJoinsConnection;
  userId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `UserOrganisationApplicationJoin`. */
  userOrganisationApplicationJoins: UserOrganisationApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `Verification`. */
  verifications: VerificationsConnection;
};


export type ApplicationActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


export type ApplicationActivityLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActivityLogCondition>;
  filter?: InputMaybe<ActivityLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};


export type ApplicationApplicationNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type ApplicationApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


export type ApplicationApplicationStageHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


export type ApplicationDataTableProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};


export type ApplicationFilesByApplicationSerialArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type ApplicationNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


export type ApplicationOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


export type ApplicationProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProductApplicationJoinCondition>;
  filter?: InputMaybe<ProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProductApplicationJoinsOrderBy>>;
};


export type ApplicationReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type ApplicationReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};


export type ApplicationTriggerQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerQueueCondition>;
  filter?: InputMaybe<TriggerQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};


export type ApplicationTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};


export type ApplicationUserApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserApplicationJoinCondition>;
  filter?: InputMaybe<UserApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};


export type ApplicationUserOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationApplicationJoinCondition>;
  filter?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};


export type ApplicationVerificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationCondition>;
  filter?: InputMaybe<VerificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationOutcomeRegistrationKeyConnect = {
  outcomeRegistration: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationOutcomeRegistrationKeyDelete = {
  outcomeRegistration: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationSerialKeyConnect = {
  serial: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationSerialKeyDelete = {
  serial: Scalars['String']['input'];
};

/** A condition to be used against `Application` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isConfig` field. */
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `outcomeRegistration` field. */
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Application` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationFilter = {
  /** Filter by the object’s `actionQueues` relation. */
  actionQueues?: InputMaybe<ApplicationToManyActionQueueFilter>;
  /** Some related `actionQueues` exist. */
  actionQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `activityLogs` relation. */
  activityLogs?: InputMaybe<ApplicationToManyActivityLogFilter>;
  /** Some related `activityLogs` exist. */
  activityLogsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `applicationNotes` relation. */
  applicationNotes?: InputMaybe<ApplicationToManyApplicationNoteFilter>;
  /** Some related `applicationNotes` exist. */
  applicationNotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: InputMaybe<ApplicationToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationStageHistories` relation. */
  applicationStageHistories?: InputMaybe<ApplicationToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistories` exist. */
  applicationStageHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTableProductApplicationJoins` relation. */
  dataTableProductApplicationJoins?: InputMaybe<ApplicationToManyDataTableProductApplicationJoinFilter>;
  /** Some related `dataTableProductApplicationJoins` exist. */
  dataTableProductApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filesByApplicationSerial` relation. */
  filesByApplicationSerial?: InputMaybe<ApplicationToManyFileFilter>;
  /** Some related `filesByApplicationSerial` exist. */
  filesByApplicationSerialExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isConfig` field. */
  isConfig?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: InputMaybe<ApplicationToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `org` relation. */
  org?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `organisationApplicationJoins` relation. */
  organisationApplicationJoins?: InputMaybe<ApplicationToManyOrganisationApplicationJoinFilter>;
  /** Some related `organisationApplicationJoins` exist. */
  organisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `org` exists. */
  orgExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `outcomeRegistration` field. */
  outcomeRegistration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productApplicationJoins` relation. */
  productApplicationJoins?: InputMaybe<ApplicationToManyProductApplicationJoinFilter>;
  /** Some related `productApplicationJoins` exist. */
  productApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<ApplicationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviews` relation. */
  reviews?: InputMaybe<ApplicationToManyReviewFilter>;
  /** Some related `reviews` exist. */
  reviewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
  /** Filter by the object’s `triggerQueues` relation. */
  triggerQueues?: InputMaybe<ApplicationToManyTriggerQueueFilter>;
  /** Some related `triggerQueues` exist. */
  triggerQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `triggerSchedules` relation. */
  triggerSchedules?: InputMaybe<ApplicationToManyTriggerScheduleFilter>;
  /** Some related `triggerSchedules` exist. */
  triggerSchedulesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userApplicationJoins` relation. */
  userApplicationJoins?: InputMaybe<ApplicationToManyUserApplicationJoinFilter>;
  /** Some related `userApplicationJoins` exist. */
  userApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userOrganisationApplicationJoins` relation. */
  userOrganisationApplicationJoins?: InputMaybe<ApplicationToManyUserOrganisationApplicationJoinFilter>;
  /** Some related `userOrganisationApplicationJoins` exist. */
  userOrganisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `verifications` relation. */
  verifications?: InputMaybe<ApplicationToManyVerificationFilter>;
  /** Some related `verifications` exist. */
  verificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Application` */
export type ApplicationInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterApplicantConnection = {
  __typename?: 'ApplicationListFilterApplicantConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterApplicantEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterApplicantEdge = {
  __typename?: 'ApplicationListFilterApplicantEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterAssignerConnection = {
  __typename?: 'ApplicationListFilterAssignerConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterAssignerEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterAssignerEdge = {
  __typename?: 'ApplicationListFilterAssignerEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterOrganisationConnection = {
  __typename?: 'ApplicationListFilterOrganisationConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterOrganisationEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterOrganisationEdge = {
  __typename?: 'ApplicationListFilterOrganisationEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterReviewerConnection = {
  __typename?: 'ApplicationListFilterReviewerConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterReviewerEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterReviewerEdge = {
  __typename?: 'ApplicationListFilterReviewerEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterStageConnection = {
  __typename?: 'ApplicationListFilterStageConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterStageEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterStageEdge = {
  __typename?: 'ApplicationListFilterStageEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

export type ApplicationListShape = {
  __typename?: 'ApplicationListShape';
  applicant?: Maybe<Scalars['String']['output']>;
  applicantDeadline?: Maybe<Scalars['Datetime']['output']>;
  assignerAction?: Maybe<AssignerAction>;
  assigners?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id?: Maybe<Scalars['Int']['output']>;
  lastActiveDate?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  reviewerAction?: Maybe<ReviewerAction>;
  reviewers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  serial?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  status?: Maybe<ApplicationStatus>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `ApplicationListShape` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationListShapeCondition = {
  /** Checks for equality with the object’s `applicant` field. */
  applicant?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicantDeadline` field. */
  applicantDeadline?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerAction>;
  /** Checks for equality with the object’s `assigners` field. */
  assigners?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastActiveDate` field. */
  lastActiveDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerAction>;
  /** Checks for equality with the object’s `reviewers` field. */
  reviewers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ApplicationListShape` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationListShapeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationListShapeFilter>>;
  /** Filter by the object’s `applicant` field. */
  applicant?: InputMaybe<StringFilter>;
  /** Filter by the object’s `applicantDeadline` field. */
  applicantDeadline?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Filter by the object’s `assigners` field. */
  assigners?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastActiveDate` field. */
  lastActiveDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationListShapeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationListShapeFilter>>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
  /** Filter by the object’s `reviewers` field. */
  reviewers?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ApplicationListShape` */
export type ApplicationListShapeInput = {
  applicant?: InputMaybe<Scalars['String']['input']>;
  applicantDeadline?: InputMaybe<Scalars['Datetime']['input']>;
  assignerAction?: InputMaybe<AssignerAction>;
  assigners?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastActiveDate?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  orgName?: InputMaybe<Scalars['String']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  reviewers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  serial?: InputMaybe<Scalars['String']['input']>;
  stage?: InputMaybe<Scalars['String']['input']>;
  stageColour?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `ApplicationListShape` values. */
export type ApplicationListShapesConnection = {
  __typename?: 'ApplicationListShapesConnection';
  /** A list of edges which contains the `ApplicationListShape` and cursor to aid in pagination. */
  edges: Array<ApplicationListShapesEdge>;
  /** A list of `ApplicationListShape` objects. */
  nodes: Array<Maybe<ApplicationListShape>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationListShape` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationListShape` edge in the connection. */
export type ApplicationListShapesEdge = {
  __typename?: 'ApplicationListShapesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationListShape` at the end of the edge. */
  node?: Maybe<ApplicationListShape>;
};

/** Methods to use when ordering `ApplicationListShape`. */
export enum ApplicationListShapesOrderBy {
  ApplicantAsc = 'APPLICANT_ASC',
  ApplicantDeadlineAsc = 'APPLICANT_DEADLINE_ASC',
  ApplicantDeadlineDesc = 'APPLICANT_DEADLINE_DESC',
  ApplicantDesc = 'APPLICANT_DESC',
  AssignerActionAsc = 'ASSIGNER_ACTION_ASC',
  AssignerActionDesc = 'ASSIGNER_ACTION_DESC',
  AssignersAsc = 'ASSIGNERS_ASC',
  AssignersDesc = 'ASSIGNERS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastActiveDateAsc = 'LAST_ACTIVE_DATE_ASC',
  LastActiveDateDesc = 'LAST_ACTIVE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  ReviewerActionAsc = 'REVIEWER_ACTION_ASC',
  ReviewerActionDesc = 'REVIEWER_ACTION_DESC',
  ReviewersAsc = 'REVIEWERS_ASC',
  ReviewersDesc = 'REVIEWERS_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `application` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

export type ApplicationNote = Node & {
  __typename?: 'ApplicationNote';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  comment: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  orgId: Scalars['Int']['output'];
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `User` that is related to this `ApplicationNote`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};


export type ApplicationNoteFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationNoteApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationNote` to be created by this mutation. */
export type ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput = {
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** Input for the nested mutation of `application` in the `ApplicationNoteInput` mutation. */
export type ApplicationNoteApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationNoteApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationNote` in the `ApplicationInput` mutation. */
export type ApplicationNoteApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationNote` to look up the row to connect. */
export type ApplicationNoteApplicationNotePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationNote` to look up the row to delete. */
export type ApplicationNoteApplicationNotePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `ApplicationNote` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationNoteCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationNoteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationNoteFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<ApplicationNoteToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationNoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationNoteFilter>>;
  /** Filter by the object’s `org` relation. */
  org?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ApplicationNote` */
export type ApplicationNoteInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationNoteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationNoteNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch;
};

/** The `applicationNote` to be created by this mutation. */
export type ApplicationNoteOrgIdFkeyApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** Input for the nested mutation of `organisation` in the `ApplicationNoteInput` mutation. */
export type ApplicationNoteOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationNoteOrgIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `applicationNote` in the `OrganisationInput` mutation. */
export type ApplicationNoteOrgIdFkeyInverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationNoteOrgIdFkeyApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ApplicationNoteOrgIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** Represents an update to a `ApplicationNote`. Fields that are set will be updated. */
export type ApplicationNotePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** A connection to a list of `ApplicationNote` values. */
export type ApplicationNotesConnection = {
  __typename?: 'ApplicationNotesConnection';
  /** A list of edges which contains the `ApplicationNote` and cursor to aid in pagination. */
  edges: Array<ApplicationNotesEdge>;
  /** A list of `ApplicationNote` objects. */
  nodes: Array<Maybe<ApplicationNote>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationNote` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationNote` edge in the connection. */
export type ApplicationNotesEdge = {
  __typename?: 'ApplicationNotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationNote` at the end of the edge. */
  node?: Maybe<ApplicationNote>;
};

/** Methods to use when ordering `ApplicationNote`. */
export enum ApplicationNotesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationNoteToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** The `applicationNote` to be created by this mutation. */
export type ApplicationNoteUserIdFkeyApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `ApplicationNoteInput` mutation. */
export type ApplicationNoteUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationNoteUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnApplicationNoteForApplicationNoteUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnApplicationNoteForApplicationNoteUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `applicationNote` in the `UserInput` mutation. */
export type ApplicationNoteUserIdFkeyInverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationNoteUserIdFkeyApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyUsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnApplicationNoteForApplicationNoteUserIdFkeyNodeIdUpdate>>;
};

/** The `user` to be created by this mutation. */
export type ApplicationNoteUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `activityLog` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `activityLog` being updated. */
  patch: ActivityLogPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `productApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `productApplicationJoin` being updated. */
  patch: ProductApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
  patch: UserOrganisationApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `verification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: VerificationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The `application` to be created by this mutation. */
export type ApplicationOrgIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `organisation` in the `ApplicationInput` mutation. */
export type ApplicationOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationOrgIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `application` in the `OrganisationInput` mutation. */
export type ApplicationOrgIdFkeyInverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationOrgIdFkeyApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ApplicationOrgIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

export enum ApplicationOutcome {
  Approved = 'APPROVED',
  Expired = 'EXPIRED',
  Pending = 'PENDING',
  Rejected = 'REJECTED',
  Withdrawn = 'WITHDRAWN'
}

/** A filter to be used against ApplicationOutcome fields. All fields are combined with a logical ‘and.’ */
export type ApplicationOutcomeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationOutcome>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationOutcome>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationOutcome>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationOutcome>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationOutcome>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationOutcome>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationOutcome>>;
};

/** Represents an update to a `Application`. Fields that are set will be updated. */
export type ApplicationPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

export type ApplicationResponse = Node & {
  __typename?: 'ApplicationResponse';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  evaluatedParameters?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  id: Scalars['Int']['output'];
  isValid?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationResponseStatus>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  templateElementId: Scalars['Int']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeSubmitted?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
  value?: Maybe<Scalars['JSON']['output']>;
};


export type ApplicationResponseFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type ApplicationResponseReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput = {
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `application` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationResponseApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationResponse` in the `ApplicationInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdConnect>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdDelete>>;
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationResponse` to look up the row to connect. */
export type ApplicationResponseApplicationResponsePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationResponse` to look up the row to delete. */
export type ApplicationResponseApplicationResponsePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `ApplicationResponse` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationResponseCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `evaluatedParameters` field. */
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isValid` field. */
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationResponseStatus>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationResponseFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluatedParameters` field. */
  evaluatedParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<ApplicationResponseToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isValid` field. */
  isValid?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationResponseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationResponseFilter>>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<ApplicationResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationResponseStatusFilter>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: InputMaybe<TemplateElementFilter>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `ApplicationResponse` */
export type ApplicationResponseInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
};

/** Represents an update to a `ApplicationResponse`. Fields that are set will be updated. */
export type ApplicationResponsePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `ApplicationResponse` values. */
export type ApplicationResponsesConnection = {
  __typename?: 'ApplicationResponsesConnection';
  /** A list of edges which contains the `ApplicationResponse` and cursor to aid in pagination. */
  edges: Array<ApplicationResponsesEdge>;
  /** A list of `ApplicationResponse` objects. */
  nodes: Array<Maybe<ApplicationResponse>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationResponse` edge in the connection. */
export type ApplicationResponsesEdge = {
  __typename?: 'ApplicationResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationResponse` at the end of the edge. */
  node?: Maybe<ApplicationResponse>;
};

/** Methods to use when ordering `ApplicationResponse`. */
export enum ApplicationResponsesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  EvaluatedParametersAsc = 'EVALUATED_PARAMETERS_ASC',
  EvaluatedParametersDesc = 'EVALUATED_PARAMETERS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsValidAsc = 'IS_VALID_ASC',
  IsValidDesc = 'IS_VALID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeSubmittedAsc = 'TIME_SUBMITTED_ASC',
  TimeSubmittedDesc = 'TIME_SUBMITTED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export enum ApplicationResponseStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ApplicationResponseStatus fields. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationResponseStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationResponseStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationResponseStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationResponseStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationResponseStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationResponseStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationResponseStatus>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `templateElement` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>;
};

/** Input for the nested mutation of `applicationResponse` in the `TemplateElementInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInverseInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdConnect>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdDelete>>;
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>>;
};

/** The `templateElement` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A connection to a list of `Application` values. */
export type ApplicationsConnection = {
  __typename?: 'ApplicationsConnection';
  /** A list of edges which contains the `Application` and cursor to aid in pagination. */
  edges: Array<ApplicationsEdge>;
  /** A list of `Application` objects. */
  nodes: Array<Maybe<Application>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Application` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Application` edge in the connection. */
export type ApplicationsEdge = {
  __typename?: 'ApplicationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Application` at the end of the edge. */
  node?: Maybe<Application>;
};

/** Methods to use when ordering `Application`. */
export enum ApplicationsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsConfigAsc = 'IS_CONFIG_ASC',
  IsConfigDesc = 'IS_CONFIG_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  OutcomeRegistrationAsc = 'OUTCOME_REGISTRATION_ASC',
  OutcomeRegistrationDesc = 'OUTCOME_REGISTRATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `ApplicationStageHistory` values. */
export type ApplicationStageHistoriesConnection = {
  __typename?: 'ApplicationStageHistoriesConnection';
  /** A list of edges which contains the `ApplicationStageHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStageHistoriesEdge>;
  /** A list of `ApplicationStageHistory` objects. */
  nodes: Array<Maybe<ApplicationStageHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageHistory` edge in the connection. */
export type ApplicationStageHistoriesEdge = {
  __typename?: 'ApplicationStageHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageHistory` at the end of the edge. */
  node?: Maybe<ApplicationStageHistory>;
};

/** Methods to use when ordering `ApplicationStageHistory`. */
export enum ApplicationStageHistoriesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ApplicationStageHistory = Node & {
  __typename?: 'ApplicationStageHistory';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories: ApplicationStatusHistoriesConnection;
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};


export type ApplicationStageHistoryApplicationStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStatusHistoryCondition>;
  filter?: InputMaybe<ApplicationStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput = {
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `application` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationStageHistory` to look up the row to connect. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationStageHistory` to look up the row to delete. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `ApplicationStageHistory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationStageHistoryCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageHistoryFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationStatusHistories` relation. */
  applicationStatusHistories?: InputMaybe<ApplicationStageHistoryToManyApplicationStatusHistoryFilter>;
  /** Some related `applicationStatusHistories` exist. */
  applicationStatusHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageHistoryFilter>>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ApplicationStageHistory` */
export type ApplicationStageHistoryInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStageHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStageHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
};

/** Represents an update to a `ApplicationStageHistory`. Fields that are set will be updated. */
export type ApplicationStageHistoryPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `templateStage` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `TemplateStageInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>>;
};

/** The `templateStage` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryToManyApplicationStatusHistoryFilter = {
  /** Every related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** No related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** Some related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStatusHistoryFilter>;
};

export type ApplicationStageStatusAll = {
  __typename?: 'ApplicationStageStatusAll';
  applicationId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  stageHistoryId?: Maybe<Scalars['Int']['output']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryId?: Maybe<Scalars['Int']['output']>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `ApplicationStageStatusAll` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationStageStatusAllCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationStageStatusAll` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusAllFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageStatusAllFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageStatusAllFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageStatusAllFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `ApplicationStageStatusAll` values. */
export type ApplicationStageStatusAllsConnection = {
  __typename?: 'ApplicationStageStatusAllsConnection';
  /** A list of edges which contains the `ApplicationStageStatusAll` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusAllsEdge>;
  /** A list of `ApplicationStageStatusAll` objects. */
  nodes: Array<Maybe<ApplicationStageStatusAll>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusAll` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageStatusAll` edge in the connection. */
export type ApplicationStageStatusAllsEdge = {
  __typename?: 'ApplicationStageStatusAllsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageStatusAll` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusAll>;
};

/** Methods to use when ordering `ApplicationStageStatusAll`. */
export enum ApplicationStageStatusAllsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type ApplicationStageStatusLatest = {
  __typename?: 'ApplicationStageStatusLatest';
  applicationId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  stageHistoryId?: Maybe<Scalars['Int']['output']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryId?: Maybe<Scalars['Int']['output']>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `ApplicationStageStatusLatest` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationStageStatusLatestCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationStageStatusLatest` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusLatestFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageStatusLatestFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `ApplicationStageStatusLatest` values. */
export type ApplicationStageStatusLatestsConnection = {
  __typename?: 'ApplicationStageStatusLatestsConnection';
  /** A list of edges which contains the `ApplicationStageStatusLatest` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusLatestsEdge>;
  /** A list of `ApplicationStageStatusLatest` objects. */
  nodes: Array<Maybe<ApplicationStageStatusLatest>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusLatest` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageStatusLatest` edge in the connection. */
export type ApplicationStageStatusLatestsEdge = {
  __typename?: 'ApplicationStageStatusLatestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageStatusLatest` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusLatest>;
};

/** Methods to use when ordering `ApplicationStageStatusLatest`. */
export enum ApplicationStageStatusLatestsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export enum ApplicationStatus {
  ChangesRequired = 'CHANGES_REQUIRED',
  Completed = 'COMPLETED',
  Draft = 'DRAFT',
  ReSubmitted = 'RE_SUBMITTED',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ApplicationStatus fields. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationStatus>>;
};

/** A connection to a list of `ApplicationStatusHistory` values. */
export type ApplicationStatusHistoriesConnection = {
  __typename?: 'ApplicationStatusHistoriesConnection';
  /** A list of edges which contains the `ApplicationStatusHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStatusHistoriesEdge>;
  /** A list of `ApplicationStatusHistory` objects. */
  nodes: Array<Maybe<ApplicationStatusHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStatusHistory` edge in the connection. */
export type ApplicationStatusHistoriesEdge = {
  __typename?: 'ApplicationStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStatusHistory` at the end of the edge. */
  node?: Maybe<ApplicationStatusHistory>;
};

/** Methods to use when ordering `ApplicationStatusHistory`. */
export enum ApplicationStatusHistoriesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ApplicationStageHistoryIdAsc = 'APPLICATION_STAGE_HISTORY_ID_ASC',
  ApplicationStageHistoryIdDesc = 'APPLICATION_STAGE_HISTORY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ApplicationStatusHistory = Node & {
  __typename?: 'ApplicationStatusHistory';
  applicationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  applicationStageHistoryId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `applicationStatusHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationStatusHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationStageHistoryNodeIdConnect>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationStageHistoryNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `applicationStatusHistory` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStatusHistoryNodeIdConnect>>;
  /** A `ApplicationStatusHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStatusHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationStatusHistory` to look up the row to connect. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationStatusHistory` to look up the row to delete. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A condition to be used against `ApplicationStatusHistory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ApplicationStatusHistoryCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStatusHistoryFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationStageHistory` relation. */
  applicationStageHistory?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Filter by the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStatusHistoryFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ApplicationStatusHistory` */
export type ApplicationStatusHistoryInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `applicationStatusHistory` to look up the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
};

/** Represents an update to a `ApplicationStatusHistory`. Fields that are set will be updated. */
export type ApplicationStatusHistoryPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `application` to be created by this mutation. */
export type ApplicationTemplateIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `template` in the `ApplicationInput` mutation. */
export type ApplicationTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `application` in the `TemplateInput` mutation. */
export type ApplicationTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationTemplateIdFkeyApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type ApplicationTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** A filter to be used against many `ActivityLog` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyActivityLogFilter = {
  /** Every related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActivityLogFilter>;
  /** No related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActivityLogFilter>;
  /** Some related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActivityLogFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `DataTableProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTableProductApplicationJoinFilter = {
  /** Every related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** No related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** Some related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableProductApplicationJoinFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NotificationFilter>;
};

/** A filter to be used against many `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyOrganisationApplicationJoinFilter = {
  /** Every related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** No related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Some related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganisationApplicationJoinFilter>;
};

/** A filter to be used against many `ProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyProductApplicationJoinFilter = {
  /** Every related `ProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ProductApplicationJoinFilter>;
  /** No related `ProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ProductApplicationJoinFilter>;
  /** Some related `ProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ProductApplicationJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewFilter>;
};

/** A filter to be used against many `TriggerQueue` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyTriggerQueueFilter = {
  /** Every related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerQueueFilter>;
  /** No related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerQueueFilter>;
  /** Some related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerQueueFilter>;
};

/** A filter to be used against many `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyTriggerScheduleFilter = {
  /** Every related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerScheduleFilter>;
  /** No related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerScheduleFilter>;
  /** Some related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerScheduleFilter>;
};

/** A filter to be used against many `UserApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyUserApplicationJoinFilter = {
  /** Every related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserApplicationJoinFilter>;
  /** No related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserApplicationJoinFilter>;
  /** Some related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserApplicationJoinFilter>;
};

/** A filter to be used against many `UserOrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyUserOrganisationApplicationJoinFilter = {
  /** Every related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  /** No related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  /** Some related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationApplicationJoinFilter>;
};

/** A filter to be used against many `Verification` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyVerificationFilter = {
  /** Every related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<VerificationFilter>;
  /** No related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<VerificationFilter>;
  /** Some related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<VerificationFilter>;
};

/** The `application` to be created by this mutation. */
export type ApplicationUserIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ApplicationInput` mutation. */
export type ApplicationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `application` in the `UserInput` mutation. */
export type ApplicationUserIdFkeyInverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationUserIdFkeyApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate>>;
};

/** The `user` to be created by this mutation. */
export type ApplicationUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A `AssignedQuestionsRecord` edge in the connection. */
export type AssignedQuestionEdge = {
  __typename?: 'AssignedQuestionEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignedQuestionsRecord` at the end of the edge. */
  node?: Maybe<AssignedQuestionsRecord>;
};

/** A connection to a list of `AssignedQuestionsRecord` values. */
export type AssignedQuestionsConnection = {
  __typename?: 'AssignedQuestionsConnection';
  /** A list of edges which contains the `AssignedQuestionsRecord` and cursor to aid in pagination. */
  edges: Array<AssignedQuestionEdge>;
  /** A list of `AssignedQuestionsRecord` objects. */
  nodes: Array<Maybe<AssignedQuestionsRecord>>;
  /** The count of *all* `AssignedQuestionsRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The return type of our `assignedQuestions` query. */
export type AssignedQuestionsRecord = {
  __typename?: 'AssignedQuestionsRecord';
  decision?: Maybe<ReviewResponseDecision>;
  isLastestReview?: Maybe<Scalars['Boolean']['output']>;
  isOptional?: Maybe<Scalars['Boolean']['output']>;
  responseId?: Maybe<Scalars['Int']['output']>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  reviewResponseCode?: Maybe<Scalars['String']['output']>;
  reviewResponseStatus?: Maybe<ReviewResponseStatus>;
};

/** A filter to be used against `AssignedQuestionsRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignedQuestionsRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignedQuestionsRecordFilter>>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecisionFilter>;
  /** Filter by the object’s `isLastestReview` field. */
  isLastestReview?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOptional` field. */
  isOptional?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignedQuestionsRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignedQuestionsRecordFilter>>;
  /** Filter by the object’s `responseId` field. */
  responseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponseCode` field. */
  reviewResponseCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewResponseStatus` field. */
  reviewResponseStatus?: InputMaybe<ReviewResponseStatusFilter>;
};

export type AssignedSectionsByStageAndLevel = {
  __typename?: 'AssignedSectionsByStageAndLevel';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assignedInProgressSections?: Maybe<Scalars['BigInt']['output']>;
  assignedSectionForLevel?: Maybe<Scalars['BigInt']['output']>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `AssignedSectionsByStageAndLevel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AssignedSectionsByStageAndLevelCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assignedInProgressSections` field. */
  assignedInProgressSections?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `assignedSectionForLevel` field. */
  assignedSectionForLevel?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `AssignedSectionsByStageAndLevel` object types. All fields are combined with a logical ‘and.’ */
export type AssignedSectionsByStageAndLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignedSectionsByStageAndLevelFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignedInProgressSections` field. */
  assignedInProgressSections?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `assignedSectionForLevel` field. */
  assignedSectionForLevel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignedSectionsByStageAndLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignedSectionsByStageAndLevelFilter>>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `AssignedSectionsByStageAndLevel` values. */
export type AssignedSectionsByStageAndLevelsConnection = {
  __typename?: 'AssignedSectionsByStageAndLevelsConnection';
  /** A list of edges which contains the `AssignedSectionsByStageAndLevel` and cursor to aid in pagination. */
  edges: Array<AssignedSectionsByStageAndLevelsEdge>;
  /** A list of `AssignedSectionsByStageAndLevel` objects. */
  nodes: Array<Maybe<AssignedSectionsByStageAndLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssignedSectionsByStageAndLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignedSectionsByStageAndLevel` edge in the connection. */
export type AssignedSectionsByStageAndLevelsEdge = {
  __typename?: 'AssignedSectionsByStageAndLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignedSectionsByStageAndLevel` at the end of the edge. */
  node?: Maybe<AssignedSectionsByStageAndLevel>;
};

/** Methods to use when ordering `AssignedSectionsByStageAndLevel`. */
export enum AssignedSectionsByStageAndLevelsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AssignedInProgressSectionsAsc = 'ASSIGNED_IN_PROGRESS_SECTIONS_ASC',
  AssignedInProgressSectionsDesc = 'ASSIGNED_IN_PROGRESS_SECTIONS_DESC',
  AssignedSectionForLevelAsc = 'ASSIGNED_SECTION_FOR_LEVEL_ASC',
  AssignedSectionForLevelDesc = 'ASSIGNED_SECTION_FOR_LEVEL_DESC',
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC'
}

export enum AssignerAction {
  Assign = 'ASSIGN',
  ReAssign = 'RE_ASSIGN'
}

/** A filter to be used against AssignerAction fields. All fields are combined with a logical ‘and.’ */
export type AssignerActionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AssignerAction>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AssignerAction>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AssignerAction>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AssignerAction>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<AssignerAction>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<AssignerAction>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AssignerAction>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AssignerAction>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AssignerAction>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AssignerAction>>;
};

/** A connection to a list of `AssignerListRecord` values. */
export type AssignerListConnection = {
  __typename?: 'AssignerListConnection';
  /** A list of edges which contains the `AssignerListRecord` and cursor to aid in pagination. */
  edges: Array<AssignerListEdge>;
  /** A list of `AssignerListRecord` objects. */
  nodes: Array<Maybe<AssignerListRecord>>;
  /** The count of *all* `AssignerListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignerListRecord` edge in the connection. */
export type AssignerListEdge = {
  __typename?: 'AssignerListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignerListRecord` at the end of the edge. */
  node?: Maybe<AssignerListRecord>;
};

/** The return type of our `assignerList` query. */
export type AssignerListRecord = {
  __typename?: 'AssignerListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assignerAction?: Maybe<AssignerAction>;
};

/** A filter to be used against `AssignerListRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignerListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignerListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignerListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignerListRecordFilter>>;
};

/** A connection to a list of `AssignmentListRecord` values. */
export type AssignmentListConnection = {
  __typename?: 'AssignmentListConnection';
  /** A list of edges which contains the `AssignmentListRecord` and cursor to aid in pagination. */
  edges: Array<AssignmentListEdge>;
  /** A list of `AssignmentListRecord` objects. */
  nodes: Array<Maybe<AssignmentListRecord>>;
  /** The count of *all* `AssignmentListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignmentListRecord` edge in the connection. */
export type AssignmentListEdge = {
  __typename?: 'AssignmentListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignmentListRecord` at the end of the edge. */
  node?: Maybe<AssignmentListRecord>;
};

/** The return type of our `assignmentList` query. */
export type AssignmentListRecord = {
  __typename?: 'AssignmentListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assigners?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  reviewers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A filter to be used against `AssignmentListRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignmentListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignmentListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assigners` field. */
  assigners?: InputMaybe<StringListFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignmentListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignmentListRecordFilter>>;
  /** Filter by the object’s `reviewers` field. */
  reviewers?: InputMaybe<StringListFilter>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** A filter to be used against CharacterData fields. All fields are combined with a logical ‘and.’ */
export type CharacterDataFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
};

export type ConstraintsInfo = {
  __typename?: 'ConstraintsInfo';
  constraintType?: Maybe<Scalars['CharacterData']['output']>;
  fromColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  fromTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  toColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  toTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
};

/** A condition to be used against `ConstraintsInfo` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ConstraintsInfoCondition = {
  /** Checks for equality with the object’s `constraintType` field. */
  constraintType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `fromColumnName` field. */
  fromColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `fromTableName` field. */
  fromTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `toColumnName` field. */
  toColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `toTableName` field. */
  toTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
};

/** A filter to be used against `ConstraintsInfo` object types. All fields are combined with a logical ‘and.’ */
export type ConstraintsInfoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ConstraintsInfoFilter>>;
  /** Filter by the object’s `constraintType` field. */
  constraintType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `fromColumnName` field. */
  fromColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `fromTableName` field. */
  fromTableName?: InputMaybe<SqlIdentifierFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ConstraintsInfoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ConstraintsInfoFilter>>;
  /** Filter by the object’s `toColumnName` field. */
  toColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `toTableName` field. */
  toTableName?: InputMaybe<SqlIdentifierFilter>;
};

/** A connection to a list of `ConstraintsInfo` values. */
export type ConstraintsInfosConnection = {
  __typename?: 'ConstraintsInfosConnection';
  /** A list of edges which contains the `ConstraintsInfo` and cursor to aid in pagination. */
  edges: Array<ConstraintsInfosEdge>;
  /** A list of `ConstraintsInfo` objects. */
  nodes: Array<Maybe<ConstraintsInfo>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ConstraintsInfo` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ConstraintsInfo` edge in the connection. */
export type ConstraintsInfosEdge = {
  __typename?: 'ConstraintsInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ConstraintsInfo` at the end of the edge. */
  node?: Maybe<ConstraintsInfo>;
};

/** Methods to use when ordering `ConstraintsInfo`. */
export enum ConstraintsInfosOrderBy {
  ConstraintTypeAsc = 'CONSTRAINT_TYPE_ASC',
  ConstraintTypeDesc = 'CONSTRAINT_TYPE_DESC',
  FromColumnNameAsc = 'FROM_COLUMN_NAME_ASC',
  FromColumnNameDesc = 'FROM_COLUMN_NAME_DESC',
  FromTableNameAsc = 'FROM_TABLE_NAME_ASC',
  FromTableNameDesc = 'FROM_TABLE_NAME_DESC',
  Natural = 'NATURAL',
  ToColumnNameAsc = 'TO_COLUMN_NAME_ASC',
  ToColumnNameDesc = 'TO_COLUMN_NAME_DESC',
  ToTableNameAsc = 'TO_TABLE_NAME_ASC',
  ToTableNameDesc = 'TO_TABLE_NAME_DESC'
}

export type Counter = Node & {
  __typename?: 'Counter';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  value?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Counter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CounterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Counter` object types. All fields are combined with a logical ‘and.’ */
export type CounterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CounterFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CounterFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CounterFilter>>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Counter` */
export type CounterInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Counter`. Fields that are set will be updated. */
export type CounterPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Counter` values. */
export type CountersConnection = {
  __typename?: 'CountersConnection';
  /** A list of edges which contains the `Counter` and cursor to aid in pagination. */
  edges: Array<CountersEdge>;
  /** A list of `Counter` objects. */
  nodes: Array<Maybe<Counter>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Counter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Counter` edge in the connection. */
export type CountersEdge = {
  __typename?: 'CountersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Counter` at the end of the edge. */
  node?: Maybe<Counter>;
};

/** Methods to use when ordering `Counter`. */
export enum CountersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

/** All input for the create `ActionPlugin` mutation. */
export type CreateActionPluginInput = {
  /** The `ActionPlugin` to be created by this mutation. */
  actionPlugin: ActionPluginInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayload = {
  __typename?: 'CreateActionPluginPayload';
  /** The `ActionPlugin` that was created by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the create `ActionQueue` mutation. */
export type CreateActionQueueInput = {
  /** The `ActionQueue` to be created by this mutation. */
  actionQueue: ActionQueueInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayload = {
  __typename?: 'CreateActionQueuePayload';
  /** The `ActionQueue` that was created by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the create `ActivityLog` mutation. */
export type CreateActivityLogInput = {
  /** The `ActivityLog` to be created by this mutation. */
  activityLog: ActivityLogInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActivityLog` mutation. */
export type CreateActivityLogPayload = {
  __typename?: 'CreateActivityLogPayload';
  /** The `ActivityLog` that was created by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ActivityLog` mutation. */
export type CreateActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the create `Application` mutation. */
export type CreateApplicationInput = {
  /** The `Application` to be created by this mutation. */
  application: ApplicationInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `ApplicationListShape` mutation. */
export type CreateApplicationListShapeInput = {
  /** The `ApplicationListShape` to be created by this mutation. */
  applicationListShape: ApplicationListShapeInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationListShape` mutation. */
export type CreateApplicationListShapePayload = {
  __typename?: 'CreateApplicationListShapePayload';
  /** The `ApplicationListShape` that was created by this mutation. */
  applicationListShape?: Maybe<ApplicationListShape>;
  /** An edge for our `ApplicationListShape`. May be used by Relay 1. */
  applicationListShapeEdge?: Maybe<ApplicationListShapesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ApplicationListShape` mutation. */
export type CreateApplicationListShapePayloadApplicationListShapeEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
};

/** All input for the create `ApplicationNote` mutation. */
export type CreateApplicationNoteInput = {
  /** The `ApplicationNote` to be created by this mutation. */
  applicationNote: ApplicationNoteInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationNote` mutation. */
export type CreateApplicationNotePayload = {
  __typename?: 'CreateApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was created by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ApplicationNote`. */
  user?: Maybe<User>;
};


/** The output of our create `ApplicationNote` mutation. */
export type CreateApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** The output of our create `Application` mutation. */
export type CreateApplicationPayload = {
  __typename?: 'CreateApplicationPayload';
  /** The `Application` that was created by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
};


/** The output of our create `Application` mutation. */
export type CreateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the create `ApplicationResponse` mutation. */
export type CreateApplicationResponseInput = {
  /** The `ApplicationResponse` to be created by this mutation. */
  applicationResponse: ApplicationResponseInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayload = {
  __typename?: 'CreateApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was created by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryInput = {
  /** The `ApplicationStageHistory` to be created by this mutation. */
  applicationStageHistory: ApplicationStageHistoryInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayload = {
  __typename?: 'CreateApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was created by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryInput = {
  /** The `ApplicationStatusHistory` to be created by this mutation. */
  applicationStatusHistory: ApplicationStatusHistoryInput;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayload = {
  __typename?: 'CreateApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was created by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the create `Counter` mutation. */
export type CreateCounterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Counter` to be created by this mutation. */
  counter: CounterInput;
};

/** The output of our create `Counter` mutation. */
export type CreateCounterPayload = {
  __typename?: 'CreateCounterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was created by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Counter` mutation. */
export type CreateCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableActiveIngredient` to be created by this mutation. */
  dataTableActiveIngredient: DataTableActiveIngredientInput;
};

/** The output of our create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientPayload = {
  __typename?: 'CreateDataTableActiveIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was created by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRouteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAdministrationRoute` to be created by this mutation. */
  dataTableAdministrationRoute: DataTableAdministrationRouteInput;
};

/** The output of our create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRoutePayload = {
  __typename?: 'CreateDataTableAdministrationRoutePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was created by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the create `DataTableAnnex2` mutation. */
export type CreateDataTableAnnex2Input = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAnnex2` to be created by this mutation. */
  dataTableAnnex2: DataTableAnnex2Input;
};

/** The output of our create `DataTableAnnex2` mutation. */
export type CreateDataTableAnnex2Payload = {
  __typename?: 'CreateDataTableAnnex2Payload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex2` that was created by this mutation. */
  dataTableAnnex2?: Maybe<DataTableAnnex2>;
  /** An edge for our `DataTableAnnex2`. May be used by Relay 1. */
  dataTableAnnex2Edge?: Maybe<DataTableAnnex2sEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAnnex2` mutation. */
export type CreateDataTableAnnex2PayloadDataTableAnnex2EdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnex2sOrderBy>>;
};

/** All input for the create `DataTableAnnex` mutation. */
export type CreateDataTableAnnexInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAnnex` to be created by this mutation. */
  dataTableAnnex: DataTableAnnexInput;
};

/** The output of our create `DataTableAnnex` mutation. */
export type CreateDataTableAnnexPayload = {
  __typename?: 'CreateDataTableAnnexPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex` that was created by this mutation. */
  dataTableAnnex?: Maybe<DataTableAnnex>;
  /** An edge for our `DataTableAnnex`. May be used by Relay 1. */
  dataTableAnnexEdge?: Maybe<DataTableAnnexesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAnnex` mutation. */
export type CreateDataTableAnnexPayloadDataTableAnnexEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnexesOrderBy>>;
};

/** All input for the create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAtcCode` to be created by this mutation. */
  dataTableAtcCode: DataTableAtcCodeInput;
};

/** The output of our create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodePayload = {
  __typename?: 'CreateDataTableAtcCodePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was created by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the create `DataTableAtcTherapeuticCategory` mutation. */
export type CreateDataTableAtcTherapeuticCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAtcTherapeuticCategory` to be created by this mutation. */
  dataTableAtcTherapeuticCategory: DataTableAtcTherapeuticCategoryInput;
};

/** The output of our create `DataTableAtcTherapeuticCategory` mutation. */
export type CreateDataTableAtcTherapeuticCategoryPayload = {
  __typename?: 'CreateDataTableAtcTherapeuticCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcTherapeuticCategory` that was created by this mutation. */
  dataTableAtcTherapeuticCategory?: Maybe<DataTableAtcTherapeuticCategory>;
  /** An edge for our `DataTableAtcTherapeuticCategory`. May be used by Relay 1. */
  dataTableAtcTherapeuticCategoryEdge?: Maybe<DataTableAtcTherapeuticCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAtcTherapeuticCategory` mutation. */
export type CreateDataTableAtcTherapeuticCategoryPayloadDataTableAtcTherapeuticCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcTherapeuticCategoriesOrderBy>>;
};

/** All input for the create `DataTableContainer` mutation. */
export type CreateDataTableContainerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableContainer` to be created by this mutation. */
  dataTableContainer: DataTableContainerInput;
};

/** The output of our create `DataTableContainer` mutation. */
export type CreateDataTableContainerPayload = {
  __typename?: 'CreateDataTableContainerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was created by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableContainer` mutation. */
export type CreateDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the create `DataTableCountry` mutation. */
export type CreateDataTableCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableCountry` to be created by this mutation. */
  dataTableCountry: DataTableCountryInput;
};

/** The output of our create `DataTableCountry` mutation. */
export type CreateDataTableCountryPayload = {
  __typename?: 'CreateDataTableCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was created by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableCountry` mutation. */
export type CreateDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableDosageForm` to be created by this mutation. */
  dataTableDosageForm: DataTableDosageFormInput;
};

/** The output of our create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormPayload = {
  __typename?: 'CreateDataTableDosageFormPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was created by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableGenericIngredient` to be created by this mutation. */
  dataTableGenericIngredient: DataTableGenericIngredientInput;
};

/** The output of our create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientPayload = {
  __typename?: 'CreateDataTableGenericIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was created by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the create `DataTableIngredientsList` mutation. */
export type CreateDataTableIngredientsListInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableIngredientsList` to be created by this mutation. */
  dataTableIngredientsList: DataTableIngredientsListInput;
};

/** The output of our create `DataTableIngredientsList` mutation. */
export type CreateDataTableIngredientsListPayload = {
  __typename?: 'CreateDataTableIngredientsListPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableIngredientsList` that was created by this mutation. */
  dataTableIngredientsList?: Maybe<DataTableIngredientsList>;
  /** An edge for our `DataTableIngredientsList`. May be used by Relay 1. */
  dataTableIngredientsListEdge?: Maybe<DataTableIngredientsListsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableIngredientsList` mutation. */
export type CreateDataTableIngredientsListPayloadDataTableIngredientsListEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableIngredientsListsOrderBy>>;
};

/** All input for the create `DataTable` mutation. */
export type CreateDataTableInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTable` to be created by this mutation. */
  dataTable: DataTableInput;
};

/** All input for the create `DataTableListOfSra` mutation. */
export type CreateDataTableListOfSraInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableListOfSra` to be created by this mutation. */
  dataTableListOfSra: DataTableListOfSraInput;
};

/** The output of our create `DataTableListOfSra` mutation. */
export type CreateDataTableListOfSraPayload = {
  __typename?: 'CreateDataTableListOfSraPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableListOfSra` that was created by this mutation. */
  dataTableListOfSra?: Maybe<DataTableListOfSra>;
  /** An edge for our `DataTableListOfSra`. May be used by Relay 1. */
  dataTableListOfSraEdge?: Maybe<DataTableListOfSrasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableListOfSra` mutation. */
export type CreateDataTableListOfSraPayloadDataTableListOfSraEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableListOfSrasOrderBy>>;
};

/** All input for the create `DataTableManufacturingStep` mutation. */
export type CreateDataTableManufacturingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableManufacturingStep` to be created by this mutation. */
  dataTableManufacturingStep: DataTableManufacturingStepInput;
};

/** The output of our create `DataTableManufacturingStep` mutation. */
export type CreateDataTableManufacturingStepPayload = {
  __typename?: 'CreateDataTableManufacturingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturingStep` that was created by this mutation. */
  dataTableManufacturingStep?: Maybe<DataTableManufacturingStep>;
  /** An edge for our `DataTableManufacturingStep`. May be used by Relay 1. */
  dataTableManufacturingStepEdge?: Maybe<DataTableManufacturingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableManufacturingStep` mutation. */
export type CreateDataTableManufacturingStepPayloadDataTableManufacturingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturingStepsOrderBy>>;
};

/** The output of our create `DataTable` mutation. */
export type CreateDataTablePayload = {
  __typename?: 'CreateDataTablePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was created by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTable` mutation. */
export type CreateDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProcessingStep` to be created by this mutation. */
  dataTableProcessingStep: DataTableProcessingStepInput;
};

/** The output of our create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepPayload = {
  __typename?: 'CreateDataTableProcessingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was created by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProductApplicationJoin` to be created by this mutation. */
  dataTableProductApplicationJoin: DataTableProductApplicationJoinInput;
};

/** The output of our create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinPayload = {
  __typename?: 'CreateDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProduct` that is related to this `DataTableProductApplicationJoin`. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** The `DataTableProductApplicationJoin` that was created by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTableProduct` mutation. */
export type CreateDataTableProductInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProduct` to be created by this mutation. */
  dataTableProduct: DataTableProductInput;
};

/** The output of our create `DataTableProduct` mutation. */
export type CreateDataTableProductPayload = {
  __typename?: 'CreateDataTableProductPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was created by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProduct` mutation. */
export type CreateDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the create `DataTableProvince` mutation. */
export type CreateDataTableProvinceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProvince` to be created by this mutation. */
  dataTableProvince: DataTableProvinceInput;
};

/** The output of our create `DataTableProvince` mutation. */
export type CreateDataTableProvincePayload = {
  __typename?: 'CreateDataTableProvincePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvince` that was created by this mutation. */
  dataTableProvince?: Maybe<DataTableProvince>;
  /** An edge for our `DataTableProvince`. May be used by Relay 1. */
  dataTableProvinceEdge?: Maybe<DataTableProvincesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProvince` mutation. */
export type CreateDataTableProvincePayloadDataTableProvinceEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvincesOrderBy>>;
};

/** All input for the create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableStorageCondition` to be created by this mutation. */
  dataTableStorageCondition: DataTableStorageConditionInput;
};

/** The output of our create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionPayload = {
  __typename?: 'CreateDataTableStorageConditionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was created by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableUnitsOfProportion` to be created by this mutation. */
  dataTableUnitsOfProportion: DataTableUnitsOfProportionInput;
};

/** The output of our create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionPayload = {
  __typename?: 'CreateDataTableUnitsOfProportionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was created by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataViewColumnDefinition` to be created by this mutation. */
  dataViewColumnDefinition: DataViewColumnDefinitionInput;
};

/** The output of our create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionPayload = {
  __typename?: 'CreateDataViewColumnDefinitionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was created by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the create `DataView` mutation. */
export type CreateDataViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataView` to be created by this mutation. */
  dataView: DataViewInput;
};

/** The output of our create `DataView` mutation. */
export type CreateDataViewPayload = {
  __typename?: 'CreateDataViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was created by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataView` mutation. */
export type CreateDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ElementTypePlugin` to be created by this mutation. */
  elementTypePlugin: ElementTypePluginInput;
};

/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayload = {
  __typename?: 'CreateElementTypePluginPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ElementTypePlugin` that was created by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the create `File` mutation. */
export type CreateFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `File` to be created by this mutation. */
  file: FileInput;
};

/** The output of our create `File` mutation. */
export type CreateFilePayload = {
  __typename?: 'CreateFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `File` that was created by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
};


/** The output of our create `File` mutation. */
export type CreateFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the create `Filter` mutation. */
export type CreateFilterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Filter` to be created by this mutation. */
  filter: FilterInput;
};

/** The output of our create `Filter` mutation. */
export type CreateFilterPayload = {
  __typename?: 'CreateFilterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was created by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Filter` mutation. */
export type CreateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the create `Notification` mutation. */
export type CreateNotificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Notification` to be created by this mutation. */
  notification: NotificationInput;
};

/** The output of our create `Notification` mutation. */
export type CreateNotificationPayload = {
  __typename?: 'CreateNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
};


/** The output of our create `Notification` mutation. */
export type CreateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OrganisationApplicationJoin` to be created by this mutation. */
  organisationApplicationJoin: OrganisationApplicationJoinInput;
};

/** The output of our create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinPayload = {
  __typename?: 'CreateOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was created by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the create `Organisation` mutation. */
export type CreateOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Organisation` to be created by this mutation. */
  organisation: OrganisationInput;
};

/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayload = {
  __typename?: 'CreateOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organisation` that was created by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the create `PermissionJoin` mutation. */
export type CreatePermissionJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionJoin` to be created by this mutation. */
  permissionJoin: PermissionJoinInput;
};

/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayload = {
  __typename?: 'CreatePermissionJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was created by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
};


/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the create `PermissionName` mutation. */
export type CreatePermissionNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionName` to be created by this mutation. */
  permissionName: PermissionNameInput;
};

/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayload = {
  __typename?: 'CreatePermissionNamePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionName` that was created by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionPolicy` to be created by this mutation. */
  permissionPolicy: PermissionPolicyInput;
};

/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayload = {
  __typename?: 'CreatePermissionPolicyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionPolicy` that was created by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the create `ProductApplicationJoin` mutation. */
export type CreateProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ProductApplicationJoin` to be created by this mutation. */
  productApplicationJoin: ProductApplicationJoinInput;
};

/** The output of our create `ProductApplicationJoin` mutation. */
export type CreateProductApplicationJoinPayload = {
  __typename?: 'CreateProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `ProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ProductApplicationJoin` that was created by this mutation. */
  productApplicationJoin?: Maybe<ProductApplicationJoin>;
  /** An edge for our `ProductApplicationJoin`. May be used by Relay 1. */
  productApplicationJoinEdge?: Maybe<ProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ProductApplicationJoin` mutation. */
export type CreateProductApplicationJoinPayloadProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductApplicationJoinsOrderBy>>;
};

/** All input for the create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewAssignmentAssignerJoin` to be created by this mutation. */
  reviewAssignmentAssignerJoin: ReviewAssignmentAssignerJoinInput;
};

/** The output of our create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinPayload = {
  __typename?: 'CreateReviewAssignmentAssignerJoinPayload';
  /** Reads a single `User` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was created by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewAssignment` to be created by this mutation. */
  reviewAssignment: ReviewAssignmentInput;
};

/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayload = {
  __typename?: 'CreateReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was created by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the create `ReviewDecision` mutation. */
export type CreateReviewDecisionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewDecision` to be created by this mutation. */
  reviewDecision: ReviewDecisionInput;
};

/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayload = {
  __typename?: 'CreateReviewDecisionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was created by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the create `Review` mutation. */
export type CreateReviewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Review` to be created by this mutation. */
  review: ReviewInput;
};

/** The output of our create `Review` mutation. */
export type CreateReviewPayload = {
  __typename?: 'CreateReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was created by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
};


/** The output of our create `Review` mutation. */
export type CreateReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the create `ReviewResponse` mutation. */
export type CreateReviewResponseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewResponse` to be created by this mutation. */
  reviewResponse: ReviewResponseInput;
};

/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayload = {
  __typename?: 'CreateReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was created by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewStatusHistory` to be created by this mutation. */
  reviewStatusHistory: ReviewStatusHistoryInput;
};

/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayload = {
  __typename?: 'CreateReviewStatusHistoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was created by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the create `SystemInfo` mutation. */
export type CreateSystemInfoInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SystemInfo` to be created by this mutation. */
  systemInfo: SystemInfoInput;
};

/** The output of our create `SystemInfo` mutation. */
export type CreateSystemInfoPayload = {
  __typename?: 'CreateSystemInfoPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was created by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our create `SystemInfo` mutation. */
export type CreateSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the create `TemplateAction` mutation. */
export type CreateTemplateActionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateAction` to be created by this mutation. */
  templateAction: TemplateActionInput;
};

/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayload = {
  __typename?: 'CreateTemplateActionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was created by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the create `TemplateCategory` mutation. */
export type CreateTemplateCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateCategory` to be created by this mutation. */
  templateCategory: TemplateCategoryInput;
};

/** The output of our create `TemplateCategory` mutation. */
export type CreateTemplateCategoryPayload = {
  __typename?: 'CreateTemplateCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was created by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our create `TemplateCategory` mutation. */
export type CreateTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the create `TemplateElement` mutation. */
export type CreateTemplateElementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateElement` to be created by this mutation. */
  templateElement: TemplateElementInput;
};

/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayload = {
  __typename?: 'CreateTemplateElementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was created by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateFilterJoin` to be created by this mutation. */
  templateFilterJoin: TemplateFilterJoinInput;
};

/** The output of our create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinPayload = {
  __typename?: 'CreateTemplateFilterJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was created by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the create `Template` mutation. */
export type CreateTemplateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Template` to be created by this mutation. */
  template: TemplateInput;
};

/** The output of our create `Template` mutation. */
export type CreateTemplatePayload = {
  __typename?: 'CreateTemplatePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was created by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our create `Template` mutation. */
export type CreateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the create `TemplatePermission` mutation. */
export type CreateTemplatePermissionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplatePermission` to be created by this mutation. */
  templatePermission: TemplatePermissionInput;
};

/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayload = {
  __typename?: 'CreateTemplatePermissionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was created by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the create `TemplateSection` mutation. */
export type CreateTemplateSectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateSection` to be created by this mutation. */
  templateSection: TemplateSectionInput;
};

/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayload = {
  __typename?: 'CreateTemplateSectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was created by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the create `TemplateStage` mutation. */
export type CreateTemplateStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateStage` to be created by this mutation. */
  templateStage: TemplateStageInput;
};

/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayload = {
  __typename?: 'CreateTemplateStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was created by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateStageReviewLevel` to be created by this mutation. */
  templateStageReviewLevel: TemplateStageReviewLevelInput;
};

/** The output of our create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelPayload = {
  __typename?: 'CreateTemplateStageReviewLevelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was created by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the create `TriggerQueue` mutation. */
export type CreateTriggerQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TriggerQueue` to be created by this mutation. */
  triggerQueue: TriggerQueueInput;
};

/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayload = {
  __typename?: 'CreateTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was created by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the create `TriggerSchedule` mutation. */
export type CreateTriggerScheduleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TriggerSchedule` to be created by this mutation. */
  triggerSchedule: TriggerScheduleInput;
};

/** The output of our create `TriggerSchedule` mutation. */
export type CreateTriggerSchedulePayload = {
  __typename?: 'CreateTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `TriggerSchedule`. */
  editorUser?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was created by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our create `TriggerSchedule` mutation. */
export type CreateTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserApplicationJoin` to be created by this mutation. */
  userApplicationJoin: UserApplicationJoinInput;
};

/** The output of our create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinPayload = {
  __typename?: 'CreateUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserApplicationJoin`. */
  user?: Maybe<User>;
  /** The `UserApplicationJoin` that was created by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserOrganisationApplicationJoin` mutation. */
export type CreateUserOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserOrganisationApplicationJoin` to be created by this mutation. */
  userOrganisationApplicationJoin: UserOrganisationApplicationJoinInput;
};

/** The output of our create `UserOrganisationApplicationJoin` mutation. */
export type CreateUserOrganisationApplicationJoinPayload = {
  __typename?: 'CreateUserOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserOrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserOrganisation` that is related to this `UserOrganisationApplicationJoin`. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** The `UserOrganisationApplicationJoin` that was created by this mutation. */
  userOrganisationApplicationJoin?: Maybe<UserOrganisationApplicationJoin>;
  /** An edge for our `UserOrganisationApplicationJoin`. May be used by Relay 1. */
  userOrganisationApplicationJoinEdge?: Maybe<UserOrganisationApplicationJoinsEdge>;
};


/** The output of our create `UserOrganisationApplicationJoin` mutation. */
export type CreateUserOrganisationApplicationJoinPayloadUserOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};

/** All input for the create `UserOrganisation` mutation. */
export type CreateUserOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserOrganisation` to be created by this mutation. */
  userOrganisation: UserOrganisationInput;
};

/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayload = {
  __typename?: 'CreateUserOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was created by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `Verification` mutation. */
export type CreateVerificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Verification` to be created by this mutation. */
  verification: VerificationInput;
};

/** The output of our create `Verification` mutation. */
export type CreateVerificationPayload = {
  __typename?: 'CreateVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was created by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our create `Verification` mutation. */
export type CreateVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type DataTable = Node & {
  __typename?: 'DataTable';
  dataViewCode?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  fieldMap?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  isLookupTable?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  tableName: Scalars['String']['output'];
};

export type DataTableActiveIngredient = Node & {
  __typename?: 'DataTableActiveIngredient';
  id: Scalars['Int']['output'];
  latina?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `DataTableActiveIngredient` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableActiveIngredientCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `latina` field. */
  latina?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableActiveIngredient` object types. All fields are combined with a logical ‘and.’ */
export type DataTableActiveIngredientFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableActiveIngredientFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `latina` field. */
  latina?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableActiveIngredientFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableActiveIngredientFilter>>;
};

/** An input for mutations affecting `DataTableActiveIngredient` */
export type DataTableActiveIngredientInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  latina?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableActiveIngredient`. Fields that are set will be updated. */
export type DataTableActiveIngredientPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  latina?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableActiveIngredient` values. */
export type DataTableActiveIngredientsConnection = {
  __typename?: 'DataTableActiveIngredientsConnection';
  /** A list of edges which contains the `DataTableActiveIngredient` and cursor to aid in pagination. */
  edges: Array<DataTableActiveIngredientsEdge>;
  /** A list of `DataTableActiveIngredient` objects. */
  nodes: Array<Maybe<DataTableActiveIngredient>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableActiveIngredient` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableActiveIngredient` edge in the connection. */
export type DataTableActiveIngredientsEdge = {
  __typename?: 'DataTableActiveIngredientsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableActiveIngredient` at the end of the edge. */
  node?: Maybe<DataTableActiveIngredient>;
};

/** Methods to use when ordering `DataTableActiveIngredient`. */
export enum DataTableActiveIngredientsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatinaAsc = 'LATINA_ASC',
  LatinaDesc = 'LATINA_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableAdministrationRoute = Node & {
  __typename?: 'DataTableAdministrationRoute';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `DataTableAdministrationRoute` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableAdministrationRouteCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAdministrationRoute` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAdministrationRouteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAdministrationRouteFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAdministrationRouteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAdministrationRouteFilter>>;
};

/** An input for mutations affecting `DataTableAdministrationRoute` */
export type DataTableAdministrationRouteInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAdministrationRoute`. Fields that are set will be updated. */
export type DataTableAdministrationRoutePatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAdministrationRoute` values. */
export type DataTableAdministrationRoutesConnection = {
  __typename?: 'DataTableAdministrationRoutesConnection';
  /** A list of edges which contains the `DataTableAdministrationRoute` and cursor to aid in pagination. */
  edges: Array<DataTableAdministrationRoutesEdge>;
  /** A list of `DataTableAdministrationRoute` objects. */
  nodes: Array<Maybe<DataTableAdministrationRoute>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAdministrationRoute` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAdministrationRoute` edge in the connection. */
export type DataTableAdministrationRoutesEdge = {
  __typename?: 'DataTableAdministrationRoutesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAdministrationRoute` at the end of the edge. */
  node?: Maybe<DataTableAdministrationRoute>;
};

/** Methods to use when ordering `DataTableAdministrationRoute`. */
export enum DataTableAdministrationRoutesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableAnnex = Node & {
  __typename?: 'DataTableAnnex';
  country?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  source?: Maybe<Scalars['String']['output']>;
};

export type DataTableAnnex2 = Node & {
  __typename?: 'DataTableAnnex2';
  country?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  source?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableAnnex2` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableAnnex2Condition = {
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `source` field. */
  source?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAnnex2` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAnnex2Filter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAnnex2Filter>>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAnnex2Filter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAnnex2Filter>>;
  /** Filter by the object’s `source` field. */
  source?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAnnex2` */
export type DataTableAnnex2Input = {
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAnnex2`. Fields that are set will be updated. */
export type DataTableAnnex2Patch = {
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAnnex2` values. */
export type DataTableAnnex2sConnection = {
  __typename?: 'DataTableAnnex2sConnection';
  /** A list of edges which contains the `DataTableAnnex2` and cursor to aid in pagination. */
  edges: Array<DataTableAnnex2sEdge>;
  /** A list of `DataTableAnnex2` objects. */
  nodes: Array<Maybe<DataTableAnnex2>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAnnex2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAnnex2` edge in the connection. */
export type DataTableAnnex2sEdge = {
  __typename?: 'DataTableAnnex2sEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAnnex2` at the end of the edge. */
  node?: Maybe<DataTableAnnex2>;
};

/** Methods to use when ordering `DataTableAnnex2`. */
export enum DataTableAnnex2sOrderBy {
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC'
}

/** A condition to be used against `DataTableAnnex` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableAnnexCondition = {
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `source` field. */
  source?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAnnex` values. */
export type DataTableAnnexesConnection = {
  __typename?: 'DataTableAnnexesConnection';
  /** A list of edges which contains the `DataTableAnnex` and cursor to aid in pagination. */
  edges: Array<DataTableAnnexesEdge>;
  /** A list of `DataTableAnnex` objects. */
  nodes: Array<Maybe<DataTableAnnex>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAnnex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAnnex` edge in the connection. */
export type DataTableAnnexesEdge = {
  __typename?: 'DataTableAnnexesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAnnex` at the end of the edge. */
  node?: Maybe<DataTableAnnex>;
};

/** Methods to use when ordering `DataTableAnnex`. */
export enum DataTableAnnexesOrderBy {
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC'
}

/** A filter to be used against `DataTableAnnex` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAnnexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAnnexFilter>>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAnnexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAnnexFilter>>;
  /** Filter by the object’s `source` field. */
  source?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAnnex` */
export type DataTableAnnexInput = {
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAnnex`. Fields that are set will be updated. */
export type DataTableAnnexPatch = {
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

export type DataTableAtcCode = Node & {
  __typename?: 'DataTableAtcCode';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableAtcCode` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableAtcCodeCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAtcCode` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAtcCodeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAtcCodeFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAtcCodeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAtcCodeFilter>>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAtcCode` */
export type DataTableAtcCodeInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAtcCode`. Fields that are set will be updated. */
export type DataTableAtcCodePatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAtcCode` values. */
export type DataTableAtcCodesConnection = {
  __typename?: 'DataTableAtcCodesConnection';
  /** A list of edges which contains the `DataTableAtcCode` and cursor to aid in pagination. */
  edges: Array<DataTableAtcCodesEdge>;
  /** A list of `DataTableAtcCode` objects. */
  nodes: Array<Maybe<DataTableAtcCode>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAtcCode` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAtcCode` edge in the connection. */
export type DataTableAtcCodesEdge = {
  __typename?: 'DataTableAtcCodesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAtcCode` at the end of the edge. */
  node?: Maybe<DataTableAtcCode>;
};

/** Methods to use when ordering `DataTableAtcCode`. */
export enum DataTableAtcCodesOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

/** A connection to a list of `DataTableAtcTherapeuticCategory` values. */
export type DataTableAtcTherapeuticCategoriesConnection = {
  __typename?: 'DataTableAtcTherapeuticCategoriesConnection';
  /** A list of edges which contains the `DataTableAtcTherapeuticCategory` and cursor to aid in pagination. */
  edges: Array<DataTableAtcTherapeuticCategoriesEdge>;
  /** A list of `DataTableAtcTherapeuticCategory` objects. */
  nodes: Array<Maybe<DataTableAtcTherapeuticCategory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAtcTherapeuticCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAtcTherapeuticCategory` edge in the connection. */
export type DataTableAtcTherapeuticCategoriesEdge = {
  __typename?: 'DataTableAtcTherapeuticCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAtcTherapeuticCategory` at the end of the edge. */
  node?: Maybe<DataTableAtcTherapeuticCategory>;
};

/** Methods to use when ordering `DataTableAtcTherapeuticCategory`. */
export enum DataTableAtcTherapeuticCategoriesOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

export type DataTableAtcTherapeuticCategory = Node & {
  __typename?: 'DataTableAtcTherapeuticCategory';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableAtcTherapeuticCategory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableAtcTherapeuticCategoryCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAtcTherapeuticCategory` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAtcTherapeuticCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAtcTherapeuticCategoryFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAtcTherapeuticCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAtcTherapeuticCategoryFilter>>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAtcTherapeuticCategory` */
export type DataTableAtcTherapeuticCategoryInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAtcTherapeuticCategory`. Fields that are set will be updated. */
export type DataTableAtcTherapeuticCategoryPatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A condition to be used against `DataTable` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableCondition = {
  /** Checks for equality with the object’s `dataViewCode` field. */
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldMap` field. */
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLookupTable` field. */
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

export type DataTableContainer = Node & {
  __typename?: 'DataTableContainer';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `DataTableContainer` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableContainerCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableContainer` object types. All fields are combined with a logical ‘and.’ */
export type DataTableContainerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableContainerFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableContainerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableContainerFilter>>;
};

/** An input for mutations affecting `DataTableContainer` */
export type DataTableContainerInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableContainer`. Fields that are set will be updated. */
export type DataTableContainerPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableContainer` values. */
export type DataTableContainersConnection = {
  __typename?: 'DataTableContainersConnection';
  /** A list of edges which contains the `DataTableContainer` and cursor to aid in pagination. */
  edges: Array<DataTableContainersEdge>;
  /** A list of `DataTableContainer` objects. */
  nodes: Array<Maybe<DataTableContainer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableContainer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableContainer` edge in the connection. */
export type DataTableContainersEdge = {
  __typename?: 'DataTableContainersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableContainer` at the end of the edge. */
  node?: Maybe<DataTableContainer>;
};

/** Methods to use when ordering `DataTableContainer`. */
export enum DataTableContainersOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `DataTableCountry` values. */
export type DataTableCountriesConnection = {
  __typename?: 'DataTableCountriesConnection';
  /** A list of edges which contains the `DataTableCountry` and cursor to aid in pagination. */
  edges: Array<DataTableCountriesEdge>;
  /** A list of `DataTableCountry` objects. */
  nodes: Array<Maybe<DataTableCountry>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableCountry` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableCountry` edge in the connection. */
export type DataTableCountriesEdge = {
  __typename?: 'DataTableCountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableCountry` at the end of the edge. */
  node?: Maybe<DataTableCountry>;
};

/** Methods to use when ordering `DataTableCountry`. */
export enum DataTableCountriesOrderBy {
  FlagAsc = 'FLAG_ASC',
  FlagDesc = 'FLAG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameCommonAsc = 'NAME_COMMON_ASC',
  NameCommonDesc = 'NAME_COMMON_DESC',
  NameOfficialAsc = 'NAME_OFFICIAL_ASC',
  NameOfficialDesc = 'NAME_OFFICIAL_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TranslationCommonNoAccentAsc = 'TRANSLATION_COMMON_NO_ACCENT_ASC',
  TranslationCommonNoAccentDesc = 'TRANSLATION_COMMON_NO_ACCENT_DESC',
  TranslationsPorCommonAsc = 'TRANSLATIONS_POR_COMMON_ASC',
  TranslationsPorCommonDesc = 'TRANSLATIONS_POR_COMMON_DESC',
  TranslationsPorOfficialAsc = 'TRANSLATIONS_POR_OFFICIAL_ASC',
  TranslationsPorOfficialDesc = 'TRANSLATIONS_POR_OFFICIAL_DESC'
}

export type DataTableCountry = Node & {
  __typename?: 'DataTableCountry';
  flag?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  nameCommon?: Maybe<Scalars['String']['output']>;
  nameOfficial?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  translationCommonNoAccent?: Maybe<Scalars['String']['output']>;
  translationsPorCommon?: Maybe<Scalars['String']['output']>;
  translationsPorOfficial?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableCountry` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableCountryCondition = {
  /** Checks for equality with the object’s `flag` field. */
  flag?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `nameCommon` field. */
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nameOfficial` field. */
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `translationCommonNoAccent` field. */
  translationCommonNoAccent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `translationsPorCommon` field. */
  translationsPorCommon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `translationsPorOfficial` field. */
  translationsPorOfficial?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableCountry` object types. All fields are combined with a logical ‘and.’ */
export type DataTableCountryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableCountryFilter>>;
  /** Filter by the object’s `flag` field. */
  flag?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `nameCommon` field. */
  nameCommon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nameOfficial` field. */
  nameOfficial?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableCountryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableCountryFilter>>;
  /** Filter by the object’s `translationCommonNoAccent` field. */
  translationCommonNoAccent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `translationsPorCommon` field. */
  translationsPorCommon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `translationsPorOfficial` field. */
  translationsPorOfficial?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableCountry` */
export type DataTableCountryInput = {
  flag?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  translationCommonNoAccent?: InputMaybe<Scalars['String']['input']>;
  translationsPorCommon?: InputMaybe<Scalars['String']['input']>;
  translationsPorOfficial?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableCountry`. Fields that are set will be updated. */
export type DataTableCountryPatch = {
  flag?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  translationCommonNoAccent?: InputMaybe<Scalars['String']['input']>;
  translationsPorCommon?: InputMaybe<Scalars['String']['input']>;
  translationsPorOfficial?: InputMaybe<Scalars['String']['input']>;
};

export type DataTableDosageForm = Node & {
  __typename?: 'DataTableDosageForm';
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `DataTableDosageForm` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableDosageFormCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableDosageForm` object types. All fields are combined with a logical ‘and.’ */
export type DataTableDosageFormFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableDosageFormFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableDosageFormFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableDosageFormFilter>>;
};

/** An input for mutations affecting `DataTableDosageForm` */
export type DataTableDosageFormInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableDosageForm`. Fields that are set will be updated. */
export type DataTableDosageFormPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableDosageForm` values. */
export type DataTableDosageFormsConnection = {
  __typename?: 'DataTableDosageFormsConnection';
  /** A list of edges which contains the `DataTableDosageForm` and cursor to aid in pagination. */
  edges: Array<DataTableDosageFormsEdge>;
  /** A list of `DataTableDosageForm` objects. */
  nodes: Array<Maybe<DataTableDosageForm>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableDosageForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableDosageForm` edge in the connection. */
export type DataTableDosageFormsEdge = {
  __typename?: 'DataTableDosageFormsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableDosageForm` at the end of the edge. */
  node?: Maybe<DataTableDosageForm>;
};

/** Methods to use when ordering `DataTableDosageForm`. */
export enum DataTableDosageFormsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `DataTable` object types. All fields are combined with a logical ‘and.’ */
export type DataTableFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableFilter>>;
  /** Filter by the object’s `dataViewCode` field. */
  dataViewCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldMap` field. */
  fieldMap?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLookupTable` field. */
  isLookupTable?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableFilter>>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
};

export type DataTableGenericIngredient = Node & {
  __typename?: 'DataTableGenericIngredient';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  productEn?: Maybe<Scalars['String']['output']>;
  productFr?: Maybe<Scalars['String']['output']>;
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableGenericIngredient` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableGenericIngredientCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productEn` field. */
  productEn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productFr` field. */
  productFr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableGenericIngredient` object types. All fields are combined with a logical ‘and.’ */
export type DataTableGenericIngredientFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableGenericIngredientFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableGenericIngredientFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableGenericIngredientFilter>>;
  /** Filter by the object’s `productEn` field. */
  productEn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productFr` field. */
  productFr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableGenericIngredient` */
export type DataTableGenericIngredientInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  productEn?: InputMaybe<Scalars['String']['input']>;
  productFr?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableGenericIngredient`. Fields that are set will be updated. */
export type DataTableGenericIngredientPatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  productEn?: InputMaybe<Scalars['String']['input']>;
  productFr?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableGenericIngredient` values. */
export type DataTableGenericIngredientsConnection = {
  __typename?: 'DataTableGenericIngredientsConnection';
  /** A list of edges which contains the `DataTableGenericIngredient` and cursor to aid in pagination. */
  edges: Array<DataTableGenericIngredientsEdge>;
  /** A list of `DataTableGenericIngredient` objects. */
  nodes: Array<Maybe<DataTableGenericIngredient>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableGenericIngredient` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableGenericIngredient` edge in the connection. */
export type DataTableGenericIngredientsEdge = {
  __typename?: 'DataTableGenericIngredientsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableGenericIngredient` at the end of the edge. */
  node?: Maybe<DataTableGenericIngredient>;
};

/** Methods to use when ordering `DataTableGenericIngredient`. */
export enum DataTableGenericIngredientsOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductEnAsc = 'PRODUCT_EN_ASC',
  ProductEnDesc = 'PRODUCT_EN_DESC',
  ProductFrAsc = 'PRODUCT_FR_ASC',
  ProductFrDesc = 'PRODUCT_FR_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

export type DataTableIngredientsList = Node & {
  __typename?: 'DataTableIngredientsList';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableIngredientsList` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableIngredientsListCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableIngredientsList` object types. All fields are combined with a logical ‘and.’ */
export type DataTableIngredientsListFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableIngredientsListFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableIngredientsListFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableIngredientsListFilter>>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableIngredientsList` */
export type DataTableIngredientsListInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableIngredientsList`. Fields that are set will be updated. */
export type DataTableIngredientsListPatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableIngredientsList` values. */
export type DataTableIngredientsListsConnection = {
  __typename?: 'DataTableIngredientsListsConnection';
  /** A list of edges which contains the `DataTableIngredientsList` and cursor to aid in pagination. */
  edges: Array<DataTableIngredientsListsEdge>;
  /** A list of `DataTableIngredientsList` objects. */
  nodes: Array<Maybe<DataTableIngredientsList>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableIngredientsList` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableIngredientsList` edge in the connection. */
export type DataTableIngredientsListsEdge = {
  __typename?: 'DataTableIngredientsListsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableIngredientsList` at the end of the edge. */
  node?: Maybe<DataTableIngredientsList>;
};

/** Methods to use when ordering `DataTableIngredientsList`. */
export enum DataTableIngredientsListsOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

/** An input for mutations affecting `DataTable` */
export type DataTableInput = {
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  tableName: Scalars['String']['input'];
};

export type DataTableListOfSra = Node & {
  __typename?: 'DataTableListOfSra';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sra?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableListOfSra` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableListOfSraCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sra` field. */
  sra?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableListOfSra` object types. All fields are combined with a logical ‘and.’ */
export type DataTableListOfSraFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableListOfSraFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableListOfSraFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableListOfSraFilter>>;
  /** Filter by the object’s `sra` field. */
  sra?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableListOfSra` */
export type DataTableListOfSraInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  sra?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableListOfSra`. Fields that are set will be updated. */
export type DataTableListOfSraPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  sra?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableListOfSra` values. */
export type DataTableListOfSrasConnection = {
  __typename?: 'DataTableListOfSrasConnection';
  /** A list of edges which contains the `DataTableListOfSra` and cursor to aid in pagination. */
  edges: Array<DataTableListOfSrasEdge>;
  /** A list of `DataTableListOfSra` objects. */
  nodes: Array<Maybe<DataTableListOfSra>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableListOfSra` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableListOfSra` edge in the connection. */
export type DataTableListOfSrasEdge = {
  __typename?: 'DataTableListOfSrasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableListOfSra` at the end of the edge. */
  node?: Maybe<DataTableListOfSra>;
};

/** Methods to use when ordering `DataTableListOfSra`. */
export enum DataTableListOfSrasOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SraAsc = 'SRA_ASC',
  SraDesc = 'SRA_DESC'
}

export type DataTableManufacturingStep = Node & {
  __typename?: 'DataTableManufacturingStep';
  definition?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  manufacturingOperation?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  tipoDeFabricante?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableManufacturingStep` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableManufacturingStepCondition = {
  /** Checks for equality with the object’s `definition` field. */
  definition?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `manufacturingOperation` field. */
  manufacturingOperation?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tipoDeFabricante` field. */
  tipoDeFabricante?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableManufacturingStep` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturingStepFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableManufacturingStepFilter>>;
  /** Filter by the object’s `definition` field. */
  definition?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `manufacturingOperation` field. */
  manufacturingOperation?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableManufacturingStepFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableManufacturingStepFilter>>;
  /** Filter by the object’s `tipoDeFabricante` field. */
  tipoDeFabricante?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableManufacturingStep` */
export type DataTableManufacturingStepInput = {
  definition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  manufacturingOperation?: InputMaybe<Scalars['String']['input']>;
  tipoDeFabricante?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableManufacturingStep`. Fields that are set will be updated. */
export type DataTableManufacturingStepPatch = {
  definition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  manufacturingOperation?: InputMaybe<Scalars['String']['input']>;
  tipoDeFabricante?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableManufacturingStep` values. */
export type DataTableManufacturingStepsConnection = {
  __typename?: 'DataTableManufacturingStepsConnection';
  /** A list of edges which contains the `DataTableManufacturingStep` and cursor to aid in pagination. */
  edges: Array<DataTableManufacturingStepsEdge>;
  /** A list of `DataTableManufacturingStep` objects. */
  nodes: Array<Maybe<DataTableManufacturingStep>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableManufacturingStep` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableManufacturingStep` edge in the connection. */
export type DataTableManufacturingStepsEdge = {
  __typename?: 'DataTableManufacturingStepsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableManufacturingStep` at the end of the edge. */
  node?: Maybe<DataTableManufacturingStep>;
};

/** Methods to use when ordering `DataTableManufacturingStep`. */
export enum DataTableManufacturingStepsOrderBy {
  DefinitionAsc = 'DEFINITION_ASC',
  DefinitionDesc = 'DEFINITION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ManufacturingOperationAsc = 'MANUFACTURING_OPERATION_ASC',
  ManufacturingOperationDesc = 'MANUFACTURING_OPERATION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TipoDeFabricanteAsc = 'TIPO_DE_FABRICANTE_ASC',
  TipoDeFabricanteDesc = 'TIPO_DE_FABRICANTE_DESC'
}

/** Represents an update to a `DataTable`. Fields that are set will be updated. */
export type DataTablePatch = {
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
};

export type DataTableProcessingStep = Node & {
  __typename?: 'DataTableProcessingStep';
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  portugueseName?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableProcessingStep` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableProcessingStepCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableProcessingStep` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProcessingStepFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProcessingStepFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProcessingStepFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProcessingStepFilter>>;
  /** Filter by the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProcessingStep` */
export type DataTableProcessingStepInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableProcessingStep`. Fields that are set will be updated. */
export type DataTableProcessingStepPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableProcessingStep` values. */
export type DataTableProcessingStepsConnection = {
  __typename?: 'DataTableProcessingStepsConnection';
  /** A list of edges which contains the `DataTableProcessingStep` and cursor to aid in pagination. */
  edges: Array<DataTableProcessingStepsEdge>;
  /** A list of `DataTableProcessingStep` objects. */
  nodes: Array<Maybe<DataTableProcessingStep>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProcessingStep` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProcessingStep` edge in the connection. */
export type DataTableProcessingStepsEdge = {
  __typename?: 'DataTableProcessingStepsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProcessingStep` at the end of the edge. */
  node?: Maybe<DataTableProcessingStep>;
};

/** Methods to use when ordering `DataTableProcessingStep`. */
export enum DataTableProcessingStepsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PortugueseNameAsc = 'PORTUGUESE_NAME_ASC',
  PortugueseNameDesc = 'PORTUGUESE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableProduct = Node & {
  __typename?: 'DataTableProduct';
  administrationRoute?: Maybe<Scalars['String']['output']>;
  applicantId?: Maybe<Scalars['Int']['output']>;
  applicantName?: Maybe<Scalars['String']['output']>;
  applicationType?: Maybe<Scalars['String']['output']>;
  atcClass?: Maybe<Scalars['String']['output']>;
  atcCode?: Maybe<Scalars['String']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTableProductApplicationJoin`. */
  dataTableProductApplicationJoins: DataTableProductApplicationJoinsConnection;
  dimensions?: Maybe<Scalars['JSON']['output']>;
  dosageForm?: Maybe<Scalars['String']['output']>;
  expiryDate?: Maybe<Scalars['Datetime']['output']>;
  formulations?: Maybe<Scalars['JSON']['output']>;
  genericNames?: Maybe<Scalars['JSON']['output']>;
  genericNamesFilterData?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isLocallyManufactured?: Maybe<Scalars['Boolean']['output']>;
  manufacturersList?: Maybe<Scalars['JSON']['output']>;
  manufacturersListFilterData?: Maybe<Scalars['String']['output']>;
  medicineType?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  origin?: Maybe<Scalars['String']['output']>;
  prescription?: Maybe<Scalars['String']['output']>;
  primaryContainer?: Maybe<Scalars['String']['output']>;
  registration?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
  responsiblePerson?: Maybe<Scalars['JSON']['output']>;
  shelfLifeOpened?: Maybe<Scalars['String']['output']>;
  shelfLifeProposed?: Maybe<Scalars['String']['output']>;
  shelfLifeReconstructed?: Maybe<Scalars['String']['output']>;
  storageConditionsOpened?: Maybe<Scalars['String']['output']>;
  storageConditionsProposed?: Maybe<Scalars['String']['output']>;
};


export type DataTableProductDataTableProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

export type DataTableProductApplicationJoin = Node & {
  __typename?: 'DataTableProductApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads a single `DataTableProduct` that is related to this `DataTableProductApplicationJoin`. */
  dataTableProduct?: Maybe<DataTableProduct>;
  dataTableProductId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The `application` to be created by this mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTableProductApplicationJoin` to be created by this mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTableProductApplicationJoinInput` mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTableProductApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdConnect>>;
  /** A `DataTableProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableProductApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** A condition to be used against `DataTableProductApplicationJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableProductApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTableProductId` field. */
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to connect. */
export type DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to delete. */
export type DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The `dataTableProductApplicationJoin` to be created by this mutation. */
export type DataTableProductApplicationJoinDataTableProductIdFkeyDataTableProductApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTableProduct` to be created by this mutation. */
export type DataTableProductApplicationJoinDataTableProductIdFkeyDataTableProductCreateInput = {
  administrationRoute?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  applicantName?: InputMaybe<Scalars['String']['input']>;
  applicationType?: InputMaybe<Scalars['String']['input']>;
  atcClass?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInverseInput>;
  dimensions?: InputMaybe<Scalars['JSON']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  formulations?: InputMaybe<Scalars['JSON']['input']>;
  genericNames?: InputMaybe<Scalars['JSON']['input']>;
  genericNamesFilterData?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isLocallyManufactured?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturersList?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersListFilterData?: InputMaybe<Scalars['String']['input']>;
  medicineType?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  prescription?: InputMaybe<Scalars['String']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  responsiblePerson?: InputMaybe<Scalars['JSON']['input']>;
  shelfLifeOpened?: InputMaybe<Scalars['String']['input']>;
  shelfLifeProposed?: InputMaybe<Scalars['String']['input']>;
  shelfLifeReconstructed?: InputMaybe<Scalars['String']['input']>;
  storageConditionsOpened?: InputMaybe<Scalars['String']['input']>;
  storageConditionsProposed?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `dataTableProduct` in the `DataTableProductApplicationJoinInput` mutation. */
export type DataTableProductApplicationJoinDataTableProductIdFkeyInput = {
  /** The primary key(s) for `dataTableProduct` for the far side of the relationship. */
  connectById?: InputMaybe<DataTableProductDataTableProductPkeyConnect>;
  /** The primary key(s) for `dataTableProduct` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTableProductNodeIdConnect>;
  /** A `DataTableProductInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyDataTableProductCreateInput>;
  /** The primary key(s) for `dataTableProduct` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTableProductDataTableProductPkeyDelete>;
  /** The primary key(s) for `dataTableProduct` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTableProductNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTableProduct` for the far side of the relationship. */
  updateById?: InputMaybe<DataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyUsingDataTableProductPkeyUpdate>;
  /** The primary key(s) and patch data for `dataTableProduct` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTableProductApplicationJoin` in the `DataTableProductInput` mutation. */
export type DataTableProductApplicationJoinDataTableProductIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdConnect>>;
  /** A `DataTableProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductIdFkeyDataTableProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableProductApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyNodeIdUpdate>>;
};

/** A filter to be used against `DataTableProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProductApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProductApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTableProduct` relation. */
  dataTableProduct?: InputMaybe<DataTableProductFilter>;
  /** Filter by the object’s `dataTableProductId` field. */
  dataTableProductId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProductApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTableProductApplicationJoin` */
export type DataTableProductApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableProductApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableProductApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProduct` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProduct` being updated. */
  patch: DataTableProductPatch;
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyPatch;
};

/** Represents an update to a `DataTableProductApplicationJoin`. Fields that are set will be updated. */
export type DataTableProductApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableProductApplicationJoin` values. */
export type DataTableProductApplicationJoinsConnection = {
  __typename?: 'DataTableProductApplicationJoinsConnection';
  /** A list of edges which contains the `DataTableProductApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTableProductApplicationJoinsEdge>;
  /** A list of `DataTableProductApplicationJoin` objects. */
  nodes: Array<Maybe<DataTableProductApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProductApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProductApplicationJoin` edge in the connection. */
export type DataTableProductApplicationJoinsEdge = {
  __typename?: 'DataTableProductApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProductApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTableProductApplicationJoin>;
};

/** Methods to use when ordering `DataTableProductApplicationJoin`. */
export enum DataTableProductApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTableProductIdAsc = 'DATA_TABLE_PRODUCT_ID_ASC',
  DataTableProductIdDesc = 'DATA_TABLE_PRODUCT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `DataTableProduct` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableProductCondition = {
  /** Checks for equality with the object’s `administrationRoute` field. */
  administrationRoute?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicantId` field. */
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicantName` field. */
  applicantName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicationType` field. */
  applicationType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `atcClass` field. */
  atcClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyName` field. */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dimensions` field. */
  dimensions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formulations` field. */
  formulations?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `genericNames` field. */
  genericNames?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `genericNamesFilterData` field. */
  genericNamesFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLocallyManufactured` field. */
  isLocallyManufactured?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `manufacturersList` field. */
  manufacturersList?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturersListFilterData` field. */
  manufacturersListFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `medicineType` field. */
  medicineType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origin` field. */
  origin?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prescription` field. */
  prescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `primaryContainer` field. */
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registration` field. */
  registration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `responsiblePerson` field. */
  responsiblePerson?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `shelfLifeOpened` field. */
  shelfLifeOpened?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shelfLifeProposed` field. */
  shelfLifeProposed?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shelfLifeReconstructed` field. */
  shelfLifeReconstructed?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `storageConditionsOpened` field. */
  storageConditionsOpened?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `storageConditionsProposed` field. */
  storageConditionsProposed?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `dataTableProduct` to look up the row to connect. */
export type DataTableProductDataTableProductPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableProduct` to look up the row to delete. */
export type DataTableProductDataTableProductPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableProduct` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProductFilter = {
  /** Filter by the object’s `administrationRoute` field. */
  administrationRoute?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProductFilter>>;
  /** Filter by the object’s `applicantId` field. */
  applicantId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicantName` field. */
  applicantName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `applicationType` field. */
  applicationType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `atcClass` field. */
  atcClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyName` field. */
  companyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTableProductApplicationJoins` relation. */
  dataTableProductApplicationJoins?: InputMaybe<DataTableProductToManyDataTableProductApplicationJoinFilter>;
  /** Some related `dataTableProductApplicationJoins` exist. */
  dataTableProductApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dimensions` field. */
  dimensions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formulations` field. */
  formulations?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `genericNames` field. */
  genericNames?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `genericNamesFilterData` field. */
  genericNamesFilterData?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLocallyManufactured` field. */
  isLocallyManufactured?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `manufacturersList` field. */
  manufacturersList?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturersListFilterData` field. */
  manufacturersListFilterData?: InputMaybe<StringFilter>;
  /** Filter by the object’s `medicineType` field. */
  medicineType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProductFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProductFilter>>;
  /** Filter by the object’s `origin` field. */
  origin?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prescription` field. */
  prescription?: InputMaybe<StringFilter>;
  /** Filter by the object’s `primaryContainer` field. */
  primaryContainer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registration` field. */
  registration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `responsiblePerson` field. */
  responsiblePerson?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `shelfLifeOpened` field. */
  shelfLifeOpened?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shelfLifeProposed` field. */
  shelfLifeProposed?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shelfLifeReconstructed` field. */
  shelfLifeReconstructed?: InputMaybe<StringFilter>;
  /** Filter by the object’s `storageConditionsOpened` field. */
  storageConditionsOpened?: InputMaybe<StringFilter>;
  /** Filter by the object’s `storageConditionsProposed` field. */
  storageConditionsProposed?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProduct` */
export type DataTableProductInput = {
  administrationRoute?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  applicantName?: InputMaybe<Scalars['String']['input']>;
  applicationType?: InputMaybe<Scalars['String']['input']>;
  atcClass?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInverseInput>;
  dimensions?: InputMaybe<Scalars['JSON']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  formulations?: InputMaybe<Scalars['JSON']['input']>;
  genericNames?: InputMaybe<Scalars['JSON']['input']>;
  genericNamesFilterData?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isLocallyManufactured?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturersList?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersListFilterData?: InputMaybe<Scalars['String']['input']>;
  medicineType?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  prescription?: InputMaybe<Scalars['String']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  responsiblePerson?: InputMaybe<Scalars['JSON']['input']>;
  shelfLifeOpened?: InputMaybe<Scalars['String']['input']>;
  shelfLifeProposed?: InputMaybe<Scalars['String']['input']>;
  shelfLifeReconstructed?: InputMaybe<Scalars['String']['input']>;
  storageConditionsOpened?: InputMaybe<Scalars['String']['input']>;
  storageConditionsProposed?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableProduct` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableProduct` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** The fields on `dataTableProduct` to look up the row to update. */
export type DataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyUsingDataTableProductPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProduct` being updated. */
  patch: UpdateDataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyPatch;
};

/** Represents an update to a `DataTableProduct`. Fields that are set will be updated. */
export type DataTableProductPatch = {
  administrationRoute?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  applicantName?: InputMaybe<Scalars['String']['input']>;
  applicationType?: InputMaybe<Scalars['String']['input']>;
  atcClass?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInverseInput>;
  dimensions?: InputMaybe<Scalars['JSON']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  formulations?: InputMaybe<Scalars['JSON']['input']>;
  genericNames?: InputMaybe<Scalars['JSON']['input']>;
  genericNamesFilterData?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isLocallyManufactured?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturersList?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersListFilterData?: InputMaybe<Scalars['String']['input']>;
  medicineType?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  prescription?: InputMaybe<Scalars['String']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  responsiblePerson?: InputMaybe<Scalars['JSON']['input']>;
  shelfLifeOpened?: InputMaybe<Scalars['String']['input']>;
  shelfLifeProposed?: InputMaybe<Scalars['String']['input']>;
  shelfLifeReconstructed?: InputMaybe<Scalars['String']['input']>;
  storageConditionsOpened?: InputMaybe<Scalars['String']['input']>;
  storageConditionsProposed?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableProduct` values. */
export type DataTableProductsConnection = {
  __typename?: 'DataTableProductsConnection';
  /** A list of edges which contains the `DataTableProduct` and cursor to aid in pagination. */
  edges: Array<DataTableProductsEdge>;
  /** A list of `DataTableProduct` objects. */
  nodes: Array<Maybe<DataTableProduct>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProduct` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProduct` edge in the connection. */
export type DataTableProductsEdge = {
  __typename?: 'DataTableProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProduct` at the end of the edge. */
  node?: Maybe<DataTableProduct>;
};

/** Methods to use when ordering `DataTableProduct`. */
export enum DataTableProductsOrderBy {
  AdministrationRouteAsc = 'ADMINISTRATION_ROUTE_ASC',
  AdministrationRouteDesc = 'ADMINISTRATION_ROUTE_DESC',
  ApplicantIdAsc = 'APPLICANT_ID_ASC',
  ApplicantIdDesc = 'APPLICANT_ID_DESC',
  ApplicantNameAsc = 'APPLICANT_NAME_ASC',
  ApplicantNameDesc = 'APPLICANT_NAME_DESC',
  ApplicationTypeAsc = 'APPLICATION_TYPE_ASC',
  ApplicationTypeDesc = 'APPLICATION_TYPE_DESC',
  AtcClassAsc = 'ATC_CLASS_ASC',
  AtcClassDesc = 'ATC_CLASS_DESC',
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CompanyNameAsc = 'COMPANY_NAME_ASC',
  CompanyNameDesc = 'COMPANY_NAME_DESC',
  DimensionsAsc = 'DIMENSIONS_ASC',
  DimensionsDesc = 'DIMENSIONS_DESC',
  DosageFormAsc = 'DOSAGE_FORM_ASC',
  DosageFormDesc = 'DOSAGE_FORM_DESC',
  ExpiryDateAsc = 'EXPIRY_DATE_ASC',
  ExpiryDateDesc = 'EXPIRY_DATE_DESC',
  FormulationsAsc = 'FORMULATIONS_ASC',
  FormulationsDesc = 'FORMULATIONS_DESC',
  GenericNamesAsc = 'GENERIC_NAMES_ASC',
  GenericNamesDesc = 'GENERIC_NAMES_DESC',
  GenericNamesFilterDataAsc = 'GENERIC_NAMES_FILTER_DATA_ASC',
  GenericNamesFilterDataDesc = 'GENERIC_NAMES_FILTER_DATA_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsLocallyManufacturedAsc = 'IS_LOCALLY_MANUFACTURED_ASC',
  IsLocallyManufacturedDesc = 'IS_LOCALLY_MANUFACTURED_DESC',
  ManufacturersListAsc = 'MANUFACTURERS_LIST_ASC',
  ManufacturersListDesc = 'MANUFACTURERS_LIST_DESC',
  ManufacturersListFilterDataAsc = 'MANUFACTURERS_LIST_FILTER_DATA_ASC',
  ManufacturersListFilterDataDesc = 'MANUFACTURERS_LIST_FILTER_DATA_DESC',
  MedicineTypeAsc = 'MEDICINE_TYPE_ASC',
  MedicineTypeDesc = 'MEDICINE_TYPE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OriginAsc = 'ORIGIN_ASC',
  OriginDesc = 'ORIGIN_DESC',
  PrescriptionAsc = 'PRESCRIPTION_ASC',
  PrescriptionDesc = 'PRESCRIPTION_DESC',
  PrimaryContainerAsc = 'PRIMARY_CONTAINER_ASC',
  PrimaryContainerDesc = 'PRIMARY_CONTAINER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationAsc = 'REGISTRATION_ASC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC',
  RegistrationDesc = 'REGISTRATION_DESC',
  ResponsiblePersonAsc = 'RESPONSIBLE_PERSON_ASC',
  ResponsiblePersonDesc = 'RESPONSIBLE_PERSON_DESC',
  ShelfLifeOpenedAsc = 'SHELF_LIFE_OPENED_ASC',
  ShelfLifeOpenedDesc = 'SHELF_LIFE_OPENED_DESC',
  ShelfLifeProposedAsc = 'SHELF_LIFE_PROPOSED_ASC',
  ShelfLifeProposedDesc = 'SHELF_LIFE_PROPOSED_DESC',
  ShelfLifeReconstructedAsc = 'SHELF_LIFE_RECONSTRUCTED_ASC',
  ShelfLifeReconstructedDesc = 'SHELF_LIFE_RECONSTRUCTED_DESC',
  StorageConditionsOpenedAsc = 'STORAGE_CONDITIONS_OPENED_ASC',
  StorageConditionsOpenedDesc = 'STORAGE_CONDITIONS_OPENED_DESC',
  StorageConditionsProposedAsc = 'STORAGE_CONDITIONS_PROPOSED_ASC',
  StorageConditionsProposedDesc = 'STORAGE_CONDITIONS_PROPOSED_DESC'
}

/** A filter to be used against many `DataTableProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProductToManyDataTableProductApplicationJoinFilter = {
  /** Every related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** No related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** Some related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableProductApplicationJoinFilter>;
};

export type DataTableProvince = Node & {
  __typename?: 'DataTableProvince';
  area?: Maybe<Scalars['String']['output']>;
  capital?: Maybe<Scalars['String']['output']>;
  codigo?: Maybe<Scalars['String']['output']>;
  comunas?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  municipios?: Maybe<Scalars['String']['output']>;
  nameUppercase?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  nome?: Maybe<Scalars['String']['output']>;
  populacao?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableProvince` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableProvinceCondition = {
  /** Checks for equality with the object’s `area` field. */
  area?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `capital` field. */
  capital?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `codigo` field. */
  codigo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `comunas` field. */
  comunas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `municipios` field. */
  municipios?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nameUppercase` field. */
  nameUppercase?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nome` field. */
  nome?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `populacao` field. */
  populacao?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableProvince` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProvinceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProvinceFilter>>;
  /** Filter by the object’s `area` field. */
  area?: InputMaybe<StringFilter>;
  /** Filter by the object’s `capital` field. */
  capital?: InputMaybe<StringFilter>;
  /** Filter by the object’s `codigo` field. */
  codigo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `comunas` field. */
  comunas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `municipios` field. */
  municipios?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nameUppercase` field. */
  nameUppercase?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nome` field. */
  nome?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProvinceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProvinceFilter>>;
  /** Filter by the object’s `populacao` field. */
  populacao?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProvince` */
export type DataTableProvinceInput = {
  area?: InputMaybe<Scalars['String']['input']>;
  capital?: InputMaybe<Scalars['String']['input']>;
  codigo?: InputMaybe<Scalars['String']['input']>;
  comunas?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  municipios?: InputMaybe<Scalars['String']['input']>;
  nameUppercase?: InputMaybe<Scalars['String']['input']>;
  nome?: InputMaybe<Scalars['String']['input']>;
  populacao?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableProvince`. Fields that are set will be updated. */
export type DataTableProvincePatch = {
  area?: InputMaybe<Scalars['String']['input']>;
  capital?: InputMaybe<Scalars['String']['input']>;
  codigo?: InputMaybe<Scalars['String']['input']>;
  comunas?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  municipios?: InputMaybe<Scalars['String']['input']>;
  nameUppercase?: InputMaybe<Scalars['String']['input']>;
  nome?: InputMaybe<Scalars['String']['input']>;
  populacao?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableProvince` values. */
export type DataTableProvincesConnection = {
  __typename?: 'DataTableProvincesConnection';
  /** A list of edges which contains the `DataTableProvince` and cursor to aid in pagination. */
  edges: Array<DataTableProvincesEdge>;
  /** A list of `DataTableProvince` objects. */
  nodes: Array<Maybe<DataTableProvince>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProvince` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProvince` edge in the connection. */
export type DataTableProvincesEdge = {
  __typename?: 'DataTableProvincesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProvince` at the end of the edge. */
  node?: Maybe<DataTableProvince>;
};

/** Methods to use when ordering `DataTableProvince`. */
export enum DataTableProvincesOrderBy {
  AreaAsc = 'AREA_ASC',
  AreaDesc = 'AREA_DESC',
  CapitalAsc = 'CAPITAL_ASC',
  CapitalDesc = 'CAPITAL_DESC',
  CodigoAsc = 'CODIGO_ASC',
  CodigoDesc = 'CODIGO_DESC',
  ComunasAsc = 'COMUNAS_ASC',
  ComunasDesc = 'COMUNAS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MunicipiosAsc = 'MUNICIPIOS_ASC',
  MunicipiosDesc = 'MUNICIPIOS_DESC',
  NameUppercaseAsc = 'NAME_UPPERCASE_ASC',
  NameUppercaseDesc = 'NAME_UPPERCASE_DESC',
  Natural = 'NATURAL',
  NomeAsc = 'NOME_ASC',
  NomeDesc = 'NOME_DESC',
  PopulacaoAsc = 'POPULACAO_ASC',
  PopulacaoDesc = 'POPULACAO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `DataTable` values. */
export type DataTablesConnection = {
  __typename?: 'DataTablesConnection';
  /** A list of edges which contains the `DataTable` and cursor to aid in pagination. */
  edges: Array<DataTablesEdge>;
  /** A list of `DataTable` objects. */
  nodes: Array<Maybe<DataTable>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTable` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTable` edge in the connection. */
export type DataTablesEdge = {
  __typename?: 'DataTablesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTable` at the end of the edge. */
  node?: Maybe<DataTable>;
};

/** Methods to use when ordering `DataTable`. */
export enum DataTablesOrderBy {
  DataViewCodeAsc = 'DATA_VIEW_CODE_ASC',
  DataViewCodeDesc = 'DATA_VIEW_CODE_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  FieldMapAsc = 'FIELD_MAP_ASC',
  FieldMapDesc = 'FIELD_MAP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLookupTableAsc = 'IS_LOOKUP_TABLE_ASC',
  IsLookupTableDesc = 'IS_LOOKUP_TABLE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC'
}

export type DataTableStorageCondition = Node & {
  __typename?: 'DataTableStorageCondition';
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  portugueseName?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableStorageCondition` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableStorageConditionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableStorageCondition` object types. All fields are combined with a logical ‘and.’ */
export type DataTableStorageConditionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableStorageConditionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableStorageConditionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableStorageConditionFilter>>;
  /** Filter by the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableStorageCondition` */
export type DataTableStorageConditionInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableStorageCondition`. Fields that are set will be updated. */
export type DataTableStorageConditionPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableStorageCondition` values. */
export type DataTableStorageConditionsConnection = {
  __typename?: 'DataTableStorageConditionsConnection';
  /** A list of edges which contains the `DataTableStorageCondition` and cursor to aid in pagination. */
  edges: Array<DataTableStorageConditionsEdge>;
  /** A list of `DataTableStorageCondition` objects. */
  nodes: Array<Maybe<DataTableStorageCondition>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableStorageCondition` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableStorageCondition` edge in the connection. */
export type DataTableStorageConditionsEdge = {
  __typename?: 'DataTableStorageConditionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableStorageCondition` at the end of the edge. */
  node?: Maybe<DataTableStorageCondition>;
};

/** Methods to use when ordering `DataTableStorageCondition`. */
export enum DataTableStorageConditionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PortugueseNameAsc = 'PORTUGUESE_NAME_ASC',
  PortugueseNameDesc = 'PORTUGUESE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableUnitsOfProportion = Node & {
  __typename?: 'DataTableUnitsOfProportion';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `DataTableUnitsOfProportion` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataTableUnitsOfProportionCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableUnitsOfProportion` object types. All fields are combined with a logical ‘and.’ */
export type DataTableUnitsOfProportionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableUnitsOfProportionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableUnitsOfProportionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableUnitsOfProportionFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableUnitsOfProportion` */
export type DataTableUnitsOfProportionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableUnitsOfProportion`. Fields that are set will be updated. */
export type DataTableUnitsOfProportionPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableUnitsOfProportion` values. */
export type DataTableUnitsOfProportionsConnection = {
  __typename?: 'DataTableUnitsOfProportionsConnection';
  /** A list of edges which contains the `DataTableUnitsOfProportion` and cursor to aid in pagination. */
  edges: Array<DataTableUnitsOfProportionsEdge>;
  /** A list of `DataTableUnitsOfProportion` objects. */
  nodes: Array<Maybe<DataTableUnitsOfProportion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableUnitsOfProportion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableUnitsOfProportion` edge in the connection. */
export type DataTableUnitsOfProportionsEdge = {
  __typename?: 'DataTableUnitsOfProportionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableUnitsOfProportion` at the end of the edge. */
  node?: Maybe<DataTableUnitsOfProportion>;
};

/** Methods to use when ordering `DataTableUnitsOfProportion`. */
export enum DataTableUnitsOfProportionsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

export type DataView = Node & {
  __typename?: 'DataView';
  code: Scalars['String']['output'];
  defaultFilterString?: Maybe<Scalars['String']['output']>;
  defaultSortColumn?: Maybe<Scalars['String']['output']>;
  detailViewExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  detailViewHeaderColumn: Scalars['String']['output'];
  detailViewIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  enabled: Scalars['Boolean']['output'];
  filterExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  filterIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['Int']['output'];
  identifier: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permissionNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  priority?: Maybe<Scalars['Int']['output']>;
  rowRestrictions?: Maybe<Scalars['JSON']['output']>;
  showLinkedApplications: Scalars['Boolean']['output'];
  submenu?: Maybe<Scalars['String']['output']>;
  tableName: Scalars['String']['output'];
  tableSearchColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  tableViewExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  tableViewIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
};

export type DataViewColumnDefinition = Node & {
  __typename?: 'DataViewColumnDefinition';
  additionalFormatting?: Maybe<Scalars['JSON']['output']>;
  columnName: Scalars['String']['output'];
  elementParameters?: Maybe<Scalars['JSON']['output']>;
  elementTypePluginCode?: Maybe<Scalars['String']['output']>;
  filterDataType?: Maybe<Scalars['String']['output']>;
  filterExpression?: Maybe<Scalars['JSON']['output']>;
  filterParameters?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sortColumn?: Maybe<Scalars['String']['output']>;
  tableName?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  valueExpression?: Maybe<Scalars['JSON']['output']>;
};

/** A condition to be used against `DataViewColumnDefinition` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataViewColumnDefinitionCondition = {
  /** Checks for equality with the object’s `additionalFormatting` field. */
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `columnName` field. */
  columnName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `elementParameters` field. */
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterDataType` field. */
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterExpression` field. */
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `filterParameters` field. */
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sortColumn` field. */
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `valueExpression` field. */
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `DataViewColumnDefinition` object types. All fields are combined with a logical ‘and.’ */
export type DataViewColumnDefinitionFilter = {
  /** Filter by the object’s `additionalFormatting` field. */
  additionalFormatting?: InputMaybe<JsonFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataViewColumnDefinitionFilter>>;
  /** Filter by the object’s `columnName` field. */
  columnName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `elementParameters` field. */
  elementParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterDataType` field. */
  filterDataType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterExpression` field. */
  filterExpression?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `filterParameters` field. */
  filterParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataViewColumnDefinitionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataViewColumnDefinitionFilter>>;
  /** Filter by the object’s `sortColumn` field. */
  sortColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `valueExpression` field. */
  valueExpression?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `DataViewColumnDefinition` */
export type DataViewColumnDefinitionInput = {
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  columnName: Scalars['String']['input'];
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** Represents an update to a `DataViewColumnDefinition`. Fields that are set will be updated. */
export type DataViewColumnDefinitionPatch = {
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  columnName?: InputMaybe<Scalars['String']['input']>;
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `DataViewColumnDefinition` values. */
export type DataViewColumnDefinitionsConnection = {
  __typename?: 'DataViewColumnDefinitionsConnection';
  /** A list of edges which contains the `DataViewColumnDefinition` and cursor to aid in pagination. */
  edges: Array<DataViewColumnDefinitionsEdge>;
  /** A list of `DataViewColumnDefinition` objects. */
  nodes: Array<Maybe<DataViewColumnDefinition>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataViewColumnDefinition` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataViewColumnDefinition` edge in the connection. */
export type DataViewColumnDefinitionsEdge = {
  __typename?: 'DataViewColumnDefinitionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataViewColumnDefinition` at the end of the edge. */
  node?: Maybe<DataViewColumnDefinition>;
};

/** Methods to use when ordering `DataViewColumnDefinition`. */
export enum DataViewColumnDefinitionsOrderBy {
  AdditionalFormattingAsc = 'ADDITIONAL_FORMATTING_ASC',
  AdditionalFormattingDesc = 'ADDITIONAL_FORMATTING_DESC',
  ColumnNameAsc = 'COLUMN_NAME_ASC',
  ColumnNameDesc = 'COLUMN_NAME_DESC',
  ElementParametersAsc = 'ELEMENT_PARAMETERS_ASC',
  ElementParametersDesc = 'ELEMENT_PARAMETERS_DESC',
  ElementTypePluginCodeAsc = 'ELEMENT_TYPE_PLUGIN_CODE_ASC',
  ElementTypePluginCodeDesc = 'ELEMENT_TYPE_PLUGIN_CODE_DESC',
  FilterDataTypeAsc = 'FILTER_DATA_TYPE_ASC',
  FilterDataTypeDesc = 'FILTER_DATA_TYPE_DESC',
  FilterExpressionAsc = 'FILTER_EXPRESSION_ASC',
  FilterExpressionDesc = 'FILTER_EXPRESSION_DESC',
  FilterParametersAsc = 'FILTER_PARAMETERS_ASC',
  FilterParametersDesc = 'FILTER_PARAMETERS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortColumnAsc = 'SORT_COLUMN_ASC',
  SortColumnDesc = 'SORT_COLUMN_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  ValueExpressionAsc = 'VALUE_EXPRESSION_ASC',
  ValueExpressionDesc = 'VALUE_EXPRESSION_DESC'
}

/** A condition to be used against `DataView` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DataViewCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `defaultFilterString` field. */
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `defaultSortColumn` field. */
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detailViewExcludeColumns` field. */
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `detailViewHeaderColumn` field. */
  detailViewHeaderColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detailViewIncludeColumns` field. */
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `filterExcludeColumns` field. */
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `filterIncludeColumns` field. */
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionNames` field. */
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rowRestrictions` field. */
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `showLinkedApplications` field. */
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `submenu` field. */
  submenu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableSearchColumns` field. */
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `tableViewExcludeColumns` field. */
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `tableViewIncludeColumns` field. */
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataView` object types. All fields are combined with a logical ‘and.’ */
export type DataViewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataViewFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `defaultFilterString` field. */
  defaultFilterString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `defaultSortColumn` field. */
  defaultSortColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detailViewExcludeColumns` field. */
  detailViewExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `detailViewHeaderColumn` field. */
  detailViewHeaderColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detailViewIncludeColumns` field. */
  detailViewIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `enabled` field. */
  enabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `filterExcludeColumns` field. */
  filterExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `filterIncludeColumns` field. */
  filterIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `identifier` field. */
  identifier?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataViewFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataViewFilter>>;
  /** Filter by the object’s `permissionNames` field. */
  permissionNames?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `priority` field. */
  priority?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rowRestrictions` field. */
  rowRestrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `showLinkedApplications` field. */
  showLinkedApplications?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `submenu` field. */
  submenu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableSearchColumns` field. */
  tableSearchColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `tableViewExcludeColumns` field. */
  tableViewExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `tableViewIncludeColumns` field. */
  tableViewIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataView` */
export type DataViewInput = {
  code: Scalars['String']['input'];
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detailViewHeaderColumn: Scalars['String']['input'];
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  identifier: Scalars['String']['input'];
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  submenu?: InputMaybe<Scalars['String']['input']>;
  tableName: Scalars['String']['input'];
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataView`. Fields that are set will be updated. */
export type DataViewPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detailViewHeaderColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  submenu?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataView` values. */
export type DataViewsConnection = {
  __typename?: 'DataViewsConnection';
  /** A list of edges which contains the `DataView` and cursor to aid in pagination. */
  edges: Array<DataViewsEdge>;
  /** A list of `DataView` objects. */
  nodes: Array<Maybe<DataView>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataView` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataView` edge in the connection. */
export type DataViewsEdge = {
  __typename?: 'DataViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataView` at the end of the edge. */
  node?: Maybe<DataView>;
};

/** Methods to use when ordering `DataView`. */
export enum DataViewsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DefaultFilterStringAsc = 'DEFAULT_FILTER_STRING_ASC',
  DefaultFilterStringDesc = 'DEFAULT_FILTER_STRING_DESC',
  DefaultSortColumnAsc = 'DEFAULT_SORT_COLUMN_ASC',
  DefaultSortColumnDesc = 'DEFAULT_SORT_COLUMN_DESC',
  DetailViewExcludeColumnsAsc = 'DETAIL_VIEW_EXCLUDE_COLUMNS_ASC',
  DetailViewExcludeColumnsDesc = 'DETAIL_VIEW_EXCLUDE_COLUMNS_DESC',
  DetailViewHeaderColumnAsc = 'DETAIL_VIEW_HEADER_COLUMN_ASC',
  DetailViewHeaderColumnDesc = 'DETAIL_VIEW_HEADER_COLUMN_DESC',
  DetailViewIncludeColumnsAsc = 'DETAIL_VIEW_INCLUDE_COLUMNS_ASC',
  DetailViewIncludeColumnsDesc = 'DETAIL_VIEW_INCLUDE_COLUMNS_DESC',
  EnabledAsc = 'ENABLED_ASC',
  EnabledDesc = 'ENABLED_DESC',
  FilterExcludeColumnsAsc = 'FILTER_EXCLUDE_COLUMNS_ASC',
  FilterExcludeColumnsDesc = 'FILTER_EXCLUDE_COLUMNS_DESC',
  FilterIncludeColumnsAsc = 'FILTER_INCLUDE_COLUMNS_ASC',
  FilterIncludeColumnsDesc = 'FILTER_INCLUDE_COLUMNS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IdentifierAsc = 'IDENTIFIER_ASC',
  IdentifierDesc = 'IDENTIFIER_DESC',
  Natural = 'NATURAL',
  PermissionNamesAsc = 'PERMISSION_NAMES_ASC',
  PermissionNamesDesc = 'PERMISSION_NAMES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  RowRestrictionsAsc = 'ROW_RESTRICTIONS_ASC',
  RowRestrictionsDesc = 'ROW_RESTRICTIONS_DESC',
  ShowLinkedApplicationsAsc = 'SHOW_LINKED_APPLICATIONS_ASC',
  ShowLinkedApplicationsDesc = 'SHOW_LINKED_APPLICATIONS_DESC',
  SubmenuAsc = 'SUBMENU_ASC',
  SubmenuDesc = 'SUBMENU_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TableSearchColumnsAsc = 'TABLE_SEARCH_COLUMNS_ASC',
  TableSearchColumnsDesc = 'TABLE_SEARCH_COLUMNS_DESC',
  TableViewExcludeColumnsAsc = 'TABLE_VIEW_EXCLUDE_COLUMNS_ASC',
  TableViewExcludeColumnsDesc = 'TABLE_VIEW_EXCLUDE_COLUMNS_DESC',
  TableViewIncludeColumnsAsc = 'TABLE_VIEW_INCLUDE_COLUMNS_ASC',
  TableViewIncludeColumnsDesc = 'TABLE_VIEW_INCLUDE_COLUMNS_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Date']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Date']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Date']['input']>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

export enum Decision {
  ChangesRequested = 'CHANGES_REQUESTED',
  Conform = 'CONFORM',
  ListOfQuestions = 'LIST_OF_QUESTIONS',
  NoDecision = 'NO_DECISION',
  NonConform = 'NON_CONFORM'
}

/** A filter to be used against Decision fields. All fields are combined with a logical ‘and.’ */
export type DecisionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Decision>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Decision>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Decision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Decision>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Decision>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Decision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Decision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Decision>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Decision>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Decision>>;
};

/** All input for the `deleteActionPluginByCode` mutation. */
export type DeleteActionPluginByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteActionPluginByNodeId` mutation. */
export type DeleteActionPluginByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActionPlugin` mutation. */
export type DeleteActionPluginInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayload = {
  __typename?: 'DeleteActionPluginPayload';
  /** The `ActionPlugin` that was deleted by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActionPluginNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `deleteActionQueueByNodeId` mutation. */
export type DeleteActionQueueByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActionQueue` mutation. */
export type DeleteActionQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayload = {
  __typename?: 'DeleteActionQueuePayload';
  /** The `ActionQueue` that was deleted by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActionQueueNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `deleteActivityLogByNodeId` mutation. */
export type DeleteActivityLogByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActivityLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActivityLog` mutation. */
export type DeleteActivityLogInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActivityLog` mutation. */
export type DeleteActivityLogPayload = {
  __typename?: 'DeleteActivityLogPayload';
  /** The `ActivityLog` that was deleted by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActivityLogNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ActivityLog` mutation. */
export type DeleteActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the `deleteApplicationByNodeId` mutation. */
export type DeleteApplicationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationByOutcomeRegistration` mutation. */
export type DeleteApplicationByOutcomeRegistrationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  outcomeRegistration: Scalars['String']['input'];
};

/** All input for the `deleteApplicationBySerial` mutation. */
export type DeleteApplicationBySerialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  serial: Scalars['String']['input'];
};

/** All input for the `deleteApplication` mutation. */
export type DeleteApplicationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteApplicationNoteByNodeId` mutation. */
export type DeleteApplicationNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationNote` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationNote` mutation. */
export type DeleteApplicationNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationNote` mutation. */
export type DeleteApplicationNotePayload = {
  __typename?: 'DeleteApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was deleted by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationNoteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ApplicationNote`. */
  user?: Maybe<User>;
};


/** The output of our delete `ApplicationNote` mutation. */
export type DeleteApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayload = {
  __typename?: 'DeleteApplicationPayload';
  /** The `Application` that was deleted by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
};


/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `deleteApplicationResponseByNodeId` mutation. */
export type DeleteApplicationResponseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationResponse` mutation. */
export type DeleteApplicationResponseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayload = {
  __typename?: 'DeleteApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was deleted by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationResponseNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `deleteApplicationStageHistoryByNodeId` mutation. */
export type DeleteApplicationStageHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayload = {
  __typename?: 'DeleteApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was deleted by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationStageHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `deleteApplicationStatusHistoryByNodeId` mutation. */
export type DeleteApplicationStatusHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayload = {
  __typename?: 'DeleteApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was deleted by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationStatusHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `deleteCounterByName` mutation. */
export type DeleteCounterByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteCounterByNodeId` mutation. */
export type DeleteCounterByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Counter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCounter` mutation. */
export type DeleteCounterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Counter` mutation. */
export type DeleteCounterPayload = {
  __typename?: 'DeleteCounterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was deleted by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  deletedCounterNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Counter` mutation. */
export type DeleteCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the `deleteDataTableActiveIngredientByNodeId` mutation. */
export type DeleteDataTableActiveIngredientByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableActiveIngredient` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientPayload = {
  __typename?: 'DeleteDataTableActiveIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was deleted by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  deletedDataTableActiveIngredientNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the `deleteDataTableAdministrationRouteByNodeId` mutation. */
export type DeleteDataTableAdministrationRouteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAdministrationRoute` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRouteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRoutePayload = {
  __typename?: 'DeleteDataTableAdministrationRoutePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was deleted by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  deletedDataTableAdministrationRouteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the `deleteDataTableAnnex2ByNodeId` mutation. */
export type DeleteDataTableAnnex2ByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAnnex2` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAnnex2` mutation. */
export type DeleteDataTableAnnex2Input = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAnnex2` mutation. */
export type DeleteDataTableAnnex2Payload = {
  __typename?: 'DeleteDataTableAnnex2Payload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex2` that was deleted by this mutation. */
  dataTableAnnex2?: Maybe<DataTableAnnex2>;
  /** An edge for our `DataTableAnnex2`. May be used by Relay 1. */
  dataTableAnnex2Edge?: Maybe<DataTableAnnex2sEdge>;
  deletedDataTableAnnex2NodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAnnex2` mutation. */
export type DeleteDataTableAnnex2PayloadDataTableAnnex2EdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnex2sOrderBy>>;
};

/** All input for the `deleteDataTableAnnexByNodeId` mutation. */
export type DeleteDataTableAnnexByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAnnex` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAnnex` mutation. */
export type DeleteDataTableAnnexInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAnnex` mutation. */
export type DeleteDataTableAnnexPayload = {
  __typename?: 'DeleteDataTableAnnexPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex` that was deleted by this mutation. */
  dataTableAnnex?: Maybe<DataTableAnnex>;
  /** An edge for our `DataTableAnnex`. May be used by Relay 1. */
  dataTableAnnexEdge?: Maybe<DataTableAnnexesEdge>;
  deletedDataTableAnnexNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAnnex` mutation. */
export type DeleteDataTableAnnexPayloadDataTableAnnexEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnexesOrderBy>>;
};

/** All input for the `deleteDataTableAtcCodeByNodeId` mutation. */
export type DeleteDataTableAtcCodeByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcCode` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodePayload = {
  __typename?: 'DeleteDataTableAtcCodePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was deleted by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  deletedDataTableAtcCodeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the `deleteDataTableAtcTherapeuticCategoryByNodeId` mutation. */
export type DeleteDataTableAtcTherapeuticCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcTherapeuticCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAtcTherapeuticCategory` mutation. */
export type DeleteDataTableAtcTherapeuticCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAtcTherapeuticCategory` mutation. */
export type DeleteDataTableAtcTherapeuticCategoryPayload = {
  __typename?: 'DeleteDataTableAtcTherapeuticCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcTherapeuticCategory` that was deleted by this mutation. */
  dataTableAtcTherapeuticCategory?: Maybe<DataTableAtcTherapeuticCategory>;
  /** An edge for our `DataTableAtcTherapeuticCategory`. May be used by Relay 1. */
  dataTableAtcTherapeuticCategoryEdge?: Maybe<DataTableAtcTherapeuticCategoriesEdge>;
  deletedDataTableAtcTherapeuticCategoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAtcTherapeuticCategory` mutation. */
export type DeleteDataTableAtcTherapeuticCategoryPayloadDataTableAtcTherapeuticCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcTherapeuticCategoriesOrderBy>>;
};

/** All input for the `deleteDataTableByNodeId` mutation. */
export type DeleteDataTableByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTable` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableByTableName` mutation. */
export type DeleteDataTableByTableNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  tableName: Scalars['String']['input'];
};

/** All input for the `deleteDataTableContainerByNodeId` mutation. */
export type DeleteDataTableContainerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableContainer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableContainer` mutation. */
export type DeleteDataTableContainerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableContainer` mutation. */
export type DeleteDataTableContainerPayload = {
  __typename?: 'DeleteDataTableContainerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was deleted by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  deletedDataTableContainerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableContainer` mutation. */
export type DeleteDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the `deleteDataTableCountryByNodeId` mutation. */
export type DeleteDataTableCountryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableCountry` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableCountry` mutation. */
export type DeleteDataTableCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableCountry` mutation. */
export type DeleteDataTableCountryPayload = {
  __typename?: 'DeleteDataTableCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was deleted by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  deletedDataTableCountryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableCountry` mutation. */
export type DeleteDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the `deleteDataTableDosageFormByNodeId` mutation. */
export type DeleteDataTableDosageFormByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageForm` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormPayload = {
  __typename?: 'DeleteDataTableDosageFormPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was deleted by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  deletedDataTableDosageFormNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the `deleteDataTableGenericIngredientByNodeId` mutation. */
export type DeleteDataTableGenericIngredientByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableGenericIngredient` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientPayload = {
  __typename?: 'DeleteDataTableGenericIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was deleted by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  deletedDataTableGenericIngredientNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the `deleteDataTableIngredientsListByNodeId` mutation. */
export type DeleteDataTableIngredientsListByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableIngredientsList` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableIngredientsList` mutation. */
export type DeleteDataTableIngredientsListInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableIngredientsList` mutation. */
export type DeleteDataTableIngredientsListPayload = {
  __typename?: 'DeleteDataTableIngredientsListPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableIngredientsList` that was deleted by this mutation. */
  dataTableIngredientsList?: Maybe<DataTableIngredientsList>;
  /** An edge for our `DataTableIngredientsList`. May be used by Relay 1. */
  dataTableIngredientsListEdge?: Maybe<DataTableIngredientsListsEdge>;
  deletedDataTableIngredientsListNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableIngredientsList` mutation. */
export type DeleteDataTableIngredientsListPayloadDataTableIngredientsListEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableIngredientsListsOrderBy>>;
};

/** All input for the `deleteDataTable` mutation. */
export type DeleteDataTableInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDataTableListOfSraByNodeId` mutation. */
export type DeleteDataTableListOfSraByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableListOfSra` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableListOfSra` mutation. */
export type DeleteDataTableListOfSraInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableListOfSra` mutation. */
export type DeleteDataTableListOfSraPayload = {
  __typename?: 'DeleteDataTableListOfSraPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableListOfSra` that was deleted by this mutation. */
  dataTableListOfSra?: Maybe<DataTableListOfSra>;
  /** An edge for our `DataTableListOfSra`. May be used by Relay 1. */
  dataTableListOfSraEdge?: Maybe<DataTableListOfSrasEdge>;
  deletedDataTableListOfSraNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableListOfSra` mutation. */
export type DeleteDataTableListOfSraPayloadDataTableListOfSraEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableListOfSrasOrderBy>>;
};

/** All input for the `deleteDataTableManufacturingStepByNodeId` mutation. */
export type DeleteDataTableManufacturingStepByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturingStep` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableManufacturingStep` mutation. */
export type DeleteDataTableManufacturingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableManufacturingStep` mutation. */
export type DeleteDataTableManufacturingStepPayload = {
  __typename?: 'DeleteDataTableManufacturingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturingStep` that was deleted by this mutation. */
  dataTableManufacturingStep?: Maybe<DataTableManufacturingStep>;
  /** An edge for our `DataTableManufacturingStep`. May be used by Relay 1. */
  dataTableManufacturingStepEdge?: Maybe<DataTableManufacturingStepsEdge>;
  deletedDataTableManufacturingStepNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableManufacturingStep` mutation. */
export type DeleteDataTableManufacturingStepPayloadDataTableManufacturingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturingStepsOrderBy>>;
};

/** The output of our delete `DataTable` mutation. */
export type DeleteDataTablePayload = {
  __typename?: 'DeleteDataTablePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was deleted by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  deletedDataTableNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTable` mutation. */
export type DeleteDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the `deleteDataTableProcessingStepByNodeId` mutation. */
export type DeleteDataTableProcessingStepByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProcessingStep` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepPayload = {
  __typename?: 'DeleteDataTableProcessingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was deleted by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  deletedDataTableProcessingStepNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the `deleteDataTableProductApplicationJoinByNodeId` mutation. */
export type DeleteDataTableProductApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinPayload = {
  __typename?: 'DeleteDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProduct` that is related to this `DataTableProductApplicationJoin`. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** The `DataTableProductApplicationJoin` that was deleted by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  deletedDataTableProductApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTableProductByNodeId` mutation. */
export type DeleteDataTableProductByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProduct` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProduct` mutation. */
export type DeleteDataTableProductInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProduct` mutation. */
export type DeleteDataTableProductPayload = {
  __typename?: 'DeleteDataTableProductPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was deleted by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  deletedDataTableProductNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProduct` mutation. */
export type DeleteDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the `deleteDataTableProvinceByNodeId` mutation. */
export type DeleteDataTableProvinceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvince` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProvince` mutation. */
export type DeleteDataTableProvinceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProvince` mutation. */
export type DeleteDataTableProvincePayload = {
  __typename?: 'DeleteDataTableProvincePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvince` that was deleted by this mutation. */
  dataTableProvince?: Maybe<DataTableProvince>;
  /** An edge for our `DataTableProvince`. May be used by Relay 1. */
  dataTableProvinceEdge?: Maybe<DataTableProvincesEdge>;
  deletedDataTableProvinceNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProvince` mutation. */
export type DeleteDataTableProvincePayloadDataTableProvinceEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvincesOrderBy>>;
};

/** All input for the `deleteDataTableStorageConditionByNodeId` mutation. */
export type DeleteDataTableStorageConditionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageCondition` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionPayload = {
  __typename?: 'DeleteDataTableStorageConditionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was deleted by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  deletedDataTableStorageConditionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the `deleteDataTableUnitsOfProportionByNodeId` mutation. */
export type DeleteDataTableUnitsOfProportionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableUnitsOfProportion` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionPayload = {
  __typename?: 'DeleteDataTableUnitsOfProportionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was deleted by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  deletedDataTableUnitsOfProportionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the `deleteDataViewByIdentifier` mutation. */
export type DeleteDataViewByIdentifierInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  identifier: Scalars['String']['input'];
};

/** All input for the `deleteDataViewByNodeId` mutation. */
export type DeleteDataViewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataView` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataViewColumnDefinitionByNodeId` mutation. */
export type DeleteDataViewColumnDefinitionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataViewColumnDefinition` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataViewColumnDefinitionByTableNameAndColumnName` mutation. */
export type DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  columnName: Scalars['String']['input'];
  tableName: Scalars['String']['input'];
};

/** All input for the `deleteDataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionPayload = {
  __typename?: 'DeleteDataViewColumnDefinitionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was deleted by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  deletedDataViewColumnDefinitionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the `deleteDataView` mutation. */
export type DeleteDataViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataView` mutation. */
export type DeleteDataViewPayload = {
  __typename?: 'DeleteDataViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was deleted by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  deletedDataViewNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataView` mutation. */
export type DeleteDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the `deleteElementTypePluginByNodeId` mutation. */
export type DeleteElementTypePluginByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteElementTypePlugin` mutation. */
export type DeleteElementTypePluginInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayload = {
  __typename?: 'DeleteElementTypePluginPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedElementTypePluginNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `ElementTypePlugin` that was deleted by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `deleteFileByNodeId` mutation. */
export type DeleteFileByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFileByUniqueId` mutation. */
export type DeleteFileByUniqueIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `deleteFile` mutation. */
export type DeleteFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `File` mutation. */
export type DeleteFilePayload = {
  __typename?: 'DeleteFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFileNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `File` that was deleted by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
};


/** The output of our delete `File` mutation. */
export type DeleteFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the `deleteFilterByCode` mutation. */
export type DeleteFilterByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteFilterByNodeId` mutation. */
export type DeleteFilterByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Filter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFilter` mutation. */
export type DeleteFilterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayload = {
  __typename?: 'DeleteFilterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFilterNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Filter` that was deleted by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `deleteNotificationByNodeId` mutation. */
export type DeleteNotificationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteNotification` mutation. */
export type DeleteNotificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedNotificationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
};


/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `deleteOrganisationApplicationJoinByNodeId` mutation. */
export type DeleteOrganisationApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `OrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinPayload = {
  __typename?: 'DeleteOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganisationApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was deleted by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `OrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `deleteOrganisationByName` mutation. */
export type DeleteOrganisationByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteOrganisationByNodeId` mutation. */
export type DeleteOrganisationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganisationByRegistration` mutation. */
export type DeleteOrganisationByRegistrationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  registration: Scalars['String']['input'];
};

/** All input for the `deleteOrganisation` mutation. */
export type DeleteOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayload = {
  __typename?: 'DeleteOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganisationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Organisation` that was deleted by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `deletePermissionJoinByNodeId` mutation. */
export type DeletePermissionJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionJoin` mutation. */
export type DeletePermissionJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayload = {
  __typename?: 'DeletePermissionJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was deleted by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
};


/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `deletePermissionNameByName` mutation. */
export type DeletePermissionNameByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePermissionNameByNodeId` mutation. */
export type DeletePermissionNameByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionName` mutation. */
export type DeletePermissionNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayload = {
  __typename?: 'DeletePermissionNamePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionNameNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `PermissionName` that was deleted by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `deletePermissionPolicyByName` mutation. */
export type DeletePermissionPolicyByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePermissionPolicyByNodeId` mutation. */
export type DeletePermissionPolicyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionPolicy` mutation. */
export type DeletePermissionPolicyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayload = {
  __typename?: 'DeletePermissionPolicyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionPolicyNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `PermissionPolicy` that was deleted by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `deleteProductApplicationJoinByNodeId` mutation. */
export type DeleteProductApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteProductApplicationJoin` mutation. */
export type DeleteProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ProductApplicationJoin` mutation. */
export type DeleteProductApplicationJoinPayload = {
  __typename?: 'DeleteProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `ProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedProductApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `ProductApplicationJoin` that was deleted by this mutation. */
  productApplicationJoin?: Maybe<ProductApplicationJoin>;
  /** An edge for our `ProductApplicationJoin`. May be used by Relay 1. */
  productApplicationJoinEdge?: Maybe<ProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ProductApplicationJoin` mutation. */
export type DeleteProductApplicationJoinPayloadProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductApplicationJoinsOrderBy>>;
};

/** All input for the `deleteReviewAssignmentAssignerJoinByNodeId` mutation. */
export type DeleteReviewAssignmentAssignerJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignmentAssignerJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinPayload = {
  __typename?: 'DeleteReviewAssignmentAssignerJoinPayload';
  /** Reads a single `User` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewAssignmentAssignerJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was deleted by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our delete `ReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the `deleteReviewAssignmentByNodeId` mutation. */
export type DeleteReviewAssignmentByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewAssignment` mutation. */
export type DeleteReviewAssignmentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayload = {
  __typename?: 'DeleteReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewAssignmentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was deleted by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `deleteReviewByNodeId` mutation. */
export type DeleteReviewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Review` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewByReviewAssignmentId` mutation. */
export type DeleteReviewByReviewAssignmentIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** All input for the `deleteReviewDecisionByNodeId` mutation. */
export type DeleteReviewDecisionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewDecision` mutation. */
export type DeleteReviewDecisionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayload = {
  __typename?: 'DeleteReviewDecisionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewDecisionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was deleted by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `deleteReview` mutation. */
export type DeleteReviewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Review` mutation. */
export type DeleteReviewPayload = {
  __typename?: 'DeleteReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was deleted by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
};


/** The output of our delete `Review` mutation. */
export type DeleteReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `deleteReviewResponseByNodeId` mutation. */
export type DeleteReviewResponseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewResponse` mutation. */
export type DeleteReviewResponseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayload = {
  __typename?: 'DeleteReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewResponseNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was deleted by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `deleteReviewStatusHistoryByNodeId` mutation. */
export type DeleteReviewStatusHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayload = {
  __typename?: 'DeleteReviewStatusHistoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewStatusHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was deleted by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `deleteSystemInfoByNodeId` mutation. */
export type DeleteSystemInfoByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemInfo` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSystemInfo` mutation. */
export type DeleteSystemInfoInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `SystemInfo` mutation. */
export type DeleteSystemInfoPayload = {
  __typename?: 'DeleteSystemInfoPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSystemInfoNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was deleted by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our delete `SystemInfo` mutation. */
export type DeleteSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the `deleteTemplateActionByNodeId` mutation. */
export type DeleteTemplateActionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateAction` mutation. */
export type DeleteTemplateActionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayload = {
  __typename?: 'DeleteTemplateActionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateActionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was deleted by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `deleteTemplateByCodeAndVersionId` mutation. */
export type DeleteTemplateByCodeAndVersionIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** All input for the `deleteTemplateByNodeId` mutation. */
export type DeleteTemplateByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Template` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateCategoryByCode` mutation. */
export type DeleteTemplateCategoryByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteTemplateCategoryByNodeId` mutation. */
export type DeleteTemplateCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateCategory` mutation. */
export type DeleteTemplateCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateCategory` mutation. */
export type DeleteTemplateCategoryPayload = {
  __typename?: 'DeleteTemplateCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateCategoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was deleted by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our delete `TemplateCategory` mutation. */
export type DeleteTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the `deleteTemplateElementByNodeId` mutation. */
export type DeleteTemplateElementByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateElementByTemplateCodeAndCodeAndTemplateVersion` mutation. */
export type DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** All input for the `deleteTemplateElement` mutation. */
export type DeleteTemplateElementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayload = {
  __typename?: 'DeleteTemplateElementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateElementNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was deleted by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `deleteTemplateFilterJoinByNodeId` mutation. */
export type DeleteTemplateFilterJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateFilterJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinPayload = {
  __typename?: 'DeleteTemplateFilterJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateFilterJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was deleted by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our delete `TemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the `deleteTemplate` mutation. */
export type DeleteTemplateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayload = {
  __typename?: 'DeleteTemplatePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was deleted by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `deleteTemplatePermissionByNodeId` mutation. */
export type DeleteTemplatePermissionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplatePermission` mutation. */
export type DeleteTemplatePermissionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayload = {
  __typename?: 'DeleteTemplatePermissionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplatePermissionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was deleted by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `deleteTemplateSectionByNodeId` mutation. */
export type DeleteTemplateSectionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateSectionByTemplateIdAndCode` mutation. */
export type DeleteTemplateSectionByTemplateIdAndCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** All input for the `deleteTemplateSection` mutation. */
export type DeleteTemplateSectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayload = {
  __typename?: 'DeleteTemplateSectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateSectionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was deleted by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `deleteTemplateStageByNodeId` mutation. */
export type DeleteTemplateStageByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateStage` mutation. */
export type DeleteTemplateStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayload = {
  __typename?: 'DeleteTemplateStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateStageNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was deleted by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `deleteTemplateStageReviewLevelByNodeId` mutation. */
export type DeleteTemplateStageReviewLevelByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStageReviewLevel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelPayload = {
  __typename?: 'DeleteTemplateStageReviewLevelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateStageReviewLevelNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was deleted by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our delete `TemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the `deleteTriggerQueueByNodeId` mutation. */
export type DeleteTriggerQueueByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTriggerQueue` mutation. */
export type DeleteTriggerQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayload = {
  __typename?: 'DeleteTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTriggerQueueNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was deleted by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `deleteTriggerScheduleByNodeId` mutation. */
export type DeleteTriggerScheduleByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerSchedule` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTriggerSchedule` mutation. */
export type DeleteTriggerScheduleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TriggerSchedule` mutation. */
export type DeleteTriggerSchedulePayload = {
  __typename?: 'DeleteTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTriggerScheduleNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `User` that is related to this `TriggerSchedule`. */
  editorUser?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was deleted by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our delete `TriggerSchedule` mutation. */
export type DeleteTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the `deleteUserApplicationJoinByNodeId` mutation. */
export type DeleteUserApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `UserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinPayload = {
  __typename?: 'DeleteUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserApplicationJoin`. */
  user?: Maybe<User>;
  /** The `UserApplicationJoin` that was deleted by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our delete `UserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserByUsername` mutation. */
export type DeleteUserByUsernameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  username: Scalars['String']['input'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteUserOrganisationApplicationJoinByNodeId` mutation. */
export type DeleteUserOrganisationApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserOrganisationApplicationJoin` mutation. */
export type DeleteUserOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `UserOrganisationApplicationJoin` mutation. */
export type DeleteUserOrganisationApplicationJoinPayload = {
  __typename?: 'DeleteUserOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserOrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserOrganisationApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserOrganisation` that is related to this `UserOrganisationApplicationJoin`. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** The `UserOrganisationApplicationJoin` that was deleted by this mutation. */
  userOrganisationApplicationJoin?: Maybe<UserOrganisationApplicationJoin>;
  /** An edge for our `UserOrganisationApplicationJoin`. May be used by Relay 1. */
  userOrganisationApplicationJoinEdge?: Maybe<UserOrganisationApplicationJoinsEdge>;
};


/** The output of our delete `UserOrganisationApplicationJoin` mutation. */
export type DeleteUserOrganisationApplicationJoinPayloadUserOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `deleteUserOrganisationByNodeId` mutation. */
export type DeleteUserOrganisationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserOrganisationByUserIdAndOrganisationId` mutation. */
export type DeleteUserOrganisationByUserIdAndOrganisationIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organisationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteUserOrganisation` mutation. */
export type DeleteUserOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayload = {
  __typename?: 'DeleteUserOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserOrganisationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was deleted by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteVerificationByNodeId` mutation. */
export type DeleteVerificationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Verification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteVerificationByUniqueId` mutation. */
export type DeleteVerificationByUniqueIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `deleteVerification` mutation. */
export type DeleteVerificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Verification` mutation. */
export type DeleteVerificationPayload = {
  __typename?: 'DeleteVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVerificationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was deleted by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our delete `Verification` mutation. */
export type DeleteVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

/** All input for the `deleteWholeApplication` mutation. */
export type DeleteWholeApplicationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `deleteWholeApplication` mutation. */
export type DeleteWholeApplicationPayload = {
  __typename?: 'DeleteWholeApplicationPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type ElementTypePlugin = Node & {
  __typename?: 'ElementTypePlugin';
  category?: Maybe<TemplateElementCategory>;
  code: Scalars['String']['output'];
  configComponentName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayComponentName?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  path?: Maybe<Scalars['String']['output']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A condition to be used against `ElementTypePlugin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ElementTypePluginCondition = {
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `configComponentName` field. */
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `displayComponentName` field. */
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A filter to be used against `ElementTypePlugin` object types. All fields are combined with a logical ‘and.’ */
export type ElementTypePluginFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ElementTypePluginFilter>>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `configComponentName` field. */
  configComponentName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `displayComponentName` field. */
  displayComponentName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ElementTypePluginFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ElementTypePluginFilter>>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<StringListFilter>;
};

/** An input for mutations affecting `ElementTypePlugin` */
export type ElementTypePluginInput = {
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Represents an update to a `ElementTypePlugin`. Fields that are set will be updated. */
export type ElementTypePluginPatch = {
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `ElementTypePlugin` values. */
export type ElementTypePluginsConnection = {
  __typename?: 'ElementTypePluginsConnection';
  /** A list of edges which contains the `ElementTypePlugin` and cursor to aid in pagination. */
  edges: Array<ElementTypePluginsEdge>;
  /** A list of `ElementTypePlugin` objects. */
  nodes: Array<Maybe<ElementTypePlugin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ElementTypePlugin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ElementTypePlugin` edge in the connection. */
export type ElementTypePluginsEdge = {
  __typename?: 'ElementTypePluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ElementTypePlugin` at the end of the edge. */
  node?: Maybe<ElementTypePlugin>;
};

/** Methods to use when ordering `ElementTypePlugin`. */
export enum ElementTypePluginsOrderBy {
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ConfigComponentNameAsc = 'CONFIG_COMPONENT_NAME_ASC',
  ConfigComponentNameDesc = 'CONFIG_COMPONENT_NAME_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DisplayComponentNameAsc = 'DISPLAY_COMPONENT_NAME_ASC',
  DisplayComponentNameDesc = 'DISPLAY_COMPONENT_NAME_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC'
}

export enum EventType {
  Assignment = 'ASSIGNMENT',
  Extension = 'EXTENSION',
  Outcome = 'OUTCOME',
  Permission = 'PERMISSION',
  Review = 'REVIEW',
  ReviewDecision = 'REVIEW_DECISION',
  Stage = 'STAGE',
  Status = 'STATUS'
}

/** A filter to be used against EventType fields. All fields are combined with a logical ‘and.’ */
export type EventTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<EventType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<EventType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<EventType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<EventType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<EventType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<EventType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<EventType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<EventType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<EventType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<EventType>>;
};

export type File = Node & {
  __typename?: 'File';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  applicationNoteId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  applicationResponseId?: Maybe<Scalars['Int']['output']>;
  applicationSerial?: Maybe<Scalars['String']['output']>;
  archivePath?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  filePath: Scalars['String']['output'];
  fileSize?: Maybe<Scalars['BigInt']['output']>;
  id: Scalars['Int']['output'];
  isExternalReferenceDoc: Scalars['Boolean']['output'];
  isInternalReferenceDoc: Scalars['Boolean']['output'];
  isOutputDoc: Scalars['Boolean']['output'];
  mimetype?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originalFilename: Scalars['String']['output'];
  submitted?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  thumbnailPath?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['Datetime']['output'];
  toBeDeleted: Scalars['Boolean']['output'];
  uniqueId: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** The `applicationNote` to be created by this mutation. */
export type FileApplicationNoteIdFkeyApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationNoteIdFkeyFileCreateInput = {
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** Input for the nested mutation of `applicationNote` in the `FileInput` mutation. */
export type FileApplicationNoteIdFkeyInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationNoteApplicationNotePkeyConnect>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNoteNodeIdConnect>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationNoteIdFkeyApplicationNoteCreateInput>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationNoteApplicationNotePkeyDelete>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNoteNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationNoteInput` mutation. */
export type FileApplicationNoteIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationNoteIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type FileApplicationResponseIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationResponseIdFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** Input for the nested mutation of `applicationResponse` in the `FileInput` mutation. */
export type FileApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationResponseNodeIdConnect>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationResponseIdFkeyApplicationResponseCreateInput>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationResponseInput` mutation. */
export type FileApplicationResponseIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationResponseIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `application` to be created by this mutation. */
export type FileApplicationSerialFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationSerialFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** Input for the nested mutation of `application` in the `FileInput` mutation. */
export type FileApplicationSerialFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationSerialFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationSerialFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationInput` mutation. */
export type FileApplicationSerialFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationSerialFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `applicationNoteId` field. */
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationSerial` field. */
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `archivePath` field. */
  archivePath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filePath` field. */
  filePath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fileSize` field. */
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isExternalReferenceDoc` field. */
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isInternalReferenceDoc` field. */
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOutputDoc` field. */
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `mimetype` field. */
  mimetype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `originalFilename` field. */
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `submitted` field. */
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `thumbnailPath` field. */
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `toBeDeleted` field. */
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `file` to look up the row to connect. */
export type FileFilePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `file` to look up the row to delete. */
export type FileFilePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `file` to look up the row to connect. */
export type FileFileUniqueIdKeyConnect = {
  uniqueId: Scalars['String']['input'];
};

/** The fields on `file` to look up the row to delete. */
export type FileFileUniqueIdKeyDelete = {
  uniqueId: Scalars['String']['input'];
};

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `applicationByApplicationSerial` relation. */
  applicationByApplicationSerial?: InputMaybe<ApplicationFilter>;
  /** A related `applicationByApplicationSerial` exists. */
  applicationByApplicationSerialExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationNote` relation. */
  applicationNote?: InputMaybe<ApplicationNoteFilter>;
  /** A related `applicationNote` exists. */
  applicationNoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationNoteId` field. */
  applicationNoteId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: InputMaybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationSerial` field. */
  applicationSerial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `archivePath` field. */
  archivePath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filePath` field. */
  filePath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fileSize` field. */
  fileSize?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isExternalReferenceDoc` field. */
  isExternalReferenceDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isInternalReferenceDoc` field. */
  isInternalReferenceDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOutputDoc` field. */
  isOutputDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `mimetype` field. */
  mimetype?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `originalFilename` field. */
  originalFilename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `submitted` field. */
  submitted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `thumbnailPath` field. */
  thumbnailPath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `toBeDeleted` field. */
  toBeDeleted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `File` */
export type FileInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FileNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `file` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationSerialFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileUserIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileUserIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileUserIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** Represents an update to a `File`. Fields that are set will be updated. */
export type FilePatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** A connection to a list of `File` values. */
export type FilesConnection = {
  __typename?: 'FilesConnection';
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>;
  /** A list of `File` objects. */
  nodes: Array<Maybe<File>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `File` edge in the connection. */
export type FilesEdge = {
  __typename?: 'FilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `File` at the end of the edge. */
  node?: Maybe<File>;
};

/** Methods to use when ordering `File`. */
export enum FilesOrderBy {
  ApplicationNoteIdAsc = 'APPLICATION_NOTE_ID_ASC',
  ApplicationNoteIdDesc = 'APPLICATION_NOTE_ID_DESC',
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  ApplicationSerialAsc = 'APPLICATION_SERIAL_ASC',
  ApplicationSerialDesc = 'APPLICATION_SERIAL_DESC',
  ArchivePathAsc = 'ARCHIVE_PATH_ASC',
  ArchivePathDesc = 'ARCHIVE_PATH_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  FilePathAsc = 'FILE_PATH_ASC',
  FilePathDesc = 'FILE_PATH_DESC',
  FileSizeAsc = 'FILE_SIZE_ASC',
  FileSizeDesc = 'FILE_SIZE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsExternalReferenceDocAsc = 'IS_EXTERNAL_REFERENCE_DOC_ASC',
  IsExternalReferenceDocDesc = 'IS_EXTERNAL_REFERENCE_DOC_DESC',
  IsInternalReferenceDocAsc = 'IS_INTERNAL_REFERENCE_DOC_ASC',
  IsInternalReferenceDocDesc = 'IS_INTERNAL_REFERENCE_DOC_DESC',
  IsOutputDocAsc = 'IS_OUTPUT_DOC_ASC',
  IsOutputDocDesc = 'IS_OUTPUT_DOC_DESC',
  MimetypeAsc = 'MIMETYPE_ASC',
  MimetypeDesc = 'MIMETYPE_DESC',
  Natural = 'NATURAL',
  OriginalFilenameAsc = 'ORIGINAL_FILENAME_ASC',
  OriginalFilenameDesc = 'ORIGINAL_FILENAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SubmittedAsc = 'SUBMITTED_ASC',
  SubmittedDesc = 'SUBMITTED_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  ThumbnailPathAsc = 'THUMBNAIL_PATH_ASC',
  ThumbnailPathDesc = 'THUMBNAIL_PATH_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  ToBeDeletedAsc = 'TO_BE_DELETED_ASC',
  ToBeDeletedDesc = 'TO_BE_DELETED_DESC',
  UniqueIdAsc = 'UNIQUE_ID_ASC',
  UniqueIdDesc = 'UNIQUE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The `file` to be created by this mutation. */
export type FileTemplateIdFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** Input for the nested mutation of `template` in the `FileInput` mutation. */
export type FileTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `TemplateInput` mutation. */
export type FileTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileTemplateIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type FileTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `file` to be created by this mutation. */
export type FileUserIdFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `FileInput` mutation. */
export type FileUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `file` in the `UserInput` mutation. */
export type FileUserIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileUserIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnFileForFileUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileUserIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `user` to be created by this mutation. */
export type FileUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

export type Filter = Node & {
  __typename?: 'Filter';
  code: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  query?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins: TemplateFilterJoinsConnection;
  title?: Maybe<Scalars['String']['output']>;
  userRole?: Maybe<PermissionPolicyType>;
};


export type FilterTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** A condition to be used against `Filter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FilterCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `query` field. */
  query?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against `Filter` object types. All fields are combined with a logical ‘and.’ */
export type FilterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FilterFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `query` field. */
  query?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `templateFilterJoins` relation. */
  templateFilterJoins?: InputMaybe<FilterToManyTemplateFilterJoinFilter>;
  /** Some related `templateFilterJoins` exist. */
  templateFilterJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<PermissionPolicyTypeFilter>;
};

/** The fields on `filter` to look up the row to connect. */
export type FilterFilterCodeKeyConnect = {
  code: Scalars['String']['input'];
};

/** The fields on `filter` to look up the row to delete. */
export type FilterFilterCodeKeyDelete = {
  code: Scalars['String']['input'];
};

/** The fields on `filter` to look up the row to connect. */
export type FilterFilterPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `filter` to look up the row to delete. */
export type FilterFilterPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** An input for mutations affecting `Filter` */
export type FilterInput = {
  code: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FilterNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `filter` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FilterNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `filter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** The fields on `filter` to look up the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** The fields on `filter` to look up the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** Represents an update to a `Filter`. Fields that are set will be updated. */
export type FilterPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** A connection to a list of `Filter` values. */
export type FiltersConnection = {
  __typename?: 'FiltersConnection';
  /** A list of edges which contains the `Filter` and cursor to aid in pagination. */
  edges: Array<FiltersEdge>;
  /** A list of `Filter` objects. */
  nodes: Array<Maybe<Filter>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Filter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Filter` edge in the connection. */
export type FiltersEdge = {
  __typename?: 'FiltersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Filter` at the end of the edge. */
  node?: Maybe<Filter>;
};

/** Methods to use when ordering `Filter`. */
export enum FiltersOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QueryAsc = 'QUERY_ASC',
  QueryDesc = 'QUERY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** A filter to be used against many `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type FilterToManyTemplateFilterJoinFilter = {
  /** Every related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilterJoinFilter>;
  /** No related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilterJoinFilter>;
  /** Some related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilterJoinFilter>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `ActionPlugin`. */
  createActionPlugin?: Maybe<CreateActionPluginPayload>;
  /** Creates a single `ActionQueue`. */
  createActionQueue?: Maybe<CreateActionQueuePayload>;
  /** Creates a single `ActivityLog`. */
  createActivityLog?: Maybe<CreateActivityLogPayload>;
  /** Creates a single `Application`. */
  createApplication?: Maybe<CreateApplicationPayload>;
  /** Creates a single `ApplicationListShape`. */
  createApplicationListShape?: Maybe<CreateApplicationListShapePayload>;
  /** Creates a single `ApplicationNote`. */
  createApplicationNote?: Maybe<CreateApplicationNotePayload>;
  /** Creates a single `ApplicationResponse`. */
  createApplicationResponse?: Maybe<CreateApplicationResponsePayload>;
  /** Creates a single `ApplicationStageHistory`. */
  createApplicationStageHistory?: Maybe<CreateApplicationStageHistoryPayload>;
  /** Creates a single `ApplicationStatusHistory`. */
  createApplicationStatusHistory?: Maybe<CreateApplicationStatusHistoryPayload>;
  /** Creates a single `Counter`. */
  createCounter?: Maybe<CreateCounterPayload>;
  /** Creates a single `DataTable`. */
  createDataTable?: Maybe<CreateDataTablePayload>;
  /** Creates a single `DataTableActiveIngredient`. */
  createDataTableActiveIngredient?: Maybe<CreateDataTableActiveIngredientPayload>;
  /** Creates a single `DataTableAdministrationRoute`. */
  createDataTableAdministrationRoute?: Maybe<CreateDataTableAdministrationRoutePayload>;
  /** Creates a single `DataTableAnnex`. */
  createDataTableAnnex?: Maybe<CreateDataTableAnnexPayload>;
  /** Creates a single `DataTableAnnex2`. */
  createDataTableAnnex2?: Maybe<CreateDataTableAnnex2Payload>;
  /** Creates a single `DataTableAtcCode`. */
  createDataTableAtcCode?: Maybe<CreateDataTableAtcCodePayload>;
  /** Creates a single `DataTableAtcTherapeuticCategory`. */
  createDataTableAtcTherapeuticCategory?: Maybe<CreateDataTableAtcTherapeuticCategoryPayload>;
  /** Creates a single `DataTableContainer`. */
  createDataTableContainer?: Maybe<CreateDataTableContainerPayload>;
  /** Creates a single `DataTableCountry`. */
  createDataTableCountry?: Maybe<CreateDataTableCountryPayload>;
  /** Creates a single `DataTableDosageForm`. */
  createDataTableDosageForm?: Maybe<CreateDataTableDosageFormPayload>;
  /** Creates a single `DataTableGenericIngredient`. */
  createDataTableGenericIngredient?: Maybe<CreateDataTableGenericIngredientPayload>;
  /** Creates a single `DataTableIngredientsList`. */
  createDataTableIngredientsList?: Maybe<CreateDataTableIngredientsListPayload>;
  /** Creates a single `DataTableListOfSra`. */
  createDataTableListOfSra?: Maybe<CreateDataTableListOfSraPayload>;
  /** Creates a single `DataTableManufacturingStep`. */
  createDataTableManufacturingStep?: Maybe<CreateDataTableManufacturingStepPayload>;
  /** Creates a single `DataTableProcessingStep`. */
  createDataTableProcessingStep?: Maybe<CreateDataTableProcessingStepPayload>;
  /** Creates a single `DataTableProduct`. */
  createDataTableProduct?: Maybe<CreateDataTableProductPayload>;
  /** Creates a single `DataTableProductApplicationJoin`. */
  createDataTableProductApplicationJoin?: Maybe<CreateDataTableProductApplicationJoinPayload>;
  /** Creates a single `DataTableProvince`. */
  createDataTableProvince?: Maybe<CreateDataTableProvincePayload>;
  /** Creates a single `DataTableStorageCondition`. */
  createDataTableStorageCondition?: Maybe<CreateDataTableStorageConditionPayload>;
  /** Creates a single `DataTableUnitsOfProportion`. */
  createDataTableUnitsOfProportion?: Maybe<CreateDataTableUnitsOfProportionPayload>;
  /** Creates a single `DataView`. */
  createDataView?: Maybe<CreateDataViewPayload>;
  /** Creates a single `DataViewColumnDefinition`. */
  createDataViewColumnDefinition?: Maybe<CreateDataViewColumnDefinitionPayload>;
  /** Creates a single `ElementTypePlugin`. */
  createElementTypePlugin?: Maybe<CreateElementTypePluginPayload>;
  /** Creates a single `File`. */
  createFile?: Maybe<CreateFilePayload>;
  /** Creates a single `Filter`. */
  createFilter?: Maybe<CreateFilterPayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<CreateNotificationPayload>;
  /** Creates a single `Organisation`. */
  createOrganisation?: Maybe<CreateOrganisationPayload>;
  /** Creates a single `OrganisationApplicationJoin`. */
  createOrganisationApplicationJoin?: Maybe<CreateOrganisationApplicationJoinPayload>;
  /** Creates a single `PermissionJoin`. */
  createPermissionJoin?: Maybe<CreatePermissionJoinPayload>;
  /** Creates a single `PermissionName`. */
  createPermissionName?: Maybe<CreatePermissionNamePayload>;
  /** Creates a single `PermissionPolicy`. */
  createPermissionPolicy?: Maybe<CreatePermissionPolicyPayload>;
  /** Creates a single `ProductApplicationJoin`. */
  createProductApplicationJoin?: Maybe<CreateProductApplicationJoinPayload>;
  /** Creates a single `Review`. */
  createReview?: Maybe<CreateReviewPayload>;
  /** Creates a single `ReviewAssignment`. */
  createReviewAssignment?: Maybe<CreateReviewAssignmentPayload>;
  /** Creates a single `ReviewAssignmentAssignerJoin`. */
  createReviewAssignmentAssignerJoin?: Maybe<CreateReviewAssignmentAssignerJoinPayload>;
  /** Creates a single `ReviewDecision`. */
  createReviewDecision?: Maybe<CreateReviewDecisionPayload>;
  /** Creates a single `ReviewResponse`. */
  createReviewResponse?: Maybe<CreateReviewResponsePayload>;
  /** Creates a single `ReviewStatusHistory`. */
  createReviewStatusHistory?: Maybe<CreateReviewStatusHistoryPayload>;
  /** Creates a single `SystemInfo`. */
  createSystemInfo?: Maybe<CreateSystemInfoPayload>;
  /** Creates a single `Template`. */
  createTemplate?: Maybe<CreateTemplatePayload>;
  /** Creates a single `TemplateAction`. */
  createTemplateAction?: Maybe<CreateTemplateActionPayload>;
  /** Creates a single `TemplateCategory`. */
  createTemplateCategory?: Maybe<CreateTemplateCategoryPayload>;
  /** Creates a single `TemplateElement`. */
  createTemplateElement?: Maybe<CreateTemplateElementPayload>;
  /** Creates a single `TemplateFilterJoin`. */
  createTemplateFilterJoin?: Maybe<CreateTemplateFilterJoinPayload>;
  /** Creates a single `TemplatePermission`. */
  createTemplatePermission?: Maybe<CreateTemplatePermissionPayload>;
  /** Creates a single `TemplateSection`. */
  createTemplateSection?: Maybe<CreateTemplateSectionPayload>;
  /** Creates a single `TemplateStage`. */
  createTemplateStage?: Maybe<CreateTemplateStagePayload>;
  /** Creates a single `TemplateStageReviewLevel`. */
  createTemplateStageReviewLevel?: Maybe<CreateTemplateStageReviewLevelPayload>;
  /** Creates a single `TriggerQueue`. */
  createTriggerQueue?: Maybe<CreateTriggerQueuePayload>;
  /** Creates a single `TriggerSchedule`. */
  createTriggerSchedule?: Maybe<CreateTriggerSchedulePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserApplicationJoin`. */
  createUserApplicationJoin?: Maybe<CreateUserApplicationJoinPayload>;
  /** Creates a single `UserOrganisation`. */
  createUserOrganisation?: Maybe<CreateUserOrganisationPayload>;
  /** Creates a single `UserOrganisationApplicationJoin`. */
  createUserOrganisationApplicationJoin?: Maybe<CreateUserOrganisationApplicationJoinPayload>;
  /** Creates a single `Verification`. */
  createVerification?: Maybe<CreateVerificationPayload>;
  /** Deletes a single `ActionPlugin` using a unique key. */
  deleteActionPlugin?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionPlugin` using a unique key. */
  deleteActionPluginByCode?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionPlugin` using its globally unique id. */
  deleteActionPluginByNodeId?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionQueue` using a unique key. */
  deleteActionQueue?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `ActionQueue` using its globally unique id. */
  deleteActionQueueByNodeId?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `ActivityLog` using a unique key. */
  deleteActivityLog?: Maybe<DeleteActivityLogPayload>;
  /** Deletes a single `ActivityLog` using its globally unique id. */
  deleteActivityLogByNodeId?: Maybe<DeleteActivityLogPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplication?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using its globally unique id. */
  deleteApplicationByNodeId?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationByOutcomeRegistration?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationBySerial?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `ApplicationNote` using a unique key. */
  deleteApplicationNote?: Maybe<DeleteApplicationNotePayload>;
  /** Deletes a single `ApplicationNote` using its globally unique id. */
  deleteApplicationNoteByNodeId?: Maybe<DeleteApplicationNotePayload>;
  /** Deletes a single `ApplicationResponse` using a unique key. */
  deleteApplicationResponse?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationResponse` using its globally unique id. */
  deleteApplicationResponseByNodeId?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationStageHistory` using a unique key. */
  deleteApplicationStageHistory?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStageHistory` using its globally unique id. */
  deleteApplicationStageHistoryByNodeId?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using a unique key. */
  deleteApplicationStatusHistory?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using its globally unique id. */
  deleteApplicationStatusHistoryByNodeId?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `Counter` using a unique key. */
  deleteCounter?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `Counter` using a unique key. */
  deleteCounterByName?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `Counter` using its globally unique id. */
  deleteCounterByNodeId?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `DataTable` using a unique key. */
  deleteDataTable?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTableActiveIngredient` using a unique key. */
  deleteDataTableActiveIngredient?: Maybe<DeleteDataTableActiveIngredientPayload>;
  /** Deletes a single `DataTableActiveIngredient` using its globally unique id. */
  deleteDataTableActiveIngredientByNodeId?: Maybe<DeleteDataTableActiveIngredientPayload>;
  /** Deletes a single `DataTableAdministrationRoute` using a unique key. */
  deleteDataTableAdministrationRoute?: Maybe<DeleteDataTableAdministrationRoutePayload>;
  /** Deletes a single `DataTableAdministrationRoute` using its globally unique id. */
  deleteDataTableAdministrationRouteByNodeId?: Maybe<DeleteDataTableAdministrationRoutePayload>;
  /** Deletes a single `DataTableAnnex` using a unique key. */
  deleteDataTableAnnex?: Maybe<DeleteDataTableAnnexPayload>;
  /** Deletes a single `DataTableAnnex2` using a unique key. */
  deleteDataTableAnnex2?: Maybe<DeleteDataTableAnnex2Payload>;
  /** Deletes a single `DataTableAnnex2` using its globally unique id. */
  deleteDataTableAnnex2ByNodeId?: Maybe<DeleteDataTableAnnex2Payload>;
  /** Deletes a single `DataTableAnnex` using its globally unique id. */
  deleteDataTableAnnexByNodeId?: Maybe<DeleteDataTableAnnexPayload>;
  /** Deletes a single `DataTableAtcCode` using a unique key. */
  deleteDataTableAtcCode?: Maybe<DeleteDataTableAtcCodePayload>;
  /** Deletes a single `DataTableAtcCode` using its globally unique id. */
  deleteDataTableAtcCodeByNodeId?: Maybe<DeleteDataTableAtcCodePayload>;
  /** Deletes a single `DataTableAtcTherapeuticCategory` using a unique key. */
  deleteDataTableAtcTherapeuticCategory?: Maybe<DeleteDataTableAtcTherapeuticCategoryPayload>;
  /** Deletes a single `DataTableAtcTherapeuticCategory` using its globally unique id. */
  deleteDataTableAtcTherapeuticCategoryByNodeId?: Maybe<DeleteDataTableAtcTherapeuticCategoryPayload>;
  /** Deletes a single `DataTable` using its globally unique id. */
  deleteDataTableByNodeId?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTable` using a unique key. */
  deleteDataTableByTableName?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTableContainer` using a unique key. */
  deleteDataTableContainer?: Maybe<DeleteDataTableContainerPayload>;
  /** Deletes a single `DataTableContainer` using its globally unique id. */
  deleteDataTableContainerByNodeId?: Maybe<DeleteDataTableContainerPayload>;
  /** Deletes a single `DataTableCountry` using a unique key. */
  deleteDataTableCountry?: Maybe<DeleteDataTableCountryPayload>;
  /** Deletes a single `DataTableCountry` using its globally unique id. */
  deleteDataTableCountryByNodeId?: Maybe<DeleteDataTableCountryPayload>;
  /** Deletes a single `DataTableDosageForm` using a unique key. */
  deleteDataTableDosageForm?: Maybe<DeleteDataTableDosageFormPayload>;
  /** Deletes a single `DataTableDosageForm` using its globally unique id. */
  deleteDataTableDosageFormByNodeId?: Maybe<DeleteDataTableDosageFormPayload>;
  /** Deletes a single `DataTableGenericIngredient` using a unique key. */
  deleteDataTableGenericIngredient?: Maybe<DeleteDataTableGenericIngredientPayload>;
  /** Deletes a single `DataTableGenericIngredient` using its globally unique id. */
  deleteDataTableGenericIngredientByNodeId?: Maybe<DeleteDataTableGenericIngredientPayload>;
  /** Deletes a single `DataTableIngredientsList` using a unique key. */
  deleteDataTableIngredientsList?: Maybe<DeleteDataTableIngredientsListPayload>;
  /** Deletes a single `DataTableIngredientsList` using its globally unique id. */
  deleteDataTableIngredientsListByNodeId?: Maybe<DeleteDataTableIngredientsListPayload>;
  /** Deletes a single `DataTableListOfSra` using a unique key. */
  deleteDataTableListOfSra?: Maybe<DeleteDataTableListOfSraPayload>;
  /** Deletes a single `DataTableListOfSra` using its globally unique id. */
  deleteDataTableListOfSraByNodeId?: Maybe<DeleteDataTableListOfSraPayload>;
  /** Deletes a single `DataTableManufacturingStep` using a unique key. */
  deleteDataTableManufacturingStep?: Maybe<DeleteDataTableManufacturingStepPayload>;
  /** Deletes a single `DataTableManufacturingStep` using its globally unique id. */
  deleteDataTableManufacturingStepByNodeId?: Maybe<DeleteDataTableManufacturingStepPayload>;
  /** Deletes a single `DataTableProcessingStep` using a unique key. */
  deleteDataTableProcessingStep?: Maybe<DeleteDataTableProcessingStepPayload>;
  /** Deletes a single `DataTableProcessingStep` using its globally unique id. */
  deleteDataTableProcessingStepByNodeId?: Maybe<DeleteDataTableProcessingStepPayload>;
  /** Deletes a single `DataTableProduct` using a unique key. */
  deleteDataTableProduct?: Maybe<DeleteDataTableProductPayload>;
  /** Deletes a single `DataTableProductApplicationJoin` using a unique key. */
  deleteDataTableProductApplicationJoin?: Maybe<DeleteDataTableProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProductApplicationJoin` using its globally unique id. */
  deleteDataTableProductApplicationJoinByNodeId?: Maybe<DeleteDataTableProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProduct` using its globally unique id. */
  deleteDataTableProductByNodeId?: Maybe<DeleteDataTableProductPayload>;
  /** Deletes a single `DataTableProvince` using a unique key. */
  deleteDataTableProvince?: Maybe<DeleteDataTableProvincePayload>;
  /** Deletes a single `DataTableProvince` using its globally unique id. */
  deleteDataTableProvinceByNodeId?: Maybe<DeleteDataTableProvincePayload>;
  /** Deletes a single `DataTableStorageCondition` using a unique key. */
  deleteDataTableStorageCondition?: Maybe<DeleteDataTableStorageConditionPayload>;
  /** Deletes a single `DataTableStorageCondition` using its globally unique id. */
  deleteDataTableStorageConditionByNodeId?: Maybe<DeleteDataTableStorageConditionPayload>;
  /** Deletes a single `DataTableUnitsOfProportion` using a unique key. */
  deleteDataTableUnitsOfProportion?: Maybe<DeleteDataTableUnitsOfProportionPayload>;
  /** Deletes a single `DataTableUnitsOfProportion` using its globally unique id. */
  deleteDataTableUnitsOfProportionByNodeId?: Maybe<DeleteDataTableUnitsOfProportionPayload>;
  /** Deletes a single `DataView` using a unique key. */
  deleteDataView?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataView` using a unique key. */
  deleteDataViewByIdentifier?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataView` using its globally unique id. */
  deleteDataViewByNodeId?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataViewColumnDefinition` using a unique key. */
  deleteDataViewColumnDefinition?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `DataViewColumnDefinition` using its globally unique id. */
  deleteDataViewColumnDefinitionByNodeId?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `DataViewColumnDefinition` using a unique key. */
  deleteDataViewColumnDefinitionByTableNameAndColumnName?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `ElementTypePlugin` using a unique key. */
  deleteElementTypePlugin?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `ElementTypePlugin` using its globally unique id. */
  deleteElementTypePluginByNodeId?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFile?: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using its globally unique id. */
  deleteFileByNodeId?: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFileByUniqueId?: Maybe<DeleteFilePayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilter?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilterByCode?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using its globally unique id. */
  deleteFilterByNodeId?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotificationByNodeId?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisation?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `OrganisationApplicationJoin` using a unique key. */
  deleteOrganisationApplicationJoin?: Maybe<DeleteOrganisationApplicationJoinPayload>;
  /** Deletes a single `OrganisationApplicationJoin` using its globally unique id. */
  deleteOrganisationApplicationJoinByNodeId?: Maybe<DeleteOrganisationApplicationJoinPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisationByName?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using its globally unique id. */
  deleteOrganisationByNodeId?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisationByRegistration?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `PermissionJoin` using a unique key. */
  deletePermissionJoin?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionJoin` using its globally unique id. */
  deletePermissionJoinByNodeId?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionNameByName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using its globally unique id. */
  deletePermissionNameByNodeId?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionPolicy` using a unique key. */
  deletePermissionPolicy?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `PermissionPolicy` using a unique key. */
  deletePermissionPolicyByName?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `PermissionPolicy` using its globally unique id. */
  deletePermissionPolicyByNodeId?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `ProductApplicationJoin` using a unique key. */
  deleteProductApplicationJoin?: Maybe<DeleteProductApplicationJoinPayload>;
  /** Deletes a single `ProductApplicationJoin` using its globally unique id. */
  deleteProductApplicationJoinByNodeId?: Maybe<DeleteProductApplicationJoinPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReview?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `ReviewAssignment` using a unique key. */
  deleteReviewAssignment?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `ReviewAssignmentAssignerJoin` using a unique key. */
  deleteReviewAssignmentAssignerJoin?: Maybe<DeleteReviewAssignmentAssignerJoinPayload>;
  /** Deletes a single `ReviewAssignmentAssignerJoin` using its globally unique id. */
  deleteReviewAssignmentAssignerJoinByNodeId?: Maybe<DeleteReviewAssignmentAssignerJoinPayload>;
  /** Deletes a single `ReviewAssignment` using its globally unique id. */
  deleteReviewAssignmentByNodeId?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `Review` using its globally unique id. */
  deleteReviewByNodeId?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReviewByReviewAssignmentId?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `ReviewDecision` using a unique key. */
  deleteReviewDecision?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewDecision` using its globally unique id. */
  deleteReviewDecisionByNodeId?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewResponse` using a unique key. */
  deleteReviewResponse?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewResponse` using its globally unique id. */
  deleteReviewResponseByNodeId?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewStatusHistory` using a unique key. */
  deleteReviewStatusHistory?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `ReviewStatusHistory` using its globally unique id. */
  deleteReviewStatusHistoryByNodeId?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `SystemInfo` using a unique key. */
  deleteSystemInfo?: Maybe<DeleteSystemInfoPayload>;
  /** Deletes a single `SystemInfo` using its globally unique id. */
  deleteSystemInfoByNodeId?: Maybe<DeleteSystemInfoPayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplate?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `TemplateAction` using a unique key. */
  deleteTemplateAction?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `TemplateAction` using its globally unique id. */
  deleteTemplateActionByNodeId?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplateByCodeAndVersionId?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Template` using its globally unique id. */
  deleteTemplateByNodeId?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `TemplateCategory` using a unique key. */
  deleteTemplateCategory?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateCategory` using a unique key. */
  deleteTemplateCategoryByCode?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateCategory` using its globally unique id. */
  deleteTemplateCategoryByNodeId?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateElement` using a unique key. */
  deleteTemplateElement?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateElement` using its globally unique id. */
  deleteTemplateElementByNodeId?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateElement` using a unique key. */
  deleteTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateFilterJoin` using a unique key. */
  deleteTemplateFilterJoin?: Maybe<DeleteTemplateFilterJoinPayload>;
  /** Deletes a single `TemplateFilterJoin` using its globally unique id. */
  deleteTemplateFilterJoinByNodeId?: Maybe<DeleteTemplateFilterJoinPayload>;
  /** Deletes a single `TemplatePermission` using a unique key. */
  deleteTemplatePermission?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplatePermission` using its globally unique id. */
  deleteTemplatePermissionByNodeId?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplateSection` using a unique key. */
  deleteTemplateSection?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateSection` using its globally unique id. */
  deleteTemplateSectionByNodeId?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateSection` using a unique key. */
  deleteTemplateSectionByTemplateIdAndCode?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateStage` using a unique key. */
  deleteTemplateStage?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TemplateStage` using its globally unique id. */
  deleteTemplateStageByNodeId?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TemplateStageReviewLevel` using a unique key. */
  deleteTemplateStageReviewLevel?: Maybe<DeleteTemplateStageReviewLevelPayload>;
  /** Deletes a single `TemplateStageReviewLevel` using its globally unique id. */
  deleteTemplateStageReviewLevelByNodeId?: Maybe<DeleteTemplateStageReviewLevelPayload>;
  /** Deletes a single `TriggerQueue` using a unique key. */
  deleteTriggerQueue?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `TriggerQueue` using its globally unique id. */
  deleteTriggerQueueByNodeId?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `TriggerSchedule` using a unique key. */
  deleteTriggerSchedule?: Maybe<DeleteTriggerSchedulePayload>;
  /** Deletes a single `TriggerSchedule` using its globally unique id. */
  deleteTriggerScheduleByNodeId?: Maybe<DeleteTriggerSchedulePayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserApplicationJoin` using a unique key. */
  deleteUserApplicationJoin?: Maybe<DeleteUserApplicationJoinPayload>;
  /** Deletes a single `UserApplicationJoin` using its globally unique id. */
  deleteUserApplicationJoinByNodeId?: Maybe<DeleteUserApplicationJoinPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByUsername?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserOrganisation` using a unique key. */
  deleteUserOrganisation?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `UserOrganisationApplicationJoin` using a unique key. */
  deleteUserOrganisationApplicationJoin?: Maybe<DeleteUserOrganisationApplicationJoinPayload>;
  /** Deletes a single `UserOrganisationApplicationJoin` using its globally unique id. */
  deleteUserOrganisationApplicationJoinByNodeId?: Maybe<DeleteUserOrganisationApplicationJoinPayload>;
  /** Deletes a single `UserOrganisation` using its globally unique id. */
  deleteUserOrganisationByNodeId?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `UserOrganisation` using a unique key. */
  deleteUserOrganisationByUserIdAndOrganisationId?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `Verification` using a unique key. */
  deleteVerification?: Maybe<DeleteVerificationPayload>;
  /** Deletes a single `Verification` using its globally unique id. */
  deleteVerificationByNodeId?: Maybe<DeleteVerificationPayload>;
  /** Deletes a single `Verification` using a unique key. */
  deleteVerificationByUniqueId?: Maybe<DeleteVerificationPayload>;
  deleteWholeApplication?: Maybe<DeleteWholeApplicationPayload>;
  /** Updates a single `ActionPlugin` using a unique key and a patch. */
  updateActionPlugin?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionPlugin` using a unique key and a patch. */
  updateActionPluginByCode?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionPlugin` using its globally unique id and a patch. */
  updateActionPluginByNodeId?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionQueue` using a unique key and a patch. */
  updateActionQueue?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `ActionQueue` using its globally unique id and a patch. */
  updateActionQueueByNodeId?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `ActivityLog` using a unique key and a patch. */
  updateActivityLog?: Maybe<UpdateActivityLogPayload>;
  /** Updates a single `ActivityLog` using its globally unique id and a patch. */
  updateActivityLogByNodeId?: Maybe<UpdateActivityLogPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplication?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using its globally unique id and a patch. */
  updateApplicationByNodeId?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationByOutcomeRegistration?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationBySerial?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `ApplicationNote` using a unique key and a patch. */
  updateApplicationNote?: Maybe<UpdateApplicationNotePayload>;
  /** Updates a single `ApplicationNote` using its globally unique id and a patch. */
  updateApplicationNoteByNodeId?: Maybe<UpdateApplicationNotePayload>;
  /** Updates a single `ApplicationResponse` using a unique key and a patch. */
  updateApplicationResponse?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationResponse` using its globally unique id and a patch. */
  updateApplicationResponseByNodeId?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationStageHistory` using a unique key and a patch. */
  updateApplicationStageHistory?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStageHistory` using its globally unique id and a patch. */
  updateApplicationStageHistoryByNodeId?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using a unique key and a patch. */
  updateApplicationStatusHistory?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using its globally unique id and a patch. */
  updateApplicationStatusHistoryByNodeId?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `Counter` using a unique key and a patch. */
  updateCounter?: Maybe<UpdateCounterPayload>;
  /** Updates a single `Counter` using a unique key and a patch. */
  updateCounterByName?: Maybe<UpdateCounterPayload>;
  /** Updates a single `Counter` using its globally unique id and a patch. */
  updateCounterByNodeId?: Maybe<UpdateCounterPayload>;
  /** Updates a single `DataTable` using a unique key and a patch. */
  updateDataTable?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTableActiveIngredient` using a unique key and a patch. */
  updateDataTableActiveIngredient?: Maybe<UpdateDataTableActiveIngredientPayload>;
  /** Updates a single `DataTableActiveIngredient` using its globally unique id and a patch. */
  updateDataTableActiveIngredientByNodeId?: Maybe<UpdateDataTableActiveIngredientPayload>;
  /** Updates a single `DataTableAdministrationRoute` using a unique key and a patch. */
  updateDataTableAdministrationRoute?: Maybe<UpdateDataTableAdministrationRoutePayload>;
  /** Updates a single `DataTableAdministrationRoute` using its globally unique id and a patch. */
  updateDataTableAdministrationRouteByNodeId?: Maybe<UpdateDataTableAdministrationRoutePayload>;
  /** Updates a single `DataTableAnnex` using a unique key and a patch. */
  updateDataTableAnnex?: Maybe<UpdateDataTableAnnexPayload>;
  /** Updates a single `DataTableAnnex2` using a unique key and a patch. */
  updateDataTableAnnex2?: Maybe<UpdateDataTableAnnex2Payload>;
  /** Updates a single `DataTableAnnex2` using its globally unique id and a patch. */
  updateDataTableAnnex2ByNodeId?: Maybe<UpdateDataTableAnnex2Payload>;
  /** Updates a single `DataTableAnnex` using its globally unique id and a patch. */
  updateDataTableAnnexByNodeId?: Maybe<UpdateDataTableAnnexPayload>;
  /** Updates a single `DataTableAtcCode` using a unique key and a patch. */
  updateDataTableAtcCode?: Maybe<UpdateDataTableAtcCodePayload>;
  /** Updates a single `DataTableAtcCode` using its globally unique id and a patch. */
  updateDataTableAtcCodeByNodeId?: Maybe<UpdateDataTableAtcCodePayload>;
  /** Updates a single `DataTableAtcTherapeuticCategory` using a unique key and a patch. */
  updateDataTableAtcTherapeuticCategory?: Maybe<UpdateDataTableAtcTherapeuticCategoryPayload>;
  /** Updates a single `DataTableAtcTherapeuticCategory` using its globally unique id and a patch. */
  updateDataTableAtcTherapeuticCategoryByNodeId?: Maybe<UpdateDataTableAtcTherapeuticCategoryPayload>;
  /** Updates a single `DataTable` using its globally unique id and a patch. */
  updateDataTableByNodeId?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTable` using a unique key and a patch. */
  updateDataTableByTableName?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTableContainer` using a unique key and a patch. */
  updateDataTableContainer?: Maybe<UpdateDataTableContainerPayload>;
  /** Updates a single `DataTableContainer` using its globally unique id and a patch. */
  updateDataTableContainerByNodeId?: Maybe<UpdateDataTableContainerPayload>;
  /** Updates a single `DataTableCountry` using a unique key and a patch. */
  updateDataTableCountry?: Maybe<UpdateDataTableCountryPayload>;
  /** Updates a single `DataTableCountry` using its globally unique id and a patch. */
  updateDataTableCountryByNodeId?: Maybe<UpdateDataTableCountryPayload>;
  /** Updates a single `DataTableDosageForm` using a unique key and a patch. */
  updateDataTableDosageForm?: Maybe<UpdateDataTableDosageFormPayload>;
  /** Updates a single `DataTableDosageForm` using its globally unique id and a patch. */
  updateDataTableDosageFormByNodeId?: Maybe<UpdateDataTableDosageFormPayload>;
  /** Updates a single `DataTableGenericIngredient` using a unique key and a patch. */
  updateDataTableGenericIngredient?: Maybe<UpdateDataTableGenericIngredientPayload>;
  /** Updates a single `DataTableGenericIngredient` using its globally unique id and a patch. */
  updateDataTableGenericIngredientByNodeId?: Maybe<UpdateDataTableGenericIngredientPayload>;
  /** Updates a single `DataTableIngredientsList` using a unique key and a patch. */
  updateDataTableIngredientsList?: Maybe<UpdateDataTableIngredientsListPayload>;
  /** Updates a single `DataTableIngredientsList` using its globally unique id and a patch. */
  updateDataTableIngredientsListByNodeId?: Maybe<UpdateDataTableIngredientsListPayload>;
  /** Updates a single `DataTableListOfSra` using a unique key and a patch. */
  updateDataTableListOfSra?: Maybe<UpdateDataTableListOfSraPayload>;
  /** Updates a single `DataTableListOfSra` using its globally unique id and a patch. */
  updateDataTableListOfSraByNodeId?: Maybe<UpdateDataTableListOfSraPayload>;
  /** Updates a single `DataTableManufacturingStep` using a unique key and a patch. */
  updateDataTableManufacturingStep?: Maybe<UpdateDataTableManufacturingStepPayload>;
  /** Updates a single `DataTableManufacturingStep` using its globally unique id and a patch. */
  updateDataTableManufacturingStepByNodeId?: Maybe<UpdateDataTableManufacturingStepPayload>;
  /** Updates a single `DataTableProcessingStep` using a unique key and a patch. */
  updateDataTableProcessingStep?: Maybe<UpdateDataTableProcessingStepPayload>;
  /** Updates a single `DataTableProcessingStep` using its globally unique id and a patch. */
  updateDataTableProcessingStepByNodeId?: Maybe<UpdateDataTableProcessingStepPayload>;
  /** Updates a single `DataTableProduct` using a unique key and a patch. */
  updateDataTableProduct?: Maybe<UpdateDataTableProductPayload>;
  /** Updates a single `DataTableProductApplicationJoin` using a unique key and a patch. */
  updateDataTableProductApplicationJoin?: Maybe<UpdateDataTableProductApplicationJoinPayload>;
  /** Updates a single `DataTableProductApplicationJoin` using its globally unique id and a patch. */
  updateDataTableProductApplicationJoinByNodeId?: Maybe<UpdateDataTableProductApplicationJoinPayload>;
  /** Updates a single `DataTableProduct` using its globally unique id and a patch. */
  updateDataTableProductByNodeId?: Maybe<UpdateDataTableProductPayload>;
  /** Updates a single `DataTableProvince` using a unique key and a patch. */
  updateDataTableProvince?: Maybe<UpdateDataTableProvincePayload>;
  /** Updates a single `DataTableProvince` using its globally unique id and a patch. */
  updateDataTableProvinceByNodeId?: Maybe<UpdateDataTableProvincePayload>;
  /** Updates a single `DataTableStorageCondition` using a unique key and a patch. */
  updateDataTableStorageCondition?: Maybe<UpdateDataTableStorageConditionPayload>;
  /** Updates a single `DataTableStorageCondition` using its globally unique id and a patch. */
  updateDataTableStorageConditionByNodeId?: Maybe<UpdateDataTableStorageConditionPayload>;
  /** Updates a single `DataTableUnitsOfProportion` using a unique key and a patch. */
  updateDataTableUnitsOfProportion?: Maybe<UpdateDataTableUnitsOfProportionPayload>;
  /** Updates a single `DataTableUnitsOfProportion` using its globally unique id and a patch. */
  updateDataTableUnitsOfProportionByNodeId?: Maybe<UpdateDataTableUnitsOfProportionPayload>;
  /** Updates a single `DataView` using a unique key and a patch. */
  updateDataView?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataView` using a unique key and a patch. */
  updateDataViewByIdentifier?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataView` using its globally unique id and a patch. */
  updateDataViewByNodeId?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataViewColumnDefinition` using a unique key and a patch. */
  updateDataViewColumnDefinition?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `DataViewColumnDefinition` using its globally unique id and a patch. */
  updateDataViewColumnDefinitionByNodeId?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `DataViewColumnDefinition` using a unique key and a patch. */
  updateDataViewColumnDefinitionByTableNameAndColumnName?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `ElementTypePlugin` using a unique key and a patch. */
  updateElementTypePlugin?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `ElementTypePlugin` using its globally unique id and a patch. */
  updateElementTypePluginByNodeId?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFile?: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using its globally unique id and a patch. */
  updateFileByNodeId?: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFileByUniqueId?: Maybe<UpdateFilePayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilter?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilterByCode?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using its globally unique id and a patch. */
  updateFilterByNodeId?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotification?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotificationByNodeId?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisation?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `OrganisationApplicationJoin` using a unique key and a patch. */
  updateOrganisationApplicationJoin?: Maybe<UpdateOrganisationApplicationJoinPayload>;
  /** Updates a single `OrganisationApplicationJoin` using its globally unique id and a patch. */
  updateOrganisationApplicationJoinByNodeId?: Maybe<UpdateOrganisationApplicationJoinPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisationByName?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using its globally unique id and a patch. */
  updateOrganisationByNodeId?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisationByRegistration?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `PermissionJoin` using a unique key and a patch. */
  updatePermissionJoin?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionJoin` using its globally unique id and a patch. */
  updatePermissionJoinByNodeId?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionNameByName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using its globally unique id and a patch. */
  updatePermissionNameByNodeId?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionPolicy` using a unique key and a patch. */
  updatePermissionPolicy?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `PermissionPolicy` using a unique key and a patch. */
  updatePermissionPolicyByName?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `PermissionPolicy` using its globally unique id and a patch. */
  updatePermissionPolicyByNodeId?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `ProductApplicationJoin` using a unique key and a patch. */
  updateProductApplicationJoin?: Maybe<UpdateProductApplicationJoinPayload>;
  /** Updates a single `ProductApplicationJoin` using its globally unique id and a patch. */
  updateProductApplicationJoinByNodeId?: Maybe<UpdateProductApplicationJoinPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Updates a single `ReviewAssignment` using a unique key and a patch. */
  updateReviewAssignment?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `ReviewAssignmentAssignerJoin` using a unique key and a patch. */
  updateReviewAssignmentAssignerJoin?: Maybe<UpdateReviewAssignmentAssignerJoinPayload>;
  /** Updates a single `ReviewAssignmentAssignerJoin` using its globally unique id and a patch. */
  updateReviewAssignmentAssignerJoinByNodeId?: Maybe<UpdateReviewAssignmentAssignerJoinPayload>;
  /** Updates a single `ReviewAssignment` using its globally unique id and a patch. */
  updateReviewAssignmentByNodeId?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `Review` using its globally unique id and a patch. */
  updateReviewByNodeId?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReviewByReviewAssignmentId?: Maybe<UpdateReviewPayload>;
  /** Updates a single `ReviewDecision` using a unique key and a patch. */
  updateReviewDecision?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewDecision` using its globally unique id and a patch. */
  updateReviewDecisionByNodeId?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewResponse` using a unique key and a patch. */
  updateReviewResponse?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewResponse` using its globally unique id and a patch. */
  updateReviewResponseByNodeId?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewStatusHistory` using a unique key and a patch. */
  updateReviewStatusHistory?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `ReviewStatusHistory` using its globally unique id and a patch. */
  updateReviewStatusHistoryByNodeId?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `SystemInfo` using a unique key and a patch. */
  updateSystemInfo?: Maybe<UpdateSystemInfoPayload>;
  /** Updates a single `SystemInfo` using its globally unique id and a patch. */
  updateSystemInfoByNodeId?: Maybe<UpdateSystemInfoPayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplate?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `TemplateAction` using a unique key and a patch. */
  updateTemplateAction?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `TemplateAction` using its globally unique id and a patch. */
  updateTemplateActionByNodeId?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplateByCodeAndVersionId?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Template` using its globally unique id and a patch. */
  updateTemplateByNodeId?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `TemplateCategory` using a unique key and a patch. */
  updateTemplateCategory?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateCategory` using a unique key and a patch. */
  updateTemplateCategoryByCode?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateCategory` using its globally unique id and a patch. */
  updateTemplateCategoryByNodeId?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateElement` using a unique key and a patch. */
  updateTemplateElement?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateElement` using its globally unique id and a patch. */
  updateTemplateElementByNodeId?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateElement` using a unique key and a patch. */
  updateTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateFilterJoin` using a unique key and a patch. */
  updateTemplateFilterJoin?: Maybe<UpdateTemplateFilterJoinPayload>;
  /** Updates a single `TemplateFilterJoin` using its globally unique id and a patch. */
  updateTemplateFilterJoinByNodeId?: Maybe<UpdateTemplateFilterJoinPayload>;
  /** Updates a single `TemplatePermission` using a unique key and a patch. */
  updateTemplatePermission?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplatePermission` using its globally unique id and a patch. */
  updateTemplatePermissionByNodeId?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplateSection` using a unique key and a patch. */
  updateTemplateSection?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateSection` using its globally unique id and a patch. */
  updateTemplateSectionByNodeId?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateSection` using a unique key and a patch. */
  updateTemplateSectionByTemplateIdAndCode?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateStage` using a unique key and a patch. */
  updateTemplateStage?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TemplateStage` using its globally unique id and a patch. */
  updateTemplateStageByNodeId?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TemplateStageReviewLevel` using a unique key and a patch. */
  updateTemplateStageReviewLevel?: Maybe<UpdateTemplateStageReviewLevelPayload>;
  /** Updates a single `TemplateStageReviewLevel` using its globally unique id and a patch. */
  updateTemplateStageReviewLevelByNodeId?: Maybe<UpdateTemplateStageReviewLevelPayload>;
  /** Updates a single `TriggerQueue` using a unique key and a patch. */
  updateTriggerQueue?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `TriggerQueue` using its globally unique id and a patch. */
  updateTriggerQueueByNodeId?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `TriggerSchedule` using a unique key and a patch. */
  updateTriggerSchedule?: Maybe<UpdateTriggerSchedulePayload>;
  /** Updates a single `TriggerSchedule` using its globally unique id and a patch. */
  updateTriggerScheduleByNodeId?: Maybe<UpdateTriggerSchedulePayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserApplicationJoin` using a unique key and a patch. */
  updateUserApplicationJoin?: Maybe<UpdateUserApplicationJoinPayload>;
  /** Updates a single `UserApplicationJoin` using its globally unique id and a patch. */
  updateUserApplicationJoinByNodeId?: Maybe<UpdateUserApplicationJoinPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserOrganisation` using a unique key and a patch. */
  updateUserOrganisation?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `UserOrganisationApplicationJoin` using a unique key and a patch. */
  updateUserOrganisationApplicationJoin?: Maybe<UpdateUserOrganisationApplicationJoinPayload>;
  /** Updates a single `UserOrganisationApplicationJoin` using its globally unique id and a patch. */
  updateUserOrganisationApplicationJoinByNodeId?: Maybe<UpdateUserOrganisationApplicationJoinPayload>;
  /** Updates a single `UserOrganisation` using its globally unique id and a patch. */
  updateUserOrganisationByNodeId?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `UserOrganisation` using a unique key and a patch. */
  updateUserOrganisationByUserIdAndOrganisationId?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `Verification` using a unique key and a patch. */
  updateVerification?: Maybe<UpdateVerificationPayload>;
  /** Updates a single `Verification` using its globally unique id and a patch. */
  updateVerificationByNodeId?: Maybe<UpdateVerificationPayload>;
  /** Updates a single `Verification` using a unique key and a patch. */
  updateVerificationByUniqueId?: Maybe<UpdateVerificationPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionPluginArgs = {
  input: CreateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionQueueArgs = {
  input: CreateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActivityLogArgs = {
  input: CreateActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationArgs = {
  input: CreateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationListShapeArgs = {
  input: CreateApplicationListShapeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationNoteArgs = {
  input: CreateApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationResponseArgs = {
  input: CreateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStageHistoryArgs = {
  input: CreateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStatusHistoryArgs = {
  input: CreateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCounterArgs = {
  input: CreateCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableArgs = {
  input: CreateDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableActiveIngredientArgs = {
  input: CreateDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAdministrationRouteArgs = {
  input: CreateDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAnnexArgs = {
  input: CreateDataTableAnnexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAnnex2Args = {
  input: CreateDataTableAnnex2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAtcCodeArgs = {
  input: CreateDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAtcTherapeuticCategoryArgs = {
  input: CreateDataTableAtcTherapeuticCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableContainerArgs = {
  input: CreateDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableCountryArgs = {
  input: CreateDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableDosageFormArgs = {
  input: CreateDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableGenericIngredientArgs = {
  input: CreateDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableIngredientsListArgs = {
  input: CreateDataTableIngredientsListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableListOfSraArgs = {
  input: CreateDataTableListOfSraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableManufacturingStepArgs = {
  input: CreateDataTableManufacturingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProcessingStepArgs = {
  input: CreateDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProductArgs = {
  input: CreateDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProductApplicationJoinArgs = {
  input: CreateDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProvinceArgs = {
  input: CreateDataTableProvinceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableStorageConditionArgs = {
  input: CreateDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableUnitsOfProportionArgs = {
  input: CreateDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataViewArgs = {
  input: CreateDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataViewColumnDefinitionArgs = {
  input: CreateDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateElementTypePluginArgs = {
  input: CreateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFileArgs = {
  input: CreateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFilterArgs = {
  input: CreateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationArgs = {
  input: CreateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganisationArgs = {
  input: CreateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganisationApplicationJoinArgs = {
  input: CreateOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionJoinArgs = {
  input: CreatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionNameArgs = {
  input: CreatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionPolicyArgs = {
  input: CreatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductApplicationJoinArgs = {
  input: CreateProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewArgs = {
  input: CreateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentArgs = {
  input: CreateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentAssignerJoinArgs = {
  input: CreateReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewDecisionArgs = {
  input: CreateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewResponseArgs = {
  input: CreateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewStatusHistoryArgs = {
  input: CreateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSystemInfoArgs = {
  input: CreateSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateArgs = {
  input: CreateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateActionArgs = {
  input: CreateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateCategoryArgs = {
  input: CreateTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateElementArgs = {
  input: CreateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateFilterJoinArgs = {
  input: CreateTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplatePermissionArgs = {
  input: CreateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateSectionArgs = {
  input: CreateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateStageArgs = {
  input: CreateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateStageReviewLevelArgs = {
  input: CreateTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTriggerQueueArgs = {
  input: CreateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTriggerScheduleArgs = {
  input: CreateTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserApplicationJoinArgs = {
  input: CreateUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserOrganisationArgs = {
  input: CreateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserOrganisationApplicationJoinArgs = {
  input: CreateUserOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVerificationArgs = {
  input: CreateVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginArgs = {
  input: DeleteActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginByCodeArgs = {
  input: DeleteActionPluginByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginByNodeIdArgs = {
  input: DeleteActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueArgs = {
  input: DeleteActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueByNodeIdArgs = {
  input: DeleteActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActivityLogArgs = {
  input: DeleteActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActivityLogByNodeIdArgs = {
  input: DeleteActivityLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationArgs = {
  input: DeleteApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByNodeIdArgs = {
  input: DeleteApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByOutcomeRegistrationArgs = {
  input: DeleteApplicationByOutcomeRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationBySerialArgs = {
  input: DeleteApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationNoteArgs = {
  input: DeleteApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationNoteByNodeIdArgs = {
  input: DeleteApplicationNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseArgs = {
  input: DeleteApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseByNodeIdArgs = {
  input: DeleteApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryArgs = {
  input: DeleteApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryByNodeIdArgs = {
  input: DeleteApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryArgs = {
  input: DeleteApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryByNodeIdArgs = {
  input: DeleteApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterArgs = {
  input: DeleteCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterByNameArgs = {
  input: DeleteCounterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterByNodeIdArgs = {
  input: DeleteCounterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableArgs = {
  input: DeleteDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableActiveIngredientArgs = {
  input: DeleteDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableActiveIngredientByNodeIdArgs = {
  input: DeleteDataTableActiveIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAdministrationRouteArgs = {
  input: DeleteDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAdministrationRouteByNodeIdArgs = {
  input: DeleteDataTableAdministrationRouteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAnnexArgs = {
  input: DeleteDataTableAnnexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAnnex2Args = {
  input: DeleteDataTableAnnex2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAnnex2ByNodeIdArgs = {
  input: DeleteDataTableAnnex2ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAnnexByNodeIdArgs = {
  input: DeleteDataTableAnnexByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcCodeArgs = {
  input: DeleteDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcCodeByNodeIdArgs = {
  input: DeleteDataTableAtcCodeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcTherapeuticCategoryArgs = {
  input: DeleteDataTableAtcTherapeuticCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcTherapeuticCategoryByNodeIdArgs = {
  input: DeleteDataTableAtcTherapeuticCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableByNodeIdArgs = {
  input: DeleteDataTableByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableByTableNameArgs = {
  input: DeleteDataTableByTableNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableContainerArgs = {
  input: DeleteDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableContainerByNodeIdArgs = {
  input: DeleteDataTableContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableCountryArgs = {
  input: DeleteDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableCountryByNodeIdArgs = {
  input: DeleteDataTableCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormArgs = {
  input: DeleteDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormByNodeIdArgs = {
  input: DeleteDataTableDosageFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableGenericIngredientArgs = {
  input: DeleteDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableGenericIngredientByNodeIdArgs = {
  input: DeleteDataTableGenericIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableIngredientsListArgs = {
  input: DeleteDataTableIngredientsListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableIngredientsListByNodeIdArgs = {
  input: DeleteDataTableIngredientsListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableListOfSraArgs = {
  input: DeleteDataTableListOfSraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableListOfSraByNodeIdArgs = {
  input: DeleteDataTableListOfSraByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturingStepArgs = {
  input: DeleteDataTableManufacturingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturingStepByNodeIdArgs = {
  input: DeleteDataTableManufacturingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProcessingStepArgs = {
  input: DeleteDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProcessingStepByNodeIdArgs = {
  input: DeleteDataTableProcessingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductArgs = {
  input: DeleteDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductApplicationJoinArgs = {
  input: DeleteDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductApplicationJoinByNodeIdArgs = {
  input: DeleteDataTableProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductByNodeIdArgs = {
  input: DeleteDataTableProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvinceArgs = {
  input: DeleteDataTableProvinceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvinceByNodeIdArgs = {
  input: DeleteDataTableProvinceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionArgs = {
  input: DeleteDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionByNodeIdArgs = {
  input: DeleteDataTableStorageConditionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableUnitsOfProportionArgs = {
  input: DeleteDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableUnitsOfProportionByNodeIdArgs = {
  input: DeleteDataTableUnitsOfProportionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewArgs = {
  input: DeleteDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewByIdentifierArgs = {
  input: DeleteDataViewByIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewByNodeIdArgs = {
  input: DeleteDataViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionArgs = {
  input: DeleteDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionByNodeIdArgs = {
  input: DeleteDataViewColumnDefinitionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  input: DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginArgs = {
  input: DeleteElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginByNodeIdArgs = {
  input: DeleteElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileArgs = {
  input: DeleteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByNodeIdArgs = {
  input: DeleteFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByUniqueIdArgs = {
  input: DeleteFileByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterArgs = {
  input: DeleteFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByCodeArgs = {
  input: DeleteFilterByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByNodeIdArgs = {
  input: DeleteFilterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByNodeIdArgs = {
  input: DeleteNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationArgs = {
  input: DeleteOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationApplicationJoinArgs = {
  input: DeleteOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationApplicationJoinByNodeIdArgs = {
  input: DeleteOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNameArgs = {
  input: DeleteOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNodeIdArgs = {
  input: DeleteOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByRegistrationArgs = {
  input: DeleteOrganisationByRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinArgs = {
  input: DeletePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinByNodeIdArgs = {
  input: DeletePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameArgs = {
  input: DeletePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNameArgs = {
  input: DeletePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNodeIdArgs = {
  input: DeletePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyArgs = {
  input: DeletePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyByNameArgs = {
  input: DeletePermissionPolicyByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyByNodeIdArgs = {
  input: DeletePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductApplicationJoinArgs = {
  input: DeleteProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductApplicationJoinByNodeIdArgs = {
  input: DeleteProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewArgs = {
  input: DeleteReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentArgs = {
  input: DeleteReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentAssignerJoinArgs = {
  input: DeleteReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentAssignerJoinByNodeIdArgs = {
  input: DeleteReviewAssignmentAssignerJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentByNodeIdArgs = {
  input: DeleteReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewByNodeIdArgs = {
  input: DeleteReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewByReviewAssignmentIdArgs = {
  input: DeleteReviewByReviewAssignmentIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionArgs = {
  input: DeleteReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionByNodeIdArgs = {
  input: DeleteReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseArgs = {
  input: DeleteReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseByNodeIdArgs = {
  input: DeleteReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryArgs = {
  input: DeleteReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryByNodeIdArgs = {
  input: DeleteReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemInfoArgs = {
  input: DeleteSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemInfoByNodeIdArgs = {
  input: DeleteSystemInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateArgs = {
  input: DeleteTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionArgs = {
  input: DeleteTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionByNodeIdArgs = {
  input: DeleteTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateByCodeAndVersionIdArgs = {
  input: DeleteTemplateByCodeAndVersionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateByNodeIdArgs = {
  input: DeleteTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryArgs = {
  input: DeleteTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryByCodeArgs = {
  input: DeleteTemplateCategoryByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryByNodeIdArgs = {
  input: DeleteTemplateCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementArgs = {
  input: DeleteTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementByNodeIdArgs = {
  input: DeleteTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  input: DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateFilterJoinArgs = {
  input: DeleteTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateFilterJoinByNodeIdArgs = {
  input: DeleteTemplateFilterJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionArgs = {
  input: DeleteTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionByNodeIdArgs = {
  input: DeleteTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionArgs = {
  input: DeleteTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionByNodeIdArgs = {
  input: DeleteTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionByTemplateIdAndCodeArgs = {
  input: DeleteTemplateSectionByTemplateIdAndCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageArgs = {
  input: DeleteTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageByNodeIdArgs = {
  input: DeleteTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageReviewLevelArgs = {
  input: DeleteTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageReviewLevelByNodeIdArgs = {
  input: DeleteTemplateStageReviewLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueArgs = {
  input: DeleteTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueByNodeIdArgs = {
  input: DeleteTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerScheduleArgs = {
  input: DeleteTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerScheduleByNodeIdArgs = {
  input: DeleteTriggerScheduleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserApplicationJoinArgs = {
  input: DeleteUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserApplicationJoinByNodeIdArgs = {
  input: DeleteUserApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByUsernameArgs = {
  input: DeleteUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationArgs = {
  input: DeleteUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationApplicationJoinArgs = {
  input: DeleteUserOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationApplicationJoinByNodeIdArgs = {
  input: DeleteUserOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationByNodeIdArgs = {
  input: DeleteUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationByUserIdAndOrganisationIdArgs = {
  input: DeleteUserOrganisationByUserIdAndOrganisationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationArgs = {
  input: DeleteVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationByNodeIdArgs = {
  input: DeleteVerificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationByUniqueIdArgs = {
  input: DeleteVerificationByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWholeApplicationArgs = {
  input: DeleteWholeApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginArgs = {
  input: UpdateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginByCodeArgs = {
  input: UpdateActionPluginByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginByNodeIdArgs = {
  input: UpdateActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueArgs = {
  input: UpdateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueByNodeIdArgs = {
  input: UpdateActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActivityLogArgs = {
  input: UpdateActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActivityLogByNodeIdArgs = {
  input: UpdateActivityLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationArgs = {
  input: UpdateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByNodeIdArgs = {
  input: UpdateApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByOutcomeRegistrationArgs = {
  input: UpdateApplicationByOutcomeRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationBySerialArgs = {
  input: UpdateApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationNoteArgs = {
  input: UpdateApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationNoteByNodeIdArgs = {
  input: UpdateApplicationNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseArgs = {
  input: UpdateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseByNodeIdArgs = {
  input: UpdateApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryArgs = {
  input: UpdateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryByNodeIdArgs = {
  input: UpdateApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryArgs = {
  input: UpdateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryByNodeIdArgs = {
  input: UpdateApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterArgs = {
  input: UpdateCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterByNameArgs = {
  input: UpdateCounterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterByNodeIdArgs = {
  input: UpdateCounterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableArgs = {
  input: UpdateDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableActiveIngredientArgs = {
  input: UpdateDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableActiveIngredientByNodeIdArgs = {
  input: UpdateDataTableActiveIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAdministrationRouteArgs = {
  input: UpdateDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAdministrationRouteByNodeIdArgs = {
  input: UpdateDataTableAdministrationRouteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAnnexArgs = {
  input: UpdateDataTableAnnexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAnnex2Args = {
  input: UpdateDataTableAnnex2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAnnex2ByNodeIdArgs = {
  input: UpdateDataTableAnnex2ByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAnnexByNodeIdArgs = {
  input: UpdateDataTableAnnexByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcCodeArgs = {
  input: UpdateDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcCodeByNodeIdArgs = {
  input: UpdateDataTableAtcCodeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcTherapeuticCategoryArgs = {
  input: UpdateDataTableAtcTherapeuticCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcTherapeuticCategoryByNodeIdArgs = {
  input: UpdateDataTableAtcTherapeuticCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableByNodeIdArgs = {
  input: UpdateDataTableByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableByTableNameArgs = {
  input: UpdateDataTableByTableNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableContainerArgs = {
  input: UpdateDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableContainerByNodeIdArgs = {
  input: UpdateDataTableContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableCountryArgs = {
  input: UpdateDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableCountryByNodeIdArgs = {
  input: UpdateDataTableCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormArgs = {
  input: UpdateDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormByNodeIdArgs = {
  input: UpdateDataTableDosageFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableGenericIngredientArgs = {
  input: UpdateDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableGenericIngredientByNodeIdArgs = {
  input: UpdateDataTableGenericIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableIngredientsListArgs = {
  input: UpdateDataTableIngredientsListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableIngredientsListByNodeIdArgs = {
  input: UpdateDataTableIngredientsListByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableListOfSraArgs = {
  input: UpdateDataTableListOfSraInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableListOfSraByNodeIdArgs = {
  input: UpdateDataTableListOfSraByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturingStepArgs = {
  input: UpdateDataTableManufacturingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturingStepByNodeIdArgs = {
  input: UpdateDataTableManufacturingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProcessingStepArgs = {
  input: UpdateDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProcessingStepByNodeIdArgs = {
  input: UpdateDataTableProcessingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductArgs = {
  input: UpdateDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductApplicationJoinArgs = {
  input: UpdateDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductApplicationJoinByNodeIdArgs = {
  input: UpdateDataTableProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductByNodeIdArgs = {
  input: UpdateDataTableProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvinceArgs = {
  input: UpdateDataTableProvinceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvinceByNodeIdArgs = {
  input: UpdateDataTableProvinceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionArgs = {
  input: UpdateDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionByNodeIdArgs = {
  input: UpdateDataTableStorageConditionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableUnitsOfProportionArgs = {
  input: UpdateDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableUnitsOfProportionByNodeIdArgs = {
  input: UpdateDataTableUnitsOfProportionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewArgs = {
  input: UpdateDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewByIdentifierArgs = {
  input: UpdateDataViewByIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewByNodeIdArgs = {
  input: UpdateDataViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionArgs = {
  input: UpdateDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionByNodeIdArgs = {
  input: UpdateDataViewColumnDefinitionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  input: UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginArgs = {
  input: UpdateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginByNodeIdArgs = {
  input: UpdateElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileArgs = {
  input: UpdateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByNodeIdArgs = {
  input: UpdateFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByUniqueIdArgs = {
  input: UpdateFileByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterArgs = {
  input: UpdateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByCodeArgs = {
  input: UpdateFilterByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByNodeIdArgs = {
  input: UpdateFilterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationArgs = {
  input: UpdateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByNodeIdArgs = {
  input: UpdateNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationArgs = {
  input: UpdateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationApplicationJoinArgs = {
  input: UpdateOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationApplicationJoinByNodeIdArgs = {
  input: UpdateOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNameArgs = {
  input: UpdateOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNodeIdArgs = {
  input: UpdateOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByRegistrationArgs = {
  input: UpdateOrganisationByRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinArgs = {
  input: UpdatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinByNodeIdArgs = {
  input: UpdatePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameArgs = {
  input: UpdatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNameArgs = {
  input: UpdatePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNodeIdArgs = {
  input: UpdatePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyArgs = {
  input: UpdatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyByNameArgs = {
  input: UpdatePermissionPolicyByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyByNodeIdArgs = {
  input: UpdatePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductApplicationJoinArgs = {
  input: UpdateProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductApplicationJoinByNodeIdArgs = {
  input: UpdateProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewArgs = {
  input: UpdateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentArgs = {
  input: UpdateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentAssignerJoinArgs = {
  input: UpdateReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentAssignerJoinByNodeIdArgs = {
  input: UpdateReviewAssignmentAssignerJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentByNodeIdArgs = {
  input: UpdateReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewByNodeIdArgs = {
  input: UpdateReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewByReviewAssignmentIdArgs = {
  input: UpdateReviewByReviewAssignmentIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionArgs = {
  input: UpdateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionByNodeIdArgs = {
  input: UpdateReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseArgs = {
  input: UpdateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseByNodeIdArgs = {
  input: UpdateReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryArgs = {
  input: UpdateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryByNodeIdArgs = {
  input: UpdateReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemInfoArgs = {
  input: UpdateSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemInfoByNodeIdArgs = {
  input: UpdateSystemInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateArgs = {
  input: UpdateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionArgs = {
  input: UpdateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionByNodeIdArgs = {
  input: UpdateTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateByCodeAndVersionIdArgs = {
  input: UpdateTemplateByCodeAndVersionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateByNodeIdArgs = {
  input: UpdateTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryArgs = {
  input: UpdateTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryByCodeArgs = {
  input: UpdateTemplateCategoryByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryByNodeIdArgs = {
  input: UpdateTemplateCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementArgs = {
  input: UpdateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementByNodeIdArgs = {
  input: UpdateTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  input: UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateFilterJoinArgs = {
  input: UpdateTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateFilterJoinByNodeIdArgs = {
  input: UpdateTemplateFilterJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionArgs = {
  input: UpdateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionByNodeIdArgs = {
  input: UpdateTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionArgs = {
  input: UpdateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionByNodeIdArgs = {
  input: UpdateTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionByTemplateIdAndCodeArgs = {
  input: UpdateTemplateSectionByTemplateIdAndCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageArgs = {
  input: UpdateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageByNodeIdArgs = {
  input: UpdateTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageReviewLevelArgs = {
  input: UpdateTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageReviewLevelByNodeIdArgs = {
  input: UpdateTemplateStageReviewLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueArgs = {
  input: UpdateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueByNodeIdArgs = {
  input: UpdateTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerScheduleArgs = {
  input: UpdateTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerScheduleByNodeIdArgs = {
  input: UpdateTriggerScheduleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserApplicationJoinArgs = {
  input: UpdateUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserApplicationJoinByNodeIdArgs = {
  input: UpdateUserApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationArgs = {
  input: UpdateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationApplicationJoinArgs = {
  input: UpdateUserOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationApplicationJoinByNodeIdArgs = {
  input: UpdateUserOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationByNodeIdArgs = {
  input: UpdateUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationByUserIdAndOrganisationIdArgs = {
  input: UpdateUserOrganisationByUserIdAndOrganisationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationArgs = {
  input: UpdateVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationByNodeIdArgs = {
  input: UpdateVerificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationByUniqueIdArgs = {
  input: UpdateVerificationByUniqueIdInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  attachments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  emailRecipients?: Maybe<Scalars['String']['output']>;
  emailSent?: Maybe<Scalars['Boolean']['output']>;
  emailServerLog?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isRead?: Maybe<Scalars['Boolean']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** The `application` to be created by this mutation. */
export type NotificationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `NotificationInput` mutation. */
export type NotificationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<NotificationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `notification` in the `ApplicationInput` mutation. */
export type NotificationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<NotificationNodeIdConnect>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<NotificationApplicationIdFkeyNotificationCreateInput>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<NotificationNodeIdDelete>>;
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationApplicationIdFkeyNotificationCreateInput = {
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** A condition to be used against `Notification` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NotificationCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `attachments` field. */
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `emailRecipients` field. */
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailSent` field. */
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `emailServerLog` field. */
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isRead` field. */
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’ */
export type NotificationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `attachments` field. */
  attachments?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `emailRecipients` field. */
  emailRecipients?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailSent` field. */
  emailSent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `emailServerLog` field. */
  emailServerLog?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isRead` field. */
  isRead?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NotificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Notification` */
export type NotificationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type NotificationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type NotificationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `notification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The fields on `notification` to look up the row to connect. */
export type NotificationNotificationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `notification` to look up the row to delete. */
export type NotificationNotificationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch;
};

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export type NotificationPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** Input for the nested mutation of `review` in the `NotificationInput` mutation. */
export type NotificationReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<NotificationReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `notification` in the `ReviewInput` mutation. */
export type NotificationReviewIdFkeyInverseInput = {
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<NotificationNodeIdConnect>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<NotificationReviewIdFkeyNotificationCreateInput>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<NotificationNodeIdDelete>>;
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationReviewIdFkeyNotificationCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** The `review` to be created by this mutation. */
export type NotificationReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** A connection to a list of `Notification` values. */
export type NotificationsConnection = {
  __typename?: 'NotificationsConnection';
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: Array<NotificationsEdge>;
  /** A list of `Notification` objects. */
  nodes: Array<Maybe<Notification>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Notification` edge in the connection. */
export type NotificationsEdge = {
  __typename?: 'NotificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Notification` at the end of the edge. */
  node?: Maybe<Notification>;
};

/** Methods to use when ordering `Notification`. */
export enum NotificationsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AttachmentsAsc = 'ATTACHMENTS_ASC',
  AttachmentsDesc = 'ATTACHMENTS_DESC',
  EmailRecipientsAsc = 'EMAIL_RECIPIENTS_ASC',
  EmailRecipientsDesc = 'EMAIL_RECIPIENTS_DESC',
  EmailSentAsc = 'EMAIL_SENT_ASC',
  EmailSentDesc = 'EMAIL_SENT_DESC',
  EmailServerLogAsc = 'EMAIL_SERVER_LOG_ASC',
  EmailServerLogDesc = 'EMAIL_SERVER_LOG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsReadAsc = 'IS_READ_ASC',
  IsReadDesc = 'IS_READ_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `NotificationInput` mutation. */
export type NotificationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<NotificationUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `notification` in the `UserInput` mutation. */
export type NotificationUserIdFkeyInverseInput = {
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<NotificationNodeIdConnect>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<NotificationUserIdFkeyNotificationCreateInput>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<NotificationNodeIdDelete>>;
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationUserIdFkeyNotificationCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type NotificationUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

export type Organisation = Node & {
  __typename?: 'Organisation';
  address?: Maybe<Scalars['String']['output']>;
  agent?: Maybe<Scalars['JSON']['output']>;
  agentId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotesByOrgId: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applicationsByOrgId: ApplicationsConnection;
  authorisation?: Maybe<Scalars['JSON']['output']>;
  contact?: Maybe<Scalars['JSON']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isSystemOrg?: Maybe<Scalars['Boolean']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins: OrganisationApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  postalAddress?: Maybe<Scalars['String']['output']>;
  postalCountry?: Maybe<Scalars['String']['output']>;
  postalProvince?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  registration?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
  registrationDocumentation?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins: ReviewAssignmentAssignerJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  type?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
};


export type OrganisationApplicationNotesByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type OrganisationApplicationsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type OrganisationOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


export type OrganisationPermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type OrganisationReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type OrganisationReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type OrganisationUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

export type OrganisationApplicationJoin = Node & {
  __typename?: 'OrganisationApplicationJoin';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `OrganisationApplicationJoinInput` mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `organisationApplicationJoin` in the `ApplicationInput` mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdConnect>>;
  /** A `OrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `organisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `organisationApplicationJoin` to be created by this mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** A condition to be used against `OrganisationApplicationJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type OrganisationApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `OrganisationApplicationJoin` */
export type OrganisationApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrganisationApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrganisationApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to connect. */
export type OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisationApplicationJoin` to look up the row to delete. */
export type OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `organisation` in the `OrganisationApplicationJoinInput` mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `organisationApplicationJoin` in the `OrganisationInput` mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdConnect>>;
  /** A `OrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `organisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisationApplicationJoin` to be created by this mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** The `organisation` to be created by this mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** Represents an update to a `OrganisationApplicationJoin`. Fields that are set will be updated. */
export type OrganisationApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** A connection to a list of `OrganisationApplicationJoin` values. */
export type OrganisationApplicationJoinsConnection = {
  __typename?: 'OrganisationApplicationJoinsConnection';
  /** A list of edges which contains the `OrganisationApplicationJoin` and cursor to aid in pagination. */
  edges: Array<OrganisationApplicationJoinsEdge>;
  /** A list of `OrganisationApplicationJoin` objects. */
  nodes: Array<Maybe<OrganisationApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganisationApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganisationApplicationJoin` edge in the connection. */
export type OrganisationApplicationJoinsEdge = {
  __typename?: 'OrganisationApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganisationApplicationJoin` at the end of the edge. */
  node?: Maybe<OrganisationApplicationJoin>;
};

/** Methods to use when ordering `OrganisationApplicationJoin`. */
export enum OrganisationApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Organisation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type OrganisationCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `agent` field. */
  agent?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `agentId` field. */
  agentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `authorisation` field. */
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postalAddress` field. */
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postalCountry` field. */
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postalProvince` field. */
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `province` field. */
  province?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registration` field. */
  registration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `registrationDocumentation` field. */
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Organisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Filter by the object’s `agent` field. */
  agent?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `agentId` field. */
  agentId?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganisationFilter>>;
  /** Filter by the object’s `applicationNotesByOrgId` relation. */
  applicationNotesByOrgId?: InputMaybe<OrganisationToManyApplicationNoteFilter>;
  /** Some related `applicationNotesByOrgId` exist. */
  applicationNotesByOrgIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationsByOrgId` relation. */
  applicationsByOrgId?: InputMaybe<OrganisationToManyApplicationFilter>;
  /** Some related `applicationsByOrgId` exist. */
  applicationsByOrgIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `authorisation` field. */
  authorisation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `contact` field. */
  contact?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganisationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganisationFilter>>;
  /** Filter by the object’s `organisationApplicationJoins` relation. */
  organisationApplicationJoins?: InputMaybe<OrganisationToManyOrganisationApplicationJoinFilter>;
  /** Some related `organisationApplicationJoins` exist. */
  organisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: InputMaybe<OrganisationToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `postalAddress` field. */
  postalAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postalCountry` field. */
  postalCountry?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postalProvince` field. */
  postalProvince?: InputMaybe<StringFilter>;
  /** Filter by the object’s `province` field. */
  province?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registration` field. */
  registration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `registrationDocumentation` field. */
  registrationDocumentation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewAssignmentAssignerJoins` relation. */
  reviewAssignmentAssignerJoins?: InputMaybe<OrganisationToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoins` exist. */
  reviewAssignmentAssignerJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<OrganisationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: InputMaybe<OrganisationToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Organisation` */
export type OrganisationInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `organisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationRegistrationKeyConnect = {
  registration: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationRegistrationKeyDelete = {
  registration: Scalars['String']['input'];
};

/** Represents an update to a `Organisation`. Fields that are set will be updated. */
export type OrganisationPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** A connection to a list of `Organisation` values. */
export type OrganisationsConnection = {
  __typename?: 'OrganisationsConnection';
  /** A list of edges which contains the `Organisation` and cursor to aid in pagination. */
  edges: Array<OrganisationsEdge>;
  /** A list of `Organisation` objects. */
  nodes: Array<Maybe<Organisation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organisation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organisation` edge in the connection. */
export type OrganisationsEdge = {
  __typename?: 'OrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organisation` at the end of the edge. */
  node?: Maybe<Organisation>;
};

/** Methods to use when ordering `Organisation`. */
export enum OrganisationsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  AgentAsc = 'AGENT_ASC',
  AgentDesc = 'AGENT_DESC',
  AgentIdAsc = 'AGENT_ID_ASC',
  AgentIdDesc = 'AGENT_ID_DESC',
  AuthorisationAsc = 'AUTHORISATION_ASC',
  AuthorisationDesc = 'AUTHORISATION_DESC',
  ContactAsc = 'CONTACT_ASC',
  ContactDesc = 'CONTACT_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsSystemOrgAsc = 'IS_SYSTEM_ORG_ASC',
  IsSystemOrgDesc = 'IS_SYSTEM_ORG_DESC',
  LogoUrlAsc = 'LOGO_URL_ASC',
  LogoUrlDesc = 'LOGO_URL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PostalAddressAsc = 'POSTAL_ADDRESS_ASC',
  PostalAddressDesc = 'POSTAL_ADDRESS_DESC',
  PostalCountryAsc = 'POSTAL_COUNTRY_ASC',
  PostalCountryDesc = 'POSTAL_COUNTRY_DESC',
  PostalProvinceAsc = 'POSTAL_PROVINCE_ASC',
  PostalProvinceDesc = 'POSTAL_PROVINCE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProvinceAsc = 'PROVINCE_ASC',
  ProvinceDesc = 'PROVINCE_DESC',
  RegistrationAsc = 'REGISTRATION_ASC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC',
  RegistrationDesc = 'REGISTRATION_DESC',
  RegistrationDocumentationAsc = 'REGISTRATION_DOCUMENTATION_ASC',
  RegistrationDocumentationDesc = 'REGISTRATION_DOCUMENTATION_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyOrganisationApplicationJoinFilter = {
  /** Every related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** No related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Some related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganisationApplicationJoinFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationFilter>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PermissionJoin = Node & {
  __typename?: 'PermissionJoin';
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  permissionNameId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `PermissionJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PermissionJoinCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionJoinFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: InputMaybe<PermissionNameFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `PermissionJoin` */
export type PermissionJoinInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `PermissionJoinInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `permissionJoin` in the `OrganisationInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** Represents an update to a `PermissionJoin`. Fields that are set will be updated. */
export type PermissionJoinPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** The fields on `permissionJoin` to look up the row to connect. */
export type PermissionJoinPermissionJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionJoin` to look up the row to delete. */
export type PermissionJoinPermissionJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `permissionName` in the `PermissionJoinInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionNameNodeIdConnect>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `permissionJoin` in the `PermissionNameInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** A connection to a list of `PermissionJoin` values. */
export type PermissionJoinsConnection = {
  __typename?: 'PermissionJoinsConnection';
  /** A list of edges which contains the `PermissionJoin` and cursor to aid in pagination. */
  edges: Array<PermissionJoinsEdge>;
  /** A list of `PermissionJoin` objects. */
  nodes: Array<Maybe<PermissionJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionJoin` edge in the connection. */
export type PermissionJoinsEdge = {
  __typename?: 'PermissionJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionJoin` at the end of the edge. */
  node?: Maybe<PermissionJoin>;
};

/** Methods to use when ordering `PermissionJoin`. */
export enum PermissionJoinsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Input for the nested mutation of `user` in the `PermissionJoinInput` mutation. */
export type PermissionJoinUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionJoinUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `permissionJoin` in the `UserInput` mutation. */
export type PermissionJoinUserIdFkeyInverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionJoinUserIdFkeyPermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinUserIdFkeyPermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type PermissionJoinUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

export type PermissionName = Node & {
  __typename?: 'PermissionName';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isSystemOrgPermission?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  permissionPolicyId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
};


export type PermissionNamePermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type PermissionNameTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** A condition to be used against `PermissionName` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PermissionNameCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionNameFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionNameFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionNameFilter>>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: InputMaybe<PermissionNameToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionPolicy` relation. */
  permissionPolicy?: InputMaybe<PermissionPolicyFilter>;
  /** A related `permissionPolicy` exists. */
  permissionPolicyExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: InputMaybe<PermissionNameToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `PermissionName` */
export type PermissionNameInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionNameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionNameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionName` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** Represents an update to a `PermissionName`. Fields that are set will be updated. */
export type PermissionNamePatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNameNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNameNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNamePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNamePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `permissionPolicy` in the `PermissionNameInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInput = {
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionPolicyPermissionPolicyPkeyConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionPolicyPermissionPolicyNameKeyConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionPolicyNodeIdConnect>;
  /** A `PermissionPolicyInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionPolicyPermissionPolicyPkeyDelete>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionPolicyPermissionPolicyNameKeyDelete>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionPolicyNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `permissionName` in the `PermissionPolicyInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInverseInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionNamePermissionNamePkeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<Array<PermissionNamePermissionNameNameKeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionNameNodeIdConnect>>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionNamePermissionNamePkeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<Array<PermissionNamePermissionNameNameKeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionNameNodeIdDelete>>;
  /** Flag indicating whether all other `permissionName` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `permissionPolicy` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** A connection to a list of `PermissionName` values. */
export type PermissionNamesConnection = {
  __typename?: 'PermissionNamesConnection';
  /** A list of edges which contains the `PermissionName` and cursor to aid in pagination. */
  edges: Array<PermissionNamesEdge>;
  /** A list of `PermissionName` objects. */
  nodes: Array<Maybe<PermissionName>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionName` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionName` edge in the connection. */
export type PermissionNamesEdge = {
  __typename?: 'PermissionNamesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionName` at the end of the edge. */
  node?: Maybe<PermissionName>;
};

/** Methods to use when ordering `PermissionName`. */
export enum PermissionNamesOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsSystemOrgPermissionAsc = 'IS_SYSTEM_ORG_PERMISSION_ASC',
  IsSystemOrgPermissionDesc = 'IS_SYSTEM_ORG_PERMISSION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplatePermissionFilter>;
};

/** A connection to a list of `PermissionPolicy` values. */
export type PermissionPoliciesConnection = {
  __typename?: 'PermissionPoliciesConnection';
  /** A list of edges which contains the `PermissionPolicy` and cursor to aid in pagination. */
  edges: Array<PermissionPoliciesEdge>;
  /** A list of `PermissionPolicy` objects. */
  nodes: Array<Maybe<PermissionPolicy>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionPolicy` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionPolicy` edge in the connection. */
export type PermissionPoliciesEdge = {
  __typename?: 'PermissionPoliciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionPolicy` at the end of the edge. */
  node?: Maybe<PermissionPolicy>;
};

/** Methods to use when ordering `PermissionPolicy`. */
export enum PermissionPoliciesOrderBy {
  DefaultRestrictionsAsc = 'DEFAULT_RESTRICTIONS_ASC',
  DefaultRestrictionsDesc = 'DEFAULT_RESTRICTIONS_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsAdminAsc = 'IS_ADMIN_ASC',
  IsAdminDesc = 'IS_ADMIN_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RulesAsc = 'RULES_ASC',
  RulesDesc = 'RULES_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

export type PermissionPolicy = Node & {
  __typename?: 'PermissionPolicy';
  defaultRestrictions?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isAdmin?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames: PermissionNamesConnection;
  rules?: Maybe<Scalars['JSON']['output']>;
  type?: Maybe<PermissionPolicyType>;
};


export type PermissionPolicyPermissionNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionNameCondition>;
  filter?: InputMaybe<PermissionNameFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** A condition to be used against `PermissionPolicy` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PermissionPolicyCondition = {
  /** Checks for equality with the object’s `defaultRestrictions` field. */
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rules` field. */
  rules?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against `PermissionPolicy` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionPolicyFilter>>;
  /** Filter by the object’s `defaultRestrictions` field. */
  defaultRestrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionPolicyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionPolicyFilter>>;
  /** Filter by the object’s `permissionNames` relation. */
  permissionNames?: InputMaybe<PermissionPolicyToManyPermissionNameFilter>;
  /** Some related `permissionNames` exist. */
  permissionNamesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rules` field. */
  rules?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<PermissionPolicyTypeFilter>;
};

/** An input for mutations affecting `PermissionPolicy` */
export type PermissionPolicyInput = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionPolicyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionPolicyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionPolicy` to look up the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The fields on `permissionPolicy` to look up the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** Represents an update to a `PermissionPolicy`. Fields that are set will be updated. */
export type PermissionPolicyPatch = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** The fields on `permissionPolicy` to look up the row to connect. */
export type PermissionPolicyPermissionPolicyNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionPolicy` to look up the row to delete. */
export type PermissionPolicyPermissionPolicyNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionPolicy` to look up the row to connect. */
export type PermissionPolicyPermissionPolicyPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionPolicy` to look up the row to delete. */
export type PermissionPolicyPermissionPolicyPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyToManyPermissionNameFilter = {
  /** Every related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionNameFilter>;
  /** No related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionNameFilter>;
  /** Some related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionNameFilter>;
};

export enum PermissionPolicyType {
  Apply = 'APPLY',
  Assign = 'ASSIGN',
  Review = 'REVIEW',
  View = 'VIEW'
}

/** A filter to be used against PermissionPolicyType fields. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<PermissionPolicyType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<PermissionPolicyType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<PermissionPolicyType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<PermissionPolicyType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<PermissionPolicyType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<PermissionPolicyType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<PermissionPolicyType>>;
};

export type PermissionsAll = {
  __typename?: 'PermissionsAll';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  canMakeFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  canSelfAssign?: Maybe<Scalars['Boolean']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isAdmin?: Maybe<Scalars['Boolean']['output']>;
  isSystemOrgPermission?: Maybe<Scalars['Boolean']['output']>;
  isUserCategory?: Maybe<Scalars['Boolean']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  permissionJoinId?: Maybe<Scalars['Int']['output']>;
  permissionName?: Maybe<Scalars['String']['output']>;
  permissionNameId?: Maybe<Scalars['Int']['output']>;
  permissionPolicyId?: Maybe<Scalars['Int']['output']>;
  permissionPolicyRules?: Maybe<Scalars['JSON']['output']>;
  permissionType?: Maybe<PermissionPolicyType>;
  policyName?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['JSON']['output']>;
  reviewLevel?: Maybe<Scalars['Int']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templatePermissionId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `PermissionsAll` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PermissionsAllCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isUserCategory` field. */
  isUserCategory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionJoinId` field. */
  permissionJoinId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionName` field. */
  permissionName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `permissionType` field. */
  permissionType?: InputMaybe<PermissionPolicyType>;
  /** Checks for equality with the object’s `policyName` field. */
  policyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `restrictions` field. */
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `reviewLevel` field. */
  reviewLevel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templatePermissionId` field. */
  templatePermissionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PermissionsAll` object types. All fields are combined with a logical ‘and.’ */
export type PermissionsAllFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionsAllFilter>>;
  /** Filter by the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isUserCategory` field. */
  isUserCategory?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionsAllFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionsAllFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `permissionJoinId` field. */
  permissionJoinId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionName` field. */
  permissionName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `permissionType` field. */
  permissionType?: InputMaybe<PermissionPolicyTypeFilter>;
  /** Filter by the object’s `policyName` field. */
  policyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `restrictions` field. */
  restrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewLevel` field. */
  reviewLevel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templatePermissionId` field. */
  templatePermissionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PermissionsAll` values. */
export type PermissionsAllsConnection = {
  __typename?: 'PermissionsAllsConnection';
  /** A list of edges which contains the `PermissionsAll` and cursor to aid in pagination. */
  edges: Array<PermissionsAllsEdge>;
  /** A list of `PermissionsAll` objects. */
  nodes: Array<Maybe<PermissionsAll>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionsAll` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionsAll` edge in the connection. */
export type PermissionsAllsEdge = {
  __typename?: 'PermissionsAllsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionsAll` at the end of the edge. */
  node?: Maybe<PermissionsAll>;
};

/** Methods to use when ordering `PermissionsAll`. */
export enum PermissionsAllsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  CanMakeFinalDecisionAsc = 'CAN_MAKE_FINAL_DECISION_ASC',
  CanMakeFinalDecisionDesc = 'CAN_MAKE_FINAL_DECISION_DESC',
  CanSelfAssignAsc = 'CAN_SELF_ASSIGN_ASC',
  CanSelfAssignDesc = 'CAN_SELF_ASSIGN_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsAdminAsc = 'IS_ADMIN_ASC',
  IsAdminDesc = 'IS_ADMIN_DESC',
  IsSystemOrgPermissionAsc = 'IS_SYSTEM_ORG_PERMISSION_ASC',
  IsSystemOrgPermissionDesc = 'IS_SYSTEM_ORG_PERMISSION_DESC',
  IsUserCategoryAsc = 'IS_USER_CATEGORY_ASC',
  IsUserCategoryDesc = 'IS_USER_CATEGORY_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  PermissionJoinIdAsc = 'PERMISSION_JOIN_ID_ASC',
  PermissionJoinIdDesc = 'PERMISSION_JOIN_ID_DESC',
  PermissionNameAsc = 'PERMISSION_NAME_ASC',
  PermissionNameDesc = 'PERMISSION_NAME_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PermissionPolicyRulesAsc = 'PERMISSION_POLICY_RULES_ASC',
  PermissionPolicyRulesDesc = 'PERMISSION_POLICY_RULES_DESC',
  PermissionTypeAsc = 'PERMISSION_TYPE_ASC',
  PermissionTypeDesc = 'PERMISSION_TYPE_DESC',
  PolicyNameAsc = 'POLICY_NAME_ASC',
  PolicyNameDesc = 'POLICY_NAME_DESC',
  RestrictionsAsc = 'RESTRICTIONS_ASC',
  RestrictionsDesc = 'RESTRICTIONS_DESC',
  ReviewLevelAsc = 'REVIEW_LEVEL_ASC',
  ReviewLevelDesc = 'REVIEW_LEVEL_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplatePermissionIdAsc = 'TEMPLATE_PERMISSION_ID_ASC',
  TemplatePermissionIdDesc = 'TEMPLATE_PERMISSION_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

export type PostgresRowLevel = {
  __typename?: 'PostgresRowLevel';
  cmd?: Maybe<Scalars['String']['output']>;
  permissive?: Maybe<Scalars['String']['output']>;
  policyname?: Maybe<Scalars['String']['output']>;
  qual?: Maybe<Scalars['String']['output']>;
  roles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  schemaname?: Maybe<Scalars['String']['output']>;
  tablename?: Maybe<Scalars['String']['output']>;
  withCheck?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `PostgresRowLevel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PostgresRowLevelCondition = {
  /** Checks for equality with the object’s `cmd` field. */
  cmd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissive` field. */
  permissive?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `policyname` field. */
  policyname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `qual` field. */
  qual?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roles` field. */
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `schemaname` field. */
  schemaname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tablename` field. */
  tablename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `withCheck` field. */
  withCheck?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PostgresRowLevel` object types. All fields are combined with a logical ‘and.’ */
export type PostgresRowLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PostgresRowLevelFilter>>;
  /** Filter by the object’s `cmd` field. */
  cmd?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PostgresRowLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PostgresRowLevelFilter>>;
  /** Filter by the object’s `permissive` field. */
  permissive?: InputMaybe<StringFilter>;
  /** Filter by the object’s `policyname` field. */
  policyname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `qual` field. */
  qual?: InputMaybe<StringFilter>;
  /** Filter by the object’s `roles` field. */
  roles?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `schemaname` field. */
  schemaname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tablename` field. */
  tablename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `withCheck` field. */
  withCheck?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PostgresRowLevel` values. */
export type PostgresRowLevelsConnection = {
  __typename?: 'PostgresRowLevelsConnection';
  /** A list of edges which contains the `PostgresRowLevel` and cursor to aid in pagination. */
  edges: Array<PostgresRowLevelsEdge>;
  /** A list of `PostgresRowLevel` objects. */
  nodes: Array<Maybe<PostgresRowLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostgresRowLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PostgresRowLevel` edge in the connection. */
export type PostgresRowLevelsEdge = {
  __typename?: 'PostgresRowLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PostgresRowLevel` at the end of the edge. */
  node?: Maybe<PostgresRowLevel>;
};

/** Methods to use when ordering `PostgresRowLevel`. */
export enum PostgresRowLevelsOrderBy {
  CmdAsc = 'CMD_ASC',
  CmdDesc = 'CMD_DESC',
  Natural = 'NATURAL',
  PermissiveAsc = 'PERMISSIVE_ASC',
  PermissiveDesc = 'PERMISSIVE_DESC',
  PolicynameAsc = 'POLICYNAME_ASC',
  PolicynameDesc = 'POLICYNAME_DESC',
  QualAsc = 'QUAL_ASC',
  QualDesc = 'QUAL_DESC',
  RolesAsc = 'ROLES_ASC',
  RolesDesc = 'ROLES_DESC',
  SchemanameAsc = 'SCHEMANAME_ASC',
  SchemanameDesc = 'SCHEMANAME_DESC',
  TablenameAsc = 'TABLENAME_ASC',
  TablenameDesc = 'TABLENAME_DESC',
  WithCheckAsc = 'WITH_CHECK_ASC',
  WithCheckDesc = 'WITH_CHECK_DESC'
}

export type ProductApplicationJoin = Node & {
  __typename?: 'ProductApplicationJoin';
  /** Reads a single `Application` that is related to this `ProductApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  productId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type ProductApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ProductApplicationJoinInput` mutation. */
export type ProductApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ProductApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `productApplicationJoin` in the `ApplicationInput` mutation. */
export type ProductApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `productApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ProductApplicationJoinProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `productApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ProductApplicationJoinNodeIdConnect>>;
  /** A `ProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ProductApplicationJoinApplicationIdFkeyProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `productApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ProductApplicationJoinProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `productApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `productApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `productApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `productApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `productApplicationJoin` to be created by this mutation. */
export type ProductApplicationJoinApplicationIdFkeyProductApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  productId: Scalars['Int']['input'];
};

/** A condition to be used against `ProductApplicationJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ProductApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ProductApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProductApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProductApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProductApplicationJoinFilter>>;
  /** Filter by the object’s `productId` field. */
  productId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ProductApplicationJoin` */
export type ProductApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  productId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ProductApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `productApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ProductApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `productApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `productApplicationJoin` to look up the row to update. */
export type ProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyUsingProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `productApplicationJoin` being updated. */
  patch: UpdateProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch;
};

/** Represents an update to a `ProductApplicationJoin`. Fields that are set will be updated. */
export type ProductApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  productId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `productApplicationJoin` to look up the row to connect. */
export type ProductApplicationJoinProductApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `productApplicationJoin` to look up the row to delete. */
export type ProductApplicationJoinProductApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `ProductApplicationJoin` values. */
export type ProductApplicationJoinsConnection = {
  __typename?: 'ProductApplicationJoinsConnection';
  /** A list of edges which contains the `ProductApplicationJoin` and cursor to aid in pagination. */
  edges: Array<ProductApplicationJoinsEdge>;
  /** A list of `ProductApplicationJoin` objects. */
  nodes: Array<Maybe<ProductApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ProductApplicationJoin` edge in the connection. */
export type ProductApplicationJoinsEdge = {
  __typename?: 'ProductApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ProductApplicationJoin` at the end of the edge. */
  node?: Maybe<ProductApplicationJoin>;
};

/** Methods to use when ordering `ProductApplicationJoin`. */
export enum ProductApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  actionPlugin?: Maybe<ActionPlugin>;
  actionPluginByCode?: Maybe<ActionPlugin>;
  /** Reads a single `ActionPlugin` using its globally unique `ID`. */
  actionPluginByNodeId?: Maybe<ActionPlugin>;
  /** Reads and enables pagination through a set of `ActionPlugin`. */
  actionPlugins?: Maybe<ActionPluginsConnection>;
  actionQueue?: Maybe<ActionQueue>;
  /** Reads a single `ActionQueue` using its globally unique `ID`. */
  actionQueueByNodeId?: Maybe<ActionQueue>;
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues?: Maybe<ActionQueuesConnection>;
  activityLog?: Maybe<ActivityLog>;
  /** Reads a single `ActivityLog` using its globally unique `ID`. */
  activityLogByNodeId?: Maybe<ActivityLog>;
  /** Reads and enables pagination through a set of `ActivityLog`. */
  activityLogs?: Maybe<ActivityLogsConnection>;
  application?: Maybe<Application>;
  /** Reads a single `Application` using its globally unique `ID`. */
  applicationByNodeId?: Maybe<Application>;
  applicationByOutcomeRegistration?: Maybe<Application>;
  applicationBySerial?: Maybe<Application>;
  /** Reads and enables pagination through a set of `ApplicationListShape`. */
  applicationList?: Maybe<ApplicationListShapesConnection>;
  applicationListFilterApplicant?: Maybe<ApplicationListFilterApplicantConnection>;
  applicationListFilterAssigner?: Maybe<ApplicationListFilterAssignerConnection>;
  applicationListFilterOrganisation?: Maybe<ApplicationListFilterOrganisationConnection>;
  applicationListFilterReviewer?: Maybe<ApplicationListFilterReviewerConnection>;
  applicationListFilterStage?: Maybe<ApplicationListFilterStageConnection>;
  /** Reads and enables pagination through a set of `ApplicationListShape`. */
  applicationListShapes?: Maybe<ApplicationListShapesConnection>;
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationNote` using its globally unique `ID`. */
  applicationNoteByNodeId?: Maybe<ApplicationNote>;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotes?: Maybe<ApplicationNotesConnection>;
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ApplicationResponse` using its globally unique `ID`. */
  applicationResponseByNodeId?: Maybe<ApplicationResponse>;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses?: Maybe<ApplicationResponsesConnection>;
  /** Reads and enables pagination through a set of `Application`. */
  applications?: Maybe<ApplicationsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories?: Maybe<ApplicationStageHistoriesConnection>;
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** Reads a single `ApplicationStageHistory` using its globally unique `ID`. */
  applicationStageHistoryByNodeId?: Maybe<ApplicationStageHistory>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusAll`. */
  applicationStageStatusAlls?: Maybe<ApplicationStageStatusAllsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusLatest`. */
  applicationStageStatusLatests?: Maybe<ApplicationStageStatusLatestsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories?: Maybe<ApplicationStatusHistoriesConnection>;
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  applicationStatusHistoryApplicationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ApplicationStatusHistory` using its globally unique `ID`. */
  applicationStatusHistoryByNodeId?: Maybe<ApplicationStatusHistory>;
  assignableQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  assignedQuestions?: Maybe<AssignedQuestionsConnection>;
  assignedQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `AssignedSectionsByStageAndLevel`. */
  assignedSectionsByStageAndLevels?: Maybe<AssignedSectionsByStageAndLevelsConnection>;
  assignerList?: Maybe<AssignerListConnection>;
  assignmentList?: Maybe<AssignmentListConnection>;
  /** Reads and enables pagination through a set of `ConstraintsInfo`. */
  constraintsInfos?: Maybe<ConstraintsInfosConnection>;
  counter?: Maybe<Counter>;
  counterByName?: Maybe<Counter>;
  /** Reads a single `Counter` using its globally unique `ID`. */
  counterByNodeId?: Maybe<Counter>;
  /** Reads and enables pagination through a set of `Counter`. */
  counters?: Maybe<CountersConnection>;
  dataTable?: Maybe<DataTable>;
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** Reads a single `DataTableActiveIngredient` using its globally unique `ID`. */
  dataTableActiveIngredientByNodeId?: Maybe<DataTableActiveIngredient>;
  /** Reads and enables pagination through a set of `DataTableActiveIngredient`. */
  dataTableActiveIngredients?: Maybe<DataTableActiveIngredientsConnection>;
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** Reads a single `DataTableAdministrationRoute` using its globally unique `ID`. */
  dataTableAdministrationRouteByNodeId?: Maybe<DataTableAdministrationRoute>;
  /** Reads and enables pagination through a set of `DataTableAdministrationRoute`. */
  dataTableAdministrationRoutes?: Maybe<DataTableAdministrationRoutesConnection>;
  dataTableAnnex?: Maybe<DataTableAnnex>;
  dataTableAnnex2?: Maybe<DataTableAnnex2>;
  /** Reads a single `DataTableAnnex2` using its globally unique `ID`. */
  dataTableAnnex2ByNodeId?: Maybe<DataTableAnnex2>;
  /** Reads and enables pagination through a set of `DataTableAnnex2`. */
  dataTableAnnex2s?: Maybe<DataTableAnnex2sConnection>;
  /** Reads a single `DataTableAnnex` using its globally unique `ID`. */
  dataTableAnnexByNodeId?: Maybe<DataTableAnnex>;
  /** Reads and enables pagination through a set of `DataTableAnnex`. */
  dataTableAnnexes?: Maybe<DataTableAnnexesConnection>;
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** Reads a single `DataTableAtcCode` using its globally unique `ID`. */
  dataTableAtcCodeByNodeId?: Maybe<DataTableAtcCode>;
  /** Reads and enables pagination through a set of `DataTableAtcCode`. */
  dataTableAtcCodes?: Maybe<DataTableAtcCodesConnection>;
  /** Reads and enables pagination through a set of `DataTableAtcTherapeuticCategory`. */
  dataTableAtcTherapeuticCategories?: Maybe<DataTableAtcTherapeuticCategoriesConnection>;
  dataTableAtcTherapeuticCategory?: Maybe<DataTableAtcTherapeuticCategory>;
  /** Reads a single `DataTableAtcTherapeuticCategory` using its globally unique `ID`. */
  dataTableAtcTherapeuticCategoryByNodeId?: Maybe<DataTableAtcTherapeuticCategory>;
  /** Reads a single `DataTable` using its globally unique `ID`. */
  dataTableByNodeId?: Maybe<DataTable>;
  dataTableByTableName?: Maybe<DataTable>;
  dataTableContainer?: Maybe<DataTableContainer>;
  /** Reads a single `DataTableContainer` using its globally unique `ID`. */
  dataTableContainerByNodeId?: Maybe<DataTableContainer>;
  /** Reads and enables pagination through a set of `DataTableContainer`. */
  dataTableContainers?: Maybe<DataTableContainersConnection>;
  /** Reads and enables pagination through a set of `DataTableCountry`. */
  dataTableCountries?: Maybe<DataTableCountriesConnection>;
  dataTableCountry?: Maybe<DataTableCountry>;
  /** Reads a single `DataTableCountry` using its globally unique `ID`. */
  dataTableCountryByNodeId?: Maybe<DataTableCountry>;
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** Reads a single `DataTableDosageForm` using its globally unique `ID`. */
  dataTableDosageFormByNodeId?: Maybe<DataTableDosageForm>;
  /** Reads and enables pagination through a set of `DataTableDosageForm`. */
  dataTableDosageForms?: Maybe<DataTableDosageFormsConnection>;
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** Reads a single `DataTableGenericIngredient` using its globally unique `ID`. */
  dataTableGenericIngredientByNodeId?: Maybe<DataTableGenericIngredient>;
  /** Reads and enables pagination through a set of `DataTableGenericIngredient`. */
  dataTableGenericIngredients?: Maybe<DataTableGenericIngredientsConnection>;
  dataTableIngredientsList?: Maybe<DataTableIngredientsList>;
  /** Reads a single `DataTableIngredientsList` using its globally unique `ID`. */
  dataTableIngredientsListByNodeId?: Maybe<DataTableIngredientsList>;
  /** Reads and enables pagination through a set of `DataTableIngredientsList`. */
  dataTableIngredientsLists?: Maybe<DataTableIngredientsListsConnection>;
  dataTableListOfSra?: Maybe<DataTableListOfSra>;
  /** Reads a single `DataTableListOfSra` using its globally unique `ID`. */
  dataTableListOfSraByNodeId?: Maybe<DataTableListOfSra>;
  /** Reads and enables pagination through a set of `DataTableListOfSra`. */
  dataTableListOfSras?: Maybe<DataTableListOfSrasConnection>;
  dataTableManufacturingStep?: Maybe<DataTableManufacturingStep>;
  /** Reads a single `DataTableManufacturingStep` using its globally unique `ID`. */
  dataTableManufacturingStepByNodeId?: Maybe<DataTableManufacturingStep>;
  /** Reads and enables pagination through a set of `DataTableManufacturingStep`. */
  dataTableManufacturingSteps?: Maybe<DataTableManufacturingStepsConnection>;
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** Reads a single `DataTableProcessingStep` using its globally unique `ID`. */
  dataTableProcessingStepByNodeId?: Maybe<DataTableProcessingStep>;
  /** Reads and enables pagination through a set of `DataTableProcessingStep`. */
  dataTableProcessingSteps?: Maybe<DataTableProcessingStepsConnection>;
  dataTableProduct?: Maybe<DataTableProduct>;
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** Reads a single `DataTableProductApplicationJoin` using its globally unique `ID`. */
  dataTableProductApplicationJoinByNodeId?: Maybe<DataTableProductApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTableProductApplicationJoin`. */
  dataTableProductApplicationJoins?: Maybe<DataTableProductApplicationJoinsConnection>;
  /** Reads a single `DataTableProduct` using its globally unique `ID`. */
  dataTableProductByNodeId?: Maybe<DataTableProduct>;
  /** Reads and enables pagination through a set of `DataTableProduct`. */
  dataTableProducts?: Maybe<DataTableProductsConnection>;
  dataTableProvince?: Maybe<DataTableProvince>;
  /** Reads a single `DataTableProvince` using its globally unique `ID`. */
  dataTableProvinceByNodeId?: Maybe<DataTableProvince>;
  /** Reads and enables pagination through a set of `DataTableProvince`. */
  dataTableProvinces?: Maybe<DataTableProvincesConnection>;
  /** Reads and enables pagination through a set of `DataTable`. */
  dataTables?: Maybe<DataTablesConnection>;
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** Reads a single `DataTableStorageCondition` using its globally unique `ID`. */
  dataTableStorageConditionByNodeId?: Maybe<DataTableStorageCondition>;
  /** Reads and enables pagination through a set of `DataTableStorageCondition`. */
  dataTableStorageConditions?: Maybe<DataTableStorageConditionsConnection>;
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** Reads a single `DataTableUnitsOfProportion` using its globally unique `ID`. */
  dataTableUnitsOfProportionByNodeId?: Maybe<DataTableUnitsOfProportion>;
  /** Reads and enables pagination through a set of `DataTableUnitsOfProportion`. */
  dataTableUnitsOfProportions?: Maybe<DataTableUnitsOfProportionsConnection>;
  dataView?: Maybe<DataView>;
  dataViewByIdentifier?: Maybe<DataView>;
  /** Reads a single `DataView` using its globally unique `ID`. */
  dataViewByNodeId?: Maybe<DataView>;
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** Reads a single `DataViewColumnDefinition` using its globally unique `ID`. */
  dataViewColumnDefinitionByNodeId?: Maybe<DataViewColumnDefinition>;
  dataViewColumnDefinitionByTableNameAndColumnName?: Maybe<DataViewColumnDefinition>;
  /** Reads and enables pagination through a set of `DataViewColumnDefinition`. */
  dataViewColumnDefinitions?: Maybe<DataViewColumnDefinitionsConnection>;
  /** Reads and enables pagination through a set of `DataView`. */
  dataViews?: Maybe<DataViewsConnection>;
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** Reads a single `ElementTypePlugin` using its globally unique `ID`. */
  elementTypePluginByNodeId?: Maybe<ElementTypePlugin>;
  /** Reads and enables pagination through a set of `ElementTypePlugin`. */
  elementTypePlugins?: Maybe<ElementTypePluginsConnection>;
  file?: Maybe<File>;
  /** Reads a single `File` using its globally unique `ID`. */
  fileByNodeId?: Maybe<File>;
  fileByUniqueId?: Maybe<File>;
  /** Reads and enables pagination through a set of `File`. */
  files?: Maybe<FilesConnection>;
  filter?: Maybe<Filter>;
  filterByCode?: Maybe<Filter>;
  /** Reads a single `Filter` using its globally unique `ID`. */
  filterByNodeId?: Maybe<Filter>;
  /** Reads and enables pagination through a set of `Filter`. */
  filters?: Maybe<FiltersConnection>;
  getTemplateCode?: Maybe<Scalars['String']['output']>;
  getTemplateVersion?: Maybe<Scalars['String']['output']>;
  jwtGetBigint?: Maybe<Scalars['BigInt']['output']>;
  jwtGetBoolean?: Maybe<Scalars['Boolean']['output']>;
  jwtGetText?: Maybe<Scalars['String']['output']>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  notification?: Maybe<Notification>;
  /** Reads a single `Notification` using its globally unique `ID`. */
  notificationByNodeId?: Maybe<Notification>;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications?: Maybe<NotificationsConnection>;
  organisation?: Maybe<Organisation>;
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** Reads a single `OrganisationApplicationJoin` using its globally unique `ID`. */
  organisationApplicationJoinByNodeId?: Maybe<OrganisationApplicationJoin>;
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins?: Maybe<OrganisationApplicationJoinsConnection>;
  organisationByName?: Maybe<Organisation>;
  /** Reads a single `Organisation` using its globally unique `ID`. */
  organisationByNodeId?: Maybe<Organisation>;
  organisationByRegistration?: Maybe<Organisation>;
  /** Reads and enables pagination through a set of `Organisation`. */
  organisations?: Maybe<OrganisationsConnection>;
  permissionJoin?: Maybe<PermissionJoin>;
  /** Reads a single `PermissionJoin` using its globally unique `ID`. */
  permissionJoinByNodeId?: Maybe<PermissionJoin>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins?: Maybe<PermissionJoinsConnection>;
  permissionName?: Maybe<PermissionName>;
  permissionNameByName?: Maybe<PermissionName>;
  /** Reads a single `PermissionName` using its globally unique `ID`. */
  permissionNameByNodeId?: Maybe<PermissionName>;
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames?: Maybe<PermissionNamesConnection>;
  /** Reads and enables pagination through a set of `PermissionPolicy`. */
  permissionPolicies?: Maybe<PermissionPoliciesConnection>;
  permissionPolicy?: Maybe<PermissionPolicy>;
  permissionPolicyByName?: Maybe<PermissionPolicy>;
  /** Reads a single `PermissionPolicy` using its globally unique `ID`. */
  permissionPolicyByNodeId?: Maybe<PermissionPolicy>;
  /** Reads and enables pagination through a set of `PermissionsAll`. */
  permissionsAlls?: Maybe<PermissionsAllsConnection>;
  /** Reads and enables pagination through a set of `PostgresRowLevel`. */
  postgresRowLevels?: Maybe<PostgresRowLevelsConnection>;
  productApplicationJoin?: Maybe<ProductApplicationJoin>;
  /** Reads a single `ProductApplicationJoin` using its globally unique `ID`. */
  productApplicationJoinByNodeId?: Maybe<ProductApplicationJoin>;
  /** Reads and enables pagination through a set of `ProductApplicationJoin`. */
  productApplicationJoins?: Maybe<ProductApplicationJoinsConnection>;
  /** Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form. */
  query: Query;
  review?: Maybe<Review>;
  reviewableQuestions?: Maybe<ReviewableQuestionsConnection>;
  reviewableQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  reviewApplicationId?: Maybe<Scalars['Int']['output']>;
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** Reads a single `ReviewAssignmentAssignerJoin` using its globally unique `ID`. */
  reviewAssignmentAssignerJoinByNodeId?: Maybe<ReviewAssignmentAssignerJoin>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins?: Maybe<ReviewAssignmentAssignerJoinsConnection>;
  /** Reads a single `ReviewAssignment` using its globally unique `ID`. */
  reviewAssignmentByNodeId?: Maybe<ReviewAssignment>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments?: Maybe<ReviewAssignmentsConnection>;
  reviewAssignmentTemplateId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Review` using its globally unique `ID`. */
  reviewByNodeId?: Maybe<Review>;
  reviewByReviewAssignmentId?: Maybe<Review>;
  reviewDecision?: Maybe<ReviewDecision>;
  /** Reads a single `ReviewDecision` using its globally unique `ID`. */
  reviewDecisionByNodeId?: Maybe<ReviewDecision>;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions?: Maybe<ReviewDecisionsConnection>;
  reviewIsFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  reviewIsLastLevel?: Maybe<Scalars['Boolean']['output']>;
  reviewIsLastStage?: Maybe<Scalars['Boolean']['output']>;
  reviewLevel?: Maybe<Scalars['Int']['output']>;
  reviewList?: Maybe<ReviewListConnection>;
  reviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` using its globally unique `ID`. */
  reviewResponseByNodeId?: Maybe<ReviewResponse>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses?: Maybe<ReviewResponsesConnection>;
  reviewResponseStageNumber?: Maybe<Scalars['Int']['output']>;
  reviewReviewerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Review`. */
  reviews?: Maybe<ReviewsConnection>;
  reviewStage?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories?: Maybe<ReviewStatusHistoriesConnection>;
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** Reads a single `ReviewStatusHistory` using its globally unique `ID`. */
  reviewStatusHistoryByNodeId?: Maybe<ReviewStatusHistory>;
  reviewTimeStageCreated?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `SchemaColumn`. */
  schemaColumns?: Maybe<SchemaColumnsConnection>;
  submittedAssignedQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  systemInfo?: Maybe<SystemInfo>;
  /** Reads a single `SystemInfo` using its globally unique `ID`. */
  systemInfoByNodeId?: Maybe<SystemInfo>;
  /** Reads and enables pagination through a set of `SystemInfo`. */
  systemInfos?: Maybe<SystemInfosConnection>;
  template?: Maybe<Template>;
  templateAction?: Maybe<TemplateAction>;
  /** Reads a single `TemplateAction` using its globally unique `ID`. */
  templateActionByNodeId?: Maybe<TemplateAction>;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions?: Maybe<TemplateActionsConnection>;
  templateByCodeAndVersionId?: Maybe<Template>;
  /** Reads a single `Template` using its globally unique `ID`. */
  templateByNodeId?: Maybe<Template>;
  /** Reads and enables pagination through a set of `TemplateCategory`. */
  templateCategories?: Maybe<TemplateCategoriesConnection>;
  templateCategory?: Maybe<TemplateCategory>;
  templateCategoryByCode?: Maybe<TemplateCategory>;
  /** Reads a single `TemplateCategory` using its globally unique `ID`. */
  templateCategoryByNodeId?: Maybe<TemplateCategory>;
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `TemplateElement` using its globally unique `ID`. */
  templateElementByNodeId?: Maybe<TemplateElement>;
  templateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<TemplateElement>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElements?: Maybe<TemplateElementsConnection>;
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** Reads a single `TemplateFilterJoin` using its globally unique `ID`. */
  templateFilterJoinByNodeId?: Maybe<TemplateFilterJoin>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins?: Maybe<TemplateFilterJoinsConnection>;
  templatePermission?: Maybe<TemplatePermission>;
  /** Reads a single `TemplatePermission` using its globally unique `ID`. */
  templatePermissionByNodeId?: Maybe<TemplatePermission>;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions?: Maybe<TemplatePermissionsConnection>;
  /** Reads and enables pagination through a set of `Template`. */
  templates?: Maybe<TemplatesConnection>;
  templateSection?: Maybe<TemplateSection>;
  /** Reads a single `TemplateSection` using its globally unique `ID`. */
  templateSectionByNodeId?: Maybe<TemplateSection>;
  templateSectionByTemplateIdAndCode?: Maybe<TemplateSection>;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections?: Maybe<TemplateSectionsConnection>;
  templateStage?: Maybe<TemplateStage>;
  /** Reads a single `TemplateStage` using its globally unique `ID`. */
  templateStageByNodeId?: Maybe<TemplateStage>;
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `TemplateStageReviewLevel` using its globally unique `ID`. */
  templateStageReviewLevelByNodeId?: Maybe<TemplateStageReviewLevel>;
  /** Reads and enables pagination through a set of `TemplateStageReviewLevel`. */
  templateStageReviewLevels?: Maybe<TemplateStageReviewLevelsConnection>;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages?: Maybe<TemplateStagesConnection>;
  triggerQueue?: Maybe<TriggerQueue>;
  /** Reads a single `TriggerQueue` using its globally unique `ID`. */
  triggerQueueByNodeId?: Maybe<TriggerQueue>;
  /** Reads and enables pagination through a set of `TriggerQueue`. */
  triggerQueues?: Maybe<TriggerQueuesConnection>;
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** Reads a single `TriggerSchedule` using its globally unique `ID`. */
  triggerScheduleByNodeId?: Maybe<TriggerSchedule>;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules?: Maybe<TriggerSchedulesConnection>;
  /** Reads and enables pagination through a set of `UnnestedSection`. */
  unnestedSections?: Maybe<UnnestedSectionsConnection>;
  user?: Maybe<User>;
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** Reads a single `UserApplicationJoin` using its globally unique `ID`. */
  userApplicationJoinByNodeId?: Maybe<UserApplicationJoin>;
  /** Reads and enables pagination through a set of `UserApplicationJoin`. */
  userApplicationJoins?: Maybe<UserApplicationJoinsConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  userByUsername?: Maybe<User>;
  userOrganisation?: Maybe<UserOrganisation>;
  userOrganisationApplicationJoin?: Maybe<UserOrganisationApplicationJoin>;
  /** Reads a single `UserOrganisationApplicationJoin` using its globally unique `ID`. */
  userOrganisationApplicationJoinByNodeId?: Maybe<UserOrganisationApplicationJoin>;
  /** Reads and enables pagination through a set of `UserOrganisationApplicationJoin`. */
  userOrganisationApplicationJoins?: Maybe<UserOrganisationApplicationJoinsConnection>;
  /** Reads a single `UserOrganisation` using its globally unique `ID`. */
  userOrganisationByNodeId?: Maybe<UserOrganisation>;
  userOrganisationByUserIdAndOrganisationId?: Maybe<UserOrganisation>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations?: Maybe<UserOrganisationsConnection>;
  /** Reads and enables pagination through a set of `UserOrgJoin`. */
  userOrgJoins?: Maybe<UserOrgJoinsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  verification?: Maybe<Verification>;
  /** Reads a single `Verification` using its globally unique `ID`. */
  verificationByNodeId?: Maybe<Verification>;
  verificationByUniqueId?: Maybe<Verification>;
  /** Reads and enables pagination through a set of `Verification`. */
  verifications?: Maybe<VerificationsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionPluginCondition>;
  filter?: InputMaybe<ActionPluginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActivityLogCondition>;
  filter?: InputMaybe<ActivityLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByOutcomeRegistrationArgs = {
  outcomeRegistration: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationBySerialArgs = {
  serial: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ApplicationListShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
  userid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterApplicantArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  applicant?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterAssignerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  assigner?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterOrganisationArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  organisation?: InputMaybe<Scalars['String']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterReviewerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  reviewer?: InputMaybe<Scalars['String']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterStageArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListShapesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationListShapeCondition>;
  filter?: InputMaybe<ApplicationListShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNoteArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNoteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusAllsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageStatusAllCondition>;
  filter?: InputMaybe<ApplicationStageStatusAllFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageStatusAllsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusLatestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageStatusLatestCondition>;
  filter?: InputMaybe<ApplicationStageStatusLatestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageStatusLatestsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStatusHistoryCondition>;
  filter?: InputMaybe<ApplicationStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryApplicationIdArgs = {
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignableQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignedQuestionsRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedSectionsByStageAndLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssignedSectionsByStageAndLevelCondition>;
  filter?: InputMaybe<AssignedSectionsByStageAndLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssignedSectionsByStageAndLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignerListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignerListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignmentListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignmentListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryConstraintsInfosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConstraintsInfoCondition>;
  filter?: InputMaybe<ConstraintsInfoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConstraintsInfosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CounterCondition>;
  filter?: InputMaybe<CounterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableActiveIngredientCondition>;
  filter?: InputMaybe<DataTableActiveIngredientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRouteArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRouteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRoutesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAdministrationRouteCondition>;
  filter?: InputMaybe<DataTableAdministrationRouteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnexArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnex2Args = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnex2ByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnex2sArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAnnex2Condition>;
  filter?: InputMaybe<DataTableAnnex2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAnnex2sOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnexByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAnnexesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAnnexCondition>;
  filter?: InputMaybe<DataTableAnnexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAnnexesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodeArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAtcCodeCondition>;
  filter?: InputMaybe<DataTableAtcCodeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcTherapeuticCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAtcTherapeuticCategoryCondition>;
  filter?: InputMaybe<DataTableAtcTherapeuticCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAtcTherapeuticCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcTherapeuticCategoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcTherapeuticCategoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableByTableNameArgs = {
  tableName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainerArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableContainerCondition>;
  filter?: InputMaybe<DataTableContainerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableCountryCondition>;
  filter?: InputMaybe<DataTableCountryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableDosageFormCondition>;
  filter?: InputMaybe<DataTableDosageFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableGenericIngredientCondition>;
  filter?: InputMaybe<DataTableGenericIngredientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableIngredientsListArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableIngredientsListByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableIngredientsListsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableIngredientsListCondition>;
  filter?: InputMaybe<DataTableIngredientsListFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableIngredientsListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableListOfSraArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableListOfSraByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableListOfSrasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableListOfSraCondition>;
  filter?: InputMaybe<DataTableListOfSraFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableListOfSrasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturingStepArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturingStepByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturingStepsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturingStepCondition>;
  filter?: InputMaybe<DataTableManufacturingStepFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturingStepsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProcessingStepCondition>;
  filter?: InputMaybe<DataTableProcessingStepFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductCondition>;
  filter?: InputMaybe<DataTableProductFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvinceArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvinceByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvincesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProvinceCondition>;
  filter?: InputMaybe<DataTableProvinceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProvincesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableCondition>;
  filter?: InputMaybe<DataTableFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableStorageConditionCondition>;
  filter?: InputMaybe<DataTableStorageConditionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableUnitsOfProportionCondition>;
  filter?: InputMaybe<DataTableUnitsOfProportionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewByIdentifierArgs = {
  identifier: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  columnName: Scalars['String']['input'];
  tableName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataViewColumnDefinitionCondition>;
  filter?: InputMaybe<DataViewColumnDefinitionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataViewCondition>;
  filter?: InputMaybe<DataViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ElementTypePluginCondition>;
  filter?: InputMaybe<ElementTypePluginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByUniqueIdArgs = {
  uniqueId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFiltersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FilterCondition>;
  filter?: InputMaybe<FilterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTemplateCodeArgs = {
  sectionId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTemplateVersionArgs = {
  sectionId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBigintArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBooleanArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetTextArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByRegistrationArgs = {
  registration: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationCondition>;
  filter?: InputMaybe<OrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionNameCondition>;
  filter?: InputMaybe<PermissionNameFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPoliciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionPolicyCondition>;
  filter?: InputMaybe<PermissionPolicyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsAllsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionsAllCondition>;
  filter?: InputMaybe<PermissionsAllFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsAllsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostgresRowLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PostgresRowLevelCondition>;
  filter?: InputMaybe<PostgresRowLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PostgresRowLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryProductApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProductApplicationJoinCondition>;
  filter?: InputMaybe<ProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProductApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewableQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ReviewableQuestionsRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewableQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewApplicationIdArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentTemplateIdArgs = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewByReviewAssignmentIdArgs = {
  reviewAssignmentId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewDecisionCondition>;
  filter?: InputMaybe<ReviewDecisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewIsFinalDecisionArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewIsLastLevelArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewIsLastStageArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewLevelArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appstatus?: InputMaybe<ApplicationStatus>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ReviewListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  reviewerid?: InputMaybe<Scalars['Int']['input']>;
  stageid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseStageNumberArgs = {
  reviewId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewReviewerIdArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStageArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewStatusHistoryCondition>;
  filter?: InputMaybe<ReviewStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewTimeStageCreatedArgs = {
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchemaColumnsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchemaColumnCondition>;
  filter?: InputMaybe<SchemaColumnFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchemaColumnsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySubmittedAssignedQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfoArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfoByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SystemInfoCondition>;
  filter?: InputMaybe<SystemInfoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateActionCondition>;
  filter?: InputMaybe<TemplateActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateByCodeAndVersionIdArgs = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCategoryCondition>;
  filter?: InputMaybe<TemplateCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateElementCondition>;
  filter?: InputMaybe<TemplateElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCondition>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionByTemplateIdAndCodeArgs = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateSectionCondition>;
  filter?: InputMaybe<TemplateSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageReviewLevelCondition>;
  filter?: InputMaybe<TemplateStageReviewLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageCondition>;
  filter?: InputMaybe<TemplateStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerQueueCondition>;
  filter?: InputMaybe<TriggerQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerScheduleArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerScheduleByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUnnestedSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UnnestedSectionCondition>;
  filter?: InputMaybe<UnnestedSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UnnestedSectionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserApplicationJoinCondition>;
  filter?: InputMaybe<UserApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationApplicationJoinCondition>;
  filter?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationByUserIdAndOrganisationIdArgs = {
  organisationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrgJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrgJoinCondition>;
  filter?: InputMaybe<UserOrgJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrgJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationByUniqueIdArgs = {
  uniqueId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationCondition>;
  filter?: InputMaybe<VerificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type Review = Node & {
  __typename?: 'Review';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  isFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  isLastLevel?: Maybe<Scalars['Boolean']['output']>;
  isLastStage?: Maybe<Scalars['Boolean']['output']>;
  isLocked?: Maybe<Scalars['Boolean']['output']>;
  latestDecision?: Maybe<ReviewDecision>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions: ReviewDecisionsConnection;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
  reviewerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories: ReviewStatusHistoriesConnection;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ReviewStatus>;
  timeStageCreated?: Maybe<Scalars['Datetime']['output']>;
  timeStatusCreated?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
};


export type ReviewNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


export type ReviewReviewDecisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewDecisionCondition>;
  filter?: InputMaybe<ReviewDecisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};


export type ReviewReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


export type ReviewReviewStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewStatusHistoryCondition>;
  filter?: InputMaybe<ReviewStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

export enum Reviewability {
  Always = 'ALWAYS',
  Never = 'NEVER',
  OnlyIfApplicantAnswer = 'ONLY_IF_APPLICANT_ANSWER',
  OptionalIfNoResponse = 'OPTIONAL_IF_NO_RESPONSE'
}

/** A filter to be used against Reviewability fields. All fields are combined with a logical ‘and.’ */
export type ReviewabilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Reviewability>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Reviewability>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Reviewability>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Reviewability>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Reviewability>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Reviewability>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Reviewability>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Reviewability>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Reviewability>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Reviewability>>;
};

/** A `ReviewableQuestionsRecord` edge in the connection. */
export type ReviewableQuestionEdge = {
  __typename?: 'ReviewableQuestionEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewableQuestionsRecord` at the end of the edge. */
  node?: Maybe<ReviewableQuestionsRecord>;
};

/** A connection to a list of `ReviewableQuestionsRecord` values. */
export type ReviewableQuestionsConnection = {
  __typename?: 'ReviewableQuestionsConnection';
  /** A list of edges which contains the `ReviewableQuestionsRecord` and cursor to aid in pagination. */
  edges: Array<ReviewableQuestionEdge>;
  /** A list of `ReviewableQuestionsRecord` objects. */
  nodes: Array<Maybe<ReviewableQuestionsRecord>>;
  /** The count of *all* `ReviewableQuestionsRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The return type of our `reviewableQuestions` query. */
export type ReviewableQuestionsRecord = {
  __typename?: 'ReviewableQuestionsRecord';
  code?: Maybe<Scalars['String']['output']>;
  isOptional?: Maybe<Scalars['Boolean']['output']>;
  responseId?: Maybe<Scalars['Int']['output']>;
  responseValue?: Maybe<Scalars['JSON']['output']>;
  reviewability?: Maybe<Reviewability>;
};

/** A filter to be used against `ReviewableQuestionsRecord` object types. All fields are combined with a logical ‘and.’ */
export type ReviewableQuestionsRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewableQuestionsRecordFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isOptional` field. */
  isOptional?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewableQuestionsRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewableQuestionsRecordFilter>>;
  /** Filter by the object’s `responseId` field. */
  responseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `responseValue` field. */
  responseValue?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewability` field. */
  reviewability?: InputMaybe<ReviewabilityFilter>;
};

/** The `application` to be created by this mutation. */
export type ReviewApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewInput` mutation. */
export type ReviewApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `review` in the `ApplicationInput` mutation. */
export type ReviewApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyConnect>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewApplicationIdFkeyReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyDelete>>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<Array<ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewApplicationIdFkeyReviewCreateInput = {
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

export type ReviewAssignment = Node & {
  __typename?: 'ReviewAssignment';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  assignedSections: Array<Maybe<Scalars['String']['output']>>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  availableSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['Int']['output'];
  isFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  isLastLevel?: Maybe<Scalars['Boolean']['output']>;
  isLastStage?: Maybe<Scalars['Boolean']['output']>;
  isSelfAssignable?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  levelId?: Maybe<Scalars['Int']['output']>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Review` that is related to this `ReviewAssignment`. */
  review?: Maybe<Review>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins: ReviewAssignmentAssignerJoinsConnection;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  reviewerId: Scalars['Int']['output'];
  /**
   * Reads and enables pagination through a set of `Review`.
   * @deprecated Please use review instead
   */
  reviews: ReviewsConnection;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status: ReviewAssignmentStatus;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  timeStageCreated?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
};


export type ReviewAssignmentReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type ReviewAssignmentReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ApplicationInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentAssignerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserInput` mutation. */
export type ReviewAssignmentAssignerIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewAssignmentAssignerIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

export type ReviewAssignmentAssignerJoin = Node & {
  __typename?: 'ReviewAssignmentAssignerJoin';
  /** Reads a single `User` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<User>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewAssignmentId: Scalars['Int']['output'];
};

/** Input for the nested mutation of `user` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type ReviewAssignmentAssignerJoinAssignerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `UserInput` mutation. */
export type ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerJoinAssignerIdFkeyReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinAssignerIdFkeyReviewAssignmentAssignerJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinAssignerIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A condition to be used against `ReviewAssignmentAssignerJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewAssignmentAssignerJoinCondition = {
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentAssignerJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewAssignmentAssignerJoinFilter>>;
  /** Filter by the object’s `assigner` relation. */
  assigner?: InputMaybe<UserFilter>;
  /** A related `assigner` exists. */
  assignerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewAssignmentAssignerJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: InputMaybe<ReviewAssignmentFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReviewAssignmentAssignerJoin` */
export type ReviewAssignmentAssignerJoinInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewAssignmentAssignerJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewAssignmentAssignerJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `OrganisationInput` mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** Represents an update to a `ReviewAssignmentAssignerJoin`. Fields that are set will be updated. */
export type ReviewAssignmentAssignerJoinPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to connect. */
export type ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to delete. */
export type ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `reviewAssignment` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewAssignmentNodeIdConnect>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** A connection to a list of `ReviewAssignmentAssignerJoin` values. */
export type ReviewAssignmentAssignerJoinsConnection = {
  __typename?: 'ReviewAssignmentAssignerJoinsConnection';
  /** A list of edges which contains the `ReviewAssignmentAssignerJoin` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentAssignerJoinsEdge>;
  /** A list of `ReviewAssignmentAssignerJoin` objects. */
  nodes: Array<Maybe<ReviewAssignmentAssignerJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignmentAssignerJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewAssignmentAssignerJoin` edge in the connection. */
export type ReviewAssignmentAssignerJoinsEdge = {
  __typename?: 'ReviewAssignmentAssignerJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewAssignmentAssignerJoin` at the end of the edge. */
  node?: Maybe<ReviewAssignmentAssignerJoin>;
};

/** Methods to use when ordering `ReviewAssignmentAssignerJoin`. */
export enum ReviewAssignmentAssignerJoinsOrderBy {
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC'
}

/** A condition to be used against `ReviewAssignment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewAssignmentCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSelfAssignable` field. */
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `levelId` field. */
  levelId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewAssignmentStatus>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** A filter to be used against `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewAssignmentFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `assigner` relation. */
  assigner?: InputMaybe<UserFilter>;
  /** A related `assigner` exists. */
  assignerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `availableSections` field. */
  availableSections?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSelfAssignable` field. */
  isSelfAssignable?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `level` relation. */
  level?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** A related `level` exists. */
  levelExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `levelId` field. */
  levelId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewAssignmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewAssignmentFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewAssignmentAssignerJoins` relation. */
  reviewAssignmentAssignerJoins?: InputMaybe<ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoins` exist. */
  reviewAssignmentAssignerJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: InputMaybe<UserFilter>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<IntFilter>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewAssignmentStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `ReviewAssignment` */
export type ReviewAssignmentInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** Input for the nested mutation of `templateStageReviewLevel` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentLevelIdFkeyInput = {
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageReviewLevelNodeIdConnect>;
  /** A `TemplateStageReviewLevelInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageReviewLevelNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateStageReviewLevelInput` mutation. */
export type ReviewAssignmentLevelIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `templateStageReviewLevel` to be created by this mutation. */
export type ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewAssignmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewAssignmentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `OrganisationInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** Represents an update to a `ReviewAssignment`. Fields that are set will be updated. */
export type ReviewAssignmentPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The fields on `reviewAssignment` to look up the row to connect. */
export type ReviewAssignmentReviewAssignmentPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewAssignment` to look up the row to delete. */
export type ReviewAssignmentReviewAssignmentPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `user` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentReviewerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentReviewerIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserInput` mutation. */
export type ReviewAssignmentReviewerIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewAssignmentReviewerIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A connection to a list of `ReviewAssignment` values. */
export type ReviewAssignmentsConnection = {
  __typename?: 'ReviewAssignmentsConnection';
  /** A list of edges which contains the `ReviewAssignment` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentsEdge>;
  /** A list of `ReviewAssignment` objects. */
  nodes: Array<Maybe<ReviewAssignment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewAssignment` edge in the connection. */
export type ReviewAssignmentsEdge = {
  __typename?: 'ReviewAssignmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewAssignment` at the end of the edge. */
  node?: Maybe<ReviewAssignment>;
};

/** Methods to use when ordering `ReviewAssignment`. */
export enum ReviewAssignmentsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AssignedSectionsAsc = 'ASSIGNED_SECTIONS_ASC',
  AssignedSectionsDesc = 'ASSIGNED_SECTIONS_DESC',
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsFinalDecisionAsc = 'IS_FINAL_DECISION_ASC',
  IsFinalDecisionDesc = 'IS_FINAL_DECISION_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  IsLastStageAsc = 'IS_LAST_STAGE_ASC',
  IsLastStageDesc = 'IS_LAST_STAGE_DESC',
  IsSelfAssignableAsc = 'IS_SELF_ASSIGNABLE_ASC',
  IsSelfAssignableDesc = 'IS_SELF_ASSIGNABLE_DESC',
  LevelIdAsc = 'LEVEL_ID_ASC',
  LevelIdDesc = 'LEVEL_ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeStageCreatedAsc = 'TIME_STAGE_CREATED_ASC',
  TimeStageCreatedDesc = 'TIME_STAGE_CREATED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

/** Input for the nested mutation of `templateStage` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateStageInput` mutation. */
export type ReviewAssignmentStageIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `templateStage` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum ReviewAssignmentStatus {
  Assigned = 'ASSIGNED',
  Available = 'AVAILABLE'
}

/** A filter to be used against ReviewAssignmentStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewAssignmentStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewAssignmentStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewAssignmentStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewAssignmentStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewAssignmentStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewAssignmentStatus>>;
};

/** Input for the nested mutation of `template` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateInput` mutation. */
export type ReviewAssignmentTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `template` to be created by this mutation. */
export type ReviewAssignmentTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

export type ReviewDecision = Node & {
  __typename?: 'ReviewDecision';
  comment?: Maybe<Scalars['String']['output']>;
  decision?: Maybe<Decision>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  reviewId: Scalars['Int']['output'];
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `ReviewDecision` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewDecisionCondition = {
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: InputMaybe<Decision>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewDecisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewDecisionFilter>>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<DecisionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewDecisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewDecisionFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewDecision` */
export type ReviewDecisionInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewDecisionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewDecisionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewDecision` to look up the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
};

/** Represents an update to a `ReviewDecision`. Fields that are set will be updated. */
export type ReviewDecisionPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewDecision` to look up the row to connect. */
export type ReviewDecisionReviewDecisionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewDecision` to look up the row to delete. */
export type ReviewDecisionReviewDecisionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `review` in the `ReviewDecisionInput` mutation. */
export type ReviewDecisionReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewDecisionReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewDecision` in the `ReviewInput` mutation. */
export type ReviewDecisionReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewDecisionReviewDecisionPkeyConnect>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewDecisionNodeIdConnect>>;
  /** A `ReviewDecisionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewDecisionReviewIdFkeyReviewDecisionCreateInput>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewDecisionReviewDecisionPkeyDelete>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewDecisionNodeIdDelete>>;
  /** Flag indicating whether all other `reviewDecision` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** The `reviewDecision` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewDecisionCreateInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `ReviewDecision` values. */
export type ReviewDecisionsConnection = {
  __typename?: 'ReviewDecisionsConnection';
  /** A list of edges which contains the `ReviewDecision` and cursor to aid in pagination. */
  edges: Array<ReviewDecisionsEdge>;
  /** A list of `ReviewDecision` objects. */
  nodes: Array<Maybe<ReviewDecision>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewDecision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewDecision` edge in the connection. */
export type ReviewDecisionsEdge = {
  __typename?: 'ReviewDecisionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewDecision` at the end of the edge. */
  node?: Maybe<ReviewDecision>;
};

/** Methods to use when ordering `ReviewDecision`. */
export enum ReviewDecisionsOrderBy {
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC'
}

export enum ReviewerAction {
  AwaitingResponse = 'AWAITING_RESPONSE',
  ContinueReview = 'CONTINUE_REVIEW',
  MakeDecision = 'MAKE_DECISION',
  RestartReview = 'RESTART_REVIEW',
  SelfAssign = 'SELF_ASSIGN',
  StartReview = 'START_REVIEW',
  UpdateReview = 'UPDATE_REVIEW',
  ViewReview = 'VIEW_REVIEW'
}

/** A filter to be used against ReviewerAction fields. All fields are combined with a logical ‘and.’ */
export type ReviewerActionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewerAction>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewerAction>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewerAction>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewerAction>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewerAction>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewerAction>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewerAction>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewerAction>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewerAction>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewerAction>>;
};

/** A filter to be used against `Review` object types. All fields are combined with a logical ‘and.’ */
export type ReviewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLocked` field. */
  isLocked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: InputMaybe<ReviewToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewFilter>>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: InputMaybe<ReviewAssignmentFilter>;
  /** A related `reviewAssignment` exists. */
  reviewAssignmentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewDecisions` relation. */
  reviewDecisions?: InputMaybe<ReviewToManyReviewDecisionFilter>;
  /** Some related `reviewDecisions` exist. */
  reviewDecisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: InputMaybe<UserFilter>;
  /** A related `reviewer` exists. */
  reviewerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<ReviewToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewStatusHistories` relation. */
  reviewStatusHistories?: InputMaybe<ReviewToManyReviewStatusHistoryFilter>;
  /** Some related `reviewStatusHistories` exist. */
  reviewStatusHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeStatusCreated` field. */
  timeStatusCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `Review` */
export type ReviewInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** A connection to a list of `ReviewListRecord` values. */
export type ReviewListConnection = {
  __typename?: 'ReviewListConnection';
  /** A list of edges which contains the `ReviewListRecord` and cursor to aid in pagination. */
  edges: Array<ReviewListEdge>;
  /** A list of `ReviewListRecord` objects. */
  nodes: Array<Maybe<ReviewListRecord>>;
  /** The count of *all* `ReviewListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewListRecord` edge in the connection. */
export type ReviewListEdge = {
  __typename?: 'ReviewListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewListRecord` at the end of the edge. */
  node?: Maybe<ReviewListRecord>;
};

/** The return type of our `reviewList` query. */
export type ReviewListRecord = {
  __typename?: 'ReviewListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  reviewerAction?: Maybe<ReviewerAction>;
};

/** A filter to be used against `ReviewListRecord` object types. All fields are combined with a logical ‘and.’ */
export type ReviewListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewListRecordFilter>>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `review` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewerIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewerIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewerIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** Represents an update to a `Review`. Fields that are set will be updated. */
export type ReviewPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

export type ReviewResponse = Node & {
  __typename?: 'ReviewResponse';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  applicationResponseId?: Maybe<Scalars['Int']['output']>;
  comment?: Maybe<Scalars['String']['output']>;
  decision?: Maybe<ReviewResponseDecision>;
  id: Scalars['Int']['output'];
  isLatestReview?: Maybe<Scalars['Boolean']['output']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  originalReviewResponseId?: Maybe<Scalars['Int']['output']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  reviewResponseLinkId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByOriginalReviewResponseId: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByReviewResponseLinkId: ReviewResponsesConnection;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ReviewResponseStatus>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  templateElementId?: Maybe<Scalars['Int']['output']>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeSubmitted?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
};


export type ReviewResponseReviewResponsesByOriginalReviewResponseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


export type ReviewResponseReviewResponsesByReviewResponseLinkIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `applicationResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationResponseNodeIdConnect>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `ApplicationResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput = {
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A condition to be used against `ReviewResponse` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewResponseCondition = {
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecision>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLatestReview` field. */
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewResponseStatus>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

export enum ReviewResponseDecision {
  Agree = 'AGREE',
  Approve = 'APPROVE',
  Decline = 'DECLINE',
  Disagree = 'DISAGREE'
}

/** A filter to be used against ReviewResponseDecision fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseDecisionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseDecision>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseDecision>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseDecision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseDecision>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseDecision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseDecision>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseDecision>>;
};

/** A filter to be used against `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewResponseFilter>>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: InputMaybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecisionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLatestReview` field. */
  isLatestReview?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewResponseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewResponseFilter>>;
  /** Filter by the object’s `originalReviewResponse` relation. */
  originalReviewResponse?: InputMaybe<ReviewResponseFilter>;
  /** A related `originalReviewResponse` exists. */
  originalReviewResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibilityFilter>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponseLink` relation. */
  reviewResponseLink?: InputMaybe<ReviewResponseFilter>;
  /** A related `reviewResponseLink` exists. */
  reviewResponseLinkExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponsesByOriginalReviewResponseId` relation. */
  reviewResponsesByOriginalReviewResponseId?: InputMaybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByOriginalReviewResponseId` exist. */
  reviewResponsesByOriginalReviewResponseIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewResponsesByReviewResponseLinkId` relation. */
  reviewResponsesByReviewResponseLinkId?: InputMaybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByReviewResponseLinkId` exist. */
  reviewResponsesByReviewResponseLinkIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewResponseStatusFilter>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: InputMaybe<TemplateElementFilter>;
  /** A related `templateElement` exists. */
  templateElementExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewResponse` */
export type ReviewResponseInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewResponseNodeIdConnect>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `ReviewResponse`. Fields that are set will be updated. */
export type ReviewResponsePatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

export enum ReviewResponseRecommendedApplicantVisibility {
  OriginalResponseNotVisibleToApplicant = 'ORIGINAL_RESPONSE_NOT_VISIBLE_TO_APPLICANT',
  OriginalResponseVisibleToApplicant = 'ORIGINAL_RESPONSE_VISIBLE_TO_APPLICANT'
}

/** A filter to be used against ReviewResponseRecommendedApplicantVisibility fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseRecommendedApplicantVisibilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
};

/** Input for the nested mutation of `review` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewInput` mutation. */
export type ReviewResponseReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseReviewIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewResponseNodeIdConnect>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewResponse` to look up the row to connect. */
export type ReviewResponseReviewResponsePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewResponse` to look up the row to delete. */
export type ReviewResponseReviewResponsePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `ReviewResponse` values. */
export type ReviewResponsesConnection = {
  __typename?: 'ReviewResponsesConnection';
  /** A list of edges which contains the `ReviewResponse` and cursor to aid in pagination. */
  edges: Array<ReviewResponsesEdge>;
  /** A list of `ReviewResponse` objects. */
  nodes: Array<Maybe<ReviewResponse>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewResponse` edge in the connection. */
export type ReviewResponsesEdge = {
  __typename?: 'ReviewResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewResponse` at the end of the edge. */
  node?: Maybe<ReviewResponse>;
};

/** Methods to use when ordering `ReviewResponse`. */
export enum ReviewResponsesOrderBy {
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLatestReviewAsc = 'IS_LATEST_REVIEW_ASC',
  IsLatestReviewDesc = 'IS_LATEST_REVIEW_DESC',
  IsVisibleToApplicantAsc = 'IS_VISIBLE_TO_APPLICANT_ASC',
  IsVisibleToApplicantDesc = 'IS_VISIBLE_TO_APPLICANT_DESC',
  Natural = 'NATURAL',
  OriginalReviewResponseIdAsc = 'ORIGINAL_REVIEW_RESPONSE_ID_ASC',
  OriginalReviewResponseIdDesc = 'ORIGINAL_REVIEW_RESPONSE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedApplicantVisibilityAsc = 'RECOMMENDED_APPLICANT_VISIBILITY_ASC',
  RecommendedApplicantVisibilityDesc = 'RECOMMENDED_APPLICANT_VISIBILITY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  ReviewResponseLinkIdAsc = 'REVIEW_RESPONSE_LINK_ID_ASC',
  ReviewResponseLinkIdDesc = 'REVIEW_RESPONSE_LINK_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeSubmittedAsc = 'TIME_SUBMITTED_ASC',
  TimeSubmittedDesc = 'TIME_SUBMITTED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC'
}

export enum ReviewResponseStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ReviewResponseStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseStatus>>;
};

/** Input for the nested mutation of `templateElement` in the `ReviewResponseInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `TemplateElementInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateElement` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ReviewInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewAssignmentNodeIdConnect>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `review` in the `ReviewAssignmentInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewReviewAssignmentIdFkeyReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The `review` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** Input for the nested mutation of `user` in the `ReviewInput` mutation. */
export type ReviewReviewerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewReviewerIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `review` in the `UserInput` mutation. */
export type ReviewReviewerIdFkeyInverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyConnect>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewReviewerIdFkeyReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyDelete>>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<Array<ReviewOnReviewForReviewReviewerIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewReviewerIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewReviewerIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** The fields on `review` to look up the row to connect. */
export type ReviewReviewPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to delete. */
export type ReviewReviewPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to connect. */
export type ReviewReviewReviewAssignmentIdKeyConnect = {
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to delete. */
export type ReviewReviewReviewAssignmentIdKeyDelete = {
  reviewAssignmentId: Scalars['Int']['input'];
};

/** A connection to a list of `Review` values. */
export type ReviewsConnection = {
  __typename?: 'ReviewsConnection';
  /** A list of edges which contains the `Review` and cursor to aid in pagination. */
  edges: Array<ReviewsEdge>;
  /** A list of `Review` objects. */
  nodes: Array<Maybe<Review>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Review` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Review` edge in the connection. */
export type ReviewsEdge = {
  __typename?: 'ReviewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Review` at the end of the edge. */
  node?: Maybe<Review>;
};

/** Methods to use when ordering `Review`. */
export enum ReviewsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsFinalDecisionAsc = 'IS_FINAL_DECISION_ASC',
  IsFinalDecisionDesc = 'IS_FINAL_DECISION_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  IsLastStageAsc = 'IS_LAST_STAGE_ASC',
  IsLastStageDesc = 'IS_LAST_STAGE_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TimeStageCreatedAsc = 'TIME_STAGE_CREATED_ASC',
  TimeStageCreatedDesc = 'TIME_STAGE_CREATED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

export enum ReviewStatus {
  ChangesRequested = 'CHANGES_REQUESTED',
  Discontinued = 'DISCONTINUED',
  Draft = 'DRAFT',
  Pending = 'PENDING',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ReviewStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewStatus>>;
};

/** A connection to a list of `ReviewStatusHistory` values. */
export type ReviewStatusHistoriesConnection = {
  __typename?: 'ReviewStatusHistoriesConnection';
  /** A list of edges which contains the `ReviewStatusHistory` and cursor to aid in pagination. */
  edges: Array<ReviewStatusHistoriesEdge>;
  /** A list of `ReviewStatusHistory` objects. */
  nodes: Array<Maybe<ReviewStatusHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewStatusHistory` edge in the connection. */
export type ReviewStatusHistoriesEdge = {
  __typename?: 'ReviewStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewStatusHistory` at the end of the edge. */
  node?: Maybe<ReviewStatusHistory>;
};

/** Methods to use when ordering `ReviewStatusHistory`. */
export enum ReviewStatusHistoriesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ReviewStatusHistory = Node & {
  __typename?: 'ReviewStatusHistory';
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  reviewId: Scalars['Int']['output'];
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};

/** A condition to be used against `ReviewStatusHistory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewStatusHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewStatusHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewStatusHistoryFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewStatusHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewStatusHistoryFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewStatusHistory` */
export type ReviewStatusHistoryInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewStatusHistory` to look up the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
};

/** Represents an update to a `ReviewStatusHistory`. Fields that are set will be updated. */
export type ReviewStatusHistoryPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `review` in the `ReviewStatusHistoryInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewStatusHistoryReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewStatusHistory` in the `ReviewInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewStatusHistoryNodeIdConnect>>;
  /** A `ReviewStatusHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewStatusHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `reviewStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** The `reviewStatusHistory` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewStatusHistory` to look up the row to connect. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewStatusHistory` to look up the row to delete. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NotificationFilter>;
};

/** A filter to be used against many `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewDecisionFilter = {
  /** Every related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewDecisionFilter>;
  /** No related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewDecisionFilter>;
  /** Some related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewDecisionFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A filter to be used against many `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewStatusHistoryFilter = {
  /** Every related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewStatusHistoryFilter>;
  /** No related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewStatusHistoryFilter>;
  /** Some related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewStatusHistoryFilter>;
};

export type SchemaColumn = {
  __typename?: 'SchemaColumn';
  columnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  constraintType?: Maybe<Scalars['CharacterData']['output']>;
  dataType?: Maybe<Scalars['CharacterData']['output']>;
  fkToColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  fkToTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  isGenerated?: Maybe<Scalars['CharacterData']['output']>;
  isNullable?: Maybe<Scalars['YesOrNo']['output']>;
  subDataType?: Maybe<Scalars['CharacterData']['output']>;
  tableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  tableType?: Maybe<Scalars['CharacterData']['output']>;
};

/** A condition to be used against `SchemaColumn` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SchemaColumnCondition = {
  /** Checks for equality with the object’s `columnName` field. */
  columnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `constraintType` field. */
  constraintType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `dataType` field. */
  dataType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `fkToColumnName` field. */
  fkToColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `fkToTableName` field. */
  fkToTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `isGenerated` field. */
  isGenerated?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `isNullable` field. */
  isNullable?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Checks for equality with the object’s `subDataType` field. */
  subDataType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `tableType` field. */
  tableType?: InputMaybe<Scalars['CharacterData']['input']>;
};

/** A filter to be used against `SchemaColumn` object types. All fields are combined with a logical ‘and.’ */
export type SchemaColumnFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SchemaColumnFilter>>;
  /** Filter by the object’s `columnName` field. */
  columnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `constraintType` field. */
  constraintType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `dataType` field. */
  dataType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `fkToColumnName` field. */
  fkToColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `fkToTableName` field. */
  fkToTableName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `isGenerated` field. */
  isGenerated?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `isNullable` field. */
  isNullable?: InputMaybe<YesOrNoFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SchemaColumnFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SchemaColumnFilter>>;
  /** Filter by the object’s `subDataType` field. */
  subDataType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `tableType` field. */
  tableType?: InputMaybe<CharacterDataFilter>;
};

/** A connection to a list of `SchemaColumn` values. */
export type SchemaColumnsConnection = {
  __typename?: 'SchemaColumnsConnection';
  /** A list of edges which contains the `SchemaColumn` and cursor to aid in pagination. */
  edges: Array<SchemaColumnsEdge>;
  /** A list of `SchemaColumn` objects. */
  nodes: Array<Maybe<SchemaColumn>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchemaColumn` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchemaColumn` edge in the connection. */
export type SchemaColumnsEdge = {
  __typename?: 'SchemaColumnsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchemaColumn` at the end of the edge. */
  node?: Maybe<SchemaColumn>;
};

/** Methods to use when ordering `SchemaColumn`. */
export enum SchemaColumnsOrderBy {
  ColumnNameAsc = 'COLUMN_NAME_ASC',
  ColumnNameDesc = 'COLUMN_NAME_DESC',
  ConstraintTypeAsc = 'CONSTRAINT_TYPE_ASC',
  ConstraintTypeDesc = 'CONSTRAINT_TYPE_DESC',
  DataTypeAsc = 'DATA_TYPE_ASC',
  DataTypeDesc = 'DATA_TYPE_DESC',
  FkToColumnNameAsc = 'FK_TO_COLUMN_NAME_ASC',
  FkToColumnNameDesc = 'FK_TO_COLUMN_NAME_DESC',
  FkToTableNameAsc = 'FK_TO_TABLE_NAME_ASC',
  FkToTableNameDesc = 'FK_TO_TABLE_NAME_DESC',
  IsGeneratedAsc = 'IS_GENERATED_ASC',
  IsGeneratedDesc = 'IS_GENERATED_DESC',
  IsNullableAsc = 'IS_NULLABLE_ASC',
  IsNullableDesc = 'IS_NULLABLE_DESC',
  Natural = 'NATURAL',
  SubDataTypeAsc = 'SUB_DATA_TYPE_ASC',
  SubDataTypeDesc = 'SUB_DATA_TYPE_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TableTypeAsc = 'TABLE_TYPE_ASC',
  TableTypeDesc = 'TABLE_TYPE_DESC'
}

/** A filter to be used against SqlIdentifier fields. All fields are combined with a logical ‘and.’ */
export type SqlIdentifierFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type SystemInfo = Node & {
  __typename?: 'SystemInfo';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  value?: Maybe<Scalars['JSON']['output']>;
};

/** A condition to be used against `SystemInfo` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SystemInfoCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `SystemInfo` object types. All fields are combined with a logical ‘and.’ */
export type SystemInfoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SystemInfoFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SystemInfoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SystemInfoFilter>>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `SystemInfo` */
export type SystemInfoInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Represents an update to a `SystemInfo`. Fields that are set will be updated. */
export type SystemInfoPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `SystemInfo` values. */
export type SystemInfosConnection = {
  __typename?: 'SystemInfosConnection';
  /** A list of edges which contains the `SystemInfo` and cursor to aid in pagination. */
  edges: Array<SystemInfosEdge>;
  /** A list of `SystemInfo` objects. */
  nodes: Array<Maybe<SystemInfo>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SystemInfo` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SystemInfo` edge in the connection. */
export type SystemInfosEdge = {
  __typename?: 'SystemInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SystemInfo` at the end of the edge. */
  node?: Maybe<SystemInfo>;
};

/** Methods to use when ordering `SystemInfo`. */
export enum SystemInfosOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type Template = Node & {
  __typename?: 'Template';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues: ActionQueuesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applications: ApplicationsConnection;
  canApplicantMakeChanges?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  dashboardRestrictions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isLinear?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  namePlural?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentVersionId?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  serialPattern?: Maybe<Scalars['String']['output']>;
  startMessage?: Maybe<Scalars['JSON']['output']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions: TemplateActionsConnection;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  templateCategoryId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins: TemplateFilterJoinsConnection;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections: TemplateSectionsConnection;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages: TemplateStagesConnection;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules: TriggerSchedulesConnection;
  versionComment?: Maybe<Scalars['String']['output']>;
  versionHistory?: Maybe<Scalars['JSON']['output']>;
  versionId: Scalars['String']['output'];
  versionTimestamp?: Maybe<Scalars['Datetime']['output']>;
};


export type TemplateActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


export type TemplateApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type TemplateFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type TemplateReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type TemplateTemplateActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateActionCondition>;
  filter?: InputMaybe<TemplateActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};


export type TemplateTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};


export type TemplateTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};


export type TemplateTemplateSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateSectionCondition>;
  filter?: InputMaybe<TemplateSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};


export type TemplateTemplateStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageCondition>;
  filter?: InputMaybe<TemplateStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};


export type TemplateTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

export type TemplateAction = Node & {
  __typename?: 'TemplateAction';
  actionCode?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  condition?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parameterQueries?: Maybe<Scalars['JSON']['output']>;
  parametersQueriesString?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  trigger?: Maybe<Trigger>;
};

/** A condition to be used against `TemplateAction` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateActionCondition = {
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `condition` field. */
  condition?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** A filter to be used against `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateActionFilter = {
  /** Filter by the object’s `actionCode` field. */
  actionCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateActionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `condition` field. */
  condition?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateActionFilter>>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersQueriesString` field. */
  parametersQueriesString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: InputMaybe<IntFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TemplateAction` */
export type TemplateActionInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateActionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateActionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateAction` to look up the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplateAction`. Fields that are set will be updated. */
export type TemplateActionPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** A connection to a list of `TemplateAction` values. */
export type TemplateActionsConnection = {
  __typename?: 'TemplateActionsConnection';
  /** A list of edges which contains the `TemplateAction` and cursor to aid in pagination. */
  edges: Array<TemplateActionsEdge>;
  /** A list of `TemplateAction` objects. */
  nodes: Array<Maybe<TemplateAction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateAction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateAction` edge in the connection. */
export type TemplateActionsEdge = {
  __typename?: 'TemplateActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateAction` at the end of the edge. */
  node?: Maybe<TemplateAction>;
};

/** Methods to use when ordering `TemplateAction`. */
export enum TemplateActionsOrderBy {
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ConditionAsc = 'CONDITION_ASC',
  ConditionDesc = 'CONDITION_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

/** The fields on `templateAction` to look up the row to connect. */
export type TemplateActionTemplateActionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateAction` to look up the row to delete. */
export type TemplateActionTemplateActionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `template` in the `TemplateActionInput` mutation. */
export type TemplateActionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateActionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateAction` in the `TemplateInput` mutation. */
export type TemplateActionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateActionTemplateActionPkeyConnect>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateActionNodeIdConnect>>;
  /** A `TemplateActionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateActionTemplateIdFkeyTemplateActionCreateInput>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateActionTemplateActionPkeyDelete>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateActionNodeIdDelete>>;
  /** Flag indicating whether all other `templateAction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>>;
};

/** The `templateAction` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateActionCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The `template` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `TemplateCategory` values. */
export type TemplateCategoriesConnection = {
  __typename?: 'TemplateCategoriesConnection';
  /** A list of edges which contains the `TemplateCategory` and cursor to aid in pagination. */
  edges: Array<TemplateCategoriesEdge>;
  /** A list of `TemplateCategory` objects. */
  nodes: Array<Maybe<TemplateCategory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateCategory` edge in the connection. */
export type TemplateCategoriesEdge = {
  __typename?: 'TemplateCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateCategory` at the end of the edge. */
  node?: Maybe<TemplateCategory>;
};

/** Methods to use when ordering `TemplateCategory`. */
export enum TemplateCategoriesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IconAsc = 'ICON_ASC',
  IconDesc = 'ICON_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsSubmenuAsc = 'IS_SUBMENU_ASC',
  IsSubmenuDesc = 'IS_SUBMENU_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UiLocationAsc = 'UI_LOCATION_ASC',
  UiLocationDesc = 'UI_LOCATION_DESC'
}

export type TemplateCategory = Node & {
  __typename?: 'TemplateCategory';
  code: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isSubmenu?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Template`. */
  templates: TemplatesConnection;
  title?: Maybe<Scalars['String']['output']>;
  uiLocation?: Maybe<Array<Maybe<UiLocation>>>;
};


export type TemplateCategoryTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCondition>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** A condition to be used against `TemplateCategory` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateCategoryCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isSubmenu` field. */
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uiLocation` field. */
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** A filter to be used against `TemplateCategory` object types. All fields are combined with a logical ‘and.’ */
export type TemplateCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateCategoryFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `icon` field. */
  icon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isSubmenu` field. */
  isSubmenu?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateCategoryFilter>>;
  /** Filter by the object’s `templates` relation. */
  templates?: InputMaybe<TemplateCategoryToManyTemplateFilter>;
  /** Some related `templates` exist. */
  templatesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uiLocation` field. */
  uiLocation?: InputMaybe<UiLocationListFilter>;
};

/** An input for mutations affecting `TemplateCategory` */
export type TemplateCategoryInput = {
  code: Scalars['String']['input'];
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateCategory` to look up the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** The fields on `templateCategory` to look up the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** Represents an update to a `TemplateCategory`. Fields that are set will be updated. */
export type TemplateCategoryPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The fields on `templateCategory` to look up the row to connect. */
export type TemplateCategoryTemplateCategoryCodeKeyConnect = {
  code: Scalars['String']['input'];
};

/** The fields on `templateCategory` to look up the row to delete. */
export type TemplateCategoryTemplateCategoryCodeKeyDelete = {
  code: Scalars['String']['input'];
};

/** The fields on `templateCategory` to look up the row to connect. */
export type TemplateCategoryTemplateCategoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateCategory` to look up the row to delete. */
export type TemplateCategoryTemplateCategoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Template` object types. All fields are combined with a logical ‘and.’ */
export type TemplateCategoryToManyTemplateFilter = {
  /** Every related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilter>;
  /** No related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilter>;
  /** Some related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilter>;
};

/** A condition to be used against `Template` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateCondition = {
  /** Checks for equality with the object’s `canApplicantMakeChanges` field. */
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dashboardRestrictions` field. */
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLinear` field. */
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `namePlural` field. */
  namePlural?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentVersionId` field. */
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialPattern` field. */
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `startMessage` field. */
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<TemplateStatus>;
  /** Checks for equality with the object’s `submissionMessage` field. */
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `templateCategoryId` field. */
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `versionComment` field. */
  versionComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `versionHistory` field. */
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `versionId` field. */
  versionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `versionTimestamp` field. */
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

export type TemplateElement = Node & {
  __typename?: 'TemplateElement';
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  category?: Maybe<TemplateElementCategory>;
  code: Scalars['String']['output'];
  elementTypePluginCode?: Maybe<Scalars['String']['output']>;
  helpText?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  index?: Maybe<Scalars['Int']['output']>;
  initialValue?: Maybe<Scalars['JSON']['output']>;
  isEditable?: Maybe<Scalars['JSON']['output']>;
  isRequired?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parameters?: Maybe<Scalars['JSON']['output']>;
  parametersString?: Maybe<Scalars['String']['output']>;
  reviewability: Reviewability;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  sectionId: Scalars['Int']['output'];
  templateCode?: Maybe<Scalars['String']['output']>;
  templateVersion?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  validation?: Maybe<Scalars['JSON']['output']>;
  validationMessage?: Maybe<Scalars['String']['output']>;
  visibilityCondition?: Maybe<Scalars['JSON']['output']>;
};


export type TemplateElementApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


export type TemplateElementReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

export enum TemplateElementCategory {
  Information = 'INFORMATION',
  Question = 'QUESTION'
}

/** A filter to be used against TemplateElementCategory fields. All fields are combined with a logical ‘and.’ */
export type TemplateElementCategoryFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TemplateElementCategory>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TemplateElementCategory>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TemplateElementCategory>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TemplateElementCategory>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TemplateElementCategory>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TemplateElementCategory>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TemplateElementCategory>>;
};

/** A condition to be used against `TemplateElement` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateElementCondition = {
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `helpText` field. */
  helpText?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `index` field. */
  index?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initialValue` field. */
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `isEditable` field. */
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `isRequired` field. */
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parameters` field. */
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `reviewability` field. */
  reviewability?: InputMaybe<Reviewability>;
  /** Checks for equality with the object’s `sectionId` field. */
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateVersion` field. */
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `validation` field. */
  validation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `validationMessage` field. */
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `visibilityCondition` field. */
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateElementFilter>>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: InputMaybe<TemplateElementToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `helpText` field. */
  helpText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `index` field. */
  index?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initialValue` field. */
  initialValue?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `isEditable` field. */
  isEditable?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `isRequired` field. */
  isRequired?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateElementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateElementFilter>>;
  /** Filter by the object’s `parameters` field. */
  parameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersString` field. */
  parametersString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewability` field. */
  reviewability?: InputMaybe<ReviewabilityFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<TemplateElementToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `section` relation. */
  section?: InputMaybe<TemplateSectionFilter>;
  /** Filter by the object’s `sectionId` field. */
  sectionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateVersion` field. */
  templateVersion?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `validation` field. */
  validation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `validationMessage` field. */
  validationMessage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `visibilityCondition` field. */
  visibilityCondition?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `TemplateElement` */
export type TemplateElementInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateElementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateElementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** Represents an update to a `TemplateElement`. Fields that are set will be updated. */
export type TemplateElementPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `TemplateElement` values. */
export type TemplateElementsConnection = {
  __typename?: 'TemplateElementsConnection';
  /** A list of edges which contains the `TemplateElement` and cursor to aid in pagination. */
  edges: Array<TemplateElementsEdge>;
  /** A list of `TemplateElement` objects. */
  nodes: Array<Maybe<TemplateElement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateElement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** Input for the nested mutation of `templateSection` in the `TemplateElementInput` mutation. */
export type TemplateElementSectionIdFkeyInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateSectionTemplateSectionPkeyConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateSectionNodeIdConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByTemplateIdAndCode?: InputMaybe<TemplateSectionTemplateSectionTemplateIdCodeKeyConnect>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateElementSectionIdFkeyTemplateSectionCreateInput>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateSectionTemplateSectionPkeyDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateSectionNodeIdDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByTemplateIdAndCode?: InputMaybe<TemplateSectionTemplateSectionTemplateIdCodeKeyDelete>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByTemplateIdAndCode?: InputMaybe<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate>;
};

/** Input for the nested mutation of `templateElement` in the `TemplateSectionInput` mutation. */
export type TemplateElementSectionIdFkeyInverseInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateElementTemplateElementPkeyConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateElementNodeIdConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateElementSectionIdFkeyTemplateElementCreateInput>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateElementTemplateElementPkeyDelete>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateElementNodeIdDelete>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>>;
  /** Flag indicating whether all other `templateElement` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>>;
};

/** The `templateElement` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateSectionCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A `TemplateElement` edge in the connection. */
export type TemplateElementsEdge = {
  __typename?: 'TemplateElementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateElement` at the end of the edge. */
  node?: Maybe<TemplateElement>;
};

/** Methods to use when ordering `TemplateElement`. */
export enum TemplateElementsOrderBy {
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ElementTypePluginCodeAsc = 'ELEMENT_TYPE_PLUGIN_CODE_ASC',
  ElementTypePluginCodeDesc = 'ELEMENT_TYPE_PLUGIN_CODE_DESC',
  HelpTextAsc = 'HELP_TEXT_ASC',
  HelpTextDesc = 'HELP_TEXT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  InitialValueAsc = 'INITIAL_VALUE_ASC',
  InitialValueDesc = 'INITIAL_VALUE_DESC',
  IsEditableAsc = 'IS_EDITABLE_ASC',
  IsEditableDesc = 'IS_EDITABLE_DESC',
  IsRequiredAsc = 'IS_REQUIRED_ASC',
  IsRequiredDesc = 'IS_REQUIRED_DESC',
  Natural = 'NATURAL',
  ParametersAsc = 'PARAMETERS_ASC',
  ParametersDesc = 'PARAMETERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewabilityAsc = 'REVIEWABILITY_ASC',
  ReviewabilityDesc = 'REVIEWABILITY_DESC',
  SectionIdAsc = 'SECTION_ID_ASC',
  SectionIdDesc = 'SECTION_ID_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateVersionAsc = 'TEMPLATE_VERSION_ASC',
  TemplateVersionDesc = 'TEMPLATE_VERSION_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  ValidationAsc = 'VALIDATION_ASC',
  ValidationDesc = 'VALIDATION_DESC',
  ValidationMessageAsc = 'VALIDATION_MESSAGE_ASC',
  ValidationMessageDesc = 'VALIDATION_MESSAGE_DESC',
  VisibilityConditionAsc = 'VISIBILITY_CONDITION_ASC',
  VisibilityConditionDesc = 'VISIBILITY_CONDITION_DESC'
}

/** The fields on `templateElement` to look up the row to connect. */
export type TemplateElementTemplateElementPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateElement` to look up the row to delete. */
export type TemplateElementTemplateElementPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateElement` to look up the row to connect. */
export type TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The fields on `templateElement` to look up the row to delete. */
export type TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A filter to be used against `Template` object types. All fields are combined with a logical ‘and.’ */
export type TemplateFilter = {
  /** Filter by the object’s `actionQueues` relation. */
  actionQueues?: InputMaybe<TemplateToManyActionQueueFilter>;
  /** Some related `actionQueues` exist. */
  actionQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateFilter>>;
  /** Filter by the object’s `applications` relation. */
  applications?: InputMaybe<TemplateToManyApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `canApplicantMakeChanges` field. */
  canApplicantMakeChanges?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dashboardRestrictions` field. */
  dashboardRestrictions?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<TemplateToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `icon` field. */
  icon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLinear` field. */
  isLinear?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `namePlural` field. */
  namePlural?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateFilter>>;
  /** Filter by the object’s `parentVersionId` field. */
  parentVersionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<TemplateToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serialPattern` field. */
  serialPattern?: InputMaybe<StringFilter>;
  /** Filter by the object’s `startMessage` field. */
  startMessage?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<TemplateStatusFilter>;
  /** Filter by the object’s `submissionMessage` field. */
  submissionMessage?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `templateActions` relation. */
  templateActions?: InputMaybe<TemplateToManyTemplateActionFilter>;
  /** Some related `templateActions` exist. */
  templateActionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateCategory` relation. */
  templateCategory?: InputMaybe<TemplateCategoryFilter>;
  /** A related `templateCategory` exists. */
  templateCategoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateCategoryId` field. */
  templateCategoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateFilterJoins` relation. */
  templateFilterJoins?: InputMaybe<TemplateToManyTemplateFilterJoinFilter>;
  /** Some related `templateFilterJoins` exist. */
  templateFilterJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: InputMaybe<TemplateToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateSections` relation. */
  templateSections?: InputMaybe<TemplateToManyTemplateSectionFilter>;
  /** Some related `templateSections` exist. */
  templateSectionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateStages` relation. */
  templateStages?: InputMaybe<TemplateToManyTemplateStageFilter>;
  /** Some related `templateStages` exist. */
  templateStagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `triggerSchedules` relation. */
  triggerSchedules?: InputMaybe<TemplateToManyTriggerScheduleFilter>;
  /** Some related `triggerSchedules` exist. */
  triggerSchedulesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `versionComment` field. */
  versionComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `versionHistory` field. */
  versionHistory?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `versionId` field. */
  versionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `versionTimestamp` field. */
  versionTimestamp?: InputMaybe<DatetimeFilter>;
};

export type TemplateFilterJoin = Node & {
  __typename?: 'TemplateFilterJoin';
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  filterId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
};

/** A condition to be used against `TemplateFilterJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateFilterJoinCondition = {
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type TemplateFilterJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateFilterJoinFilter>>;
  /** Filter by the object’s `filter` relation. */
  filter?: InputMaybe<FilterFilter>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateFilterJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateFilterJoinFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
};

/** The `filter` to be created by this mutation. */
export type TemplateFilterJoinFilterIdFkeyFilterCreateInput = {
  code: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** Input for the nested mutation of `filter` in the `TemplateFilterJoinInput` mutation. */
export type TemplateFilterJoinFilterIdFkeyInput = {
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectByCode?: InputMaybe<FilterFilterCodeKeyConnect>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectById?: InputMaybe<FilterFilterPkeyConnect>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<FilterNodeIdConnect>;
  /** A `FilterInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateFilterJoinFilterIdFkeyFilterCreateInput>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteByCode?: InputMaybe<FilterFilterCodeKeyDelete>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteById?: InputMaybe<FilterFilterPkeyDelete>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<FilterNodeIdDelete>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateByCode?: InputMaybe<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateById?: InputMaybe<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateFilterJoin` in the `FilterInput` mutation. */
export type TemplateFilterJoinFilterIdFkeyInverseInput = {
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyConnect>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdConnect>>;
  /** A `TemplateFilterJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyDelete>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdDelete>>;
  /** Flag indicating whether all other `templateFilterJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate>>;
};

/** The `templateFilterJoin` to be created by this mutation. */
export type TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput = {
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An input for mutations affecting `TemplateFilterJoin` */
export type TemplateFilterJoinInput = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateFilterJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateFilterJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `filter` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: FilterPatch;
};

/** The fields on `templateFilterJoin` to look up the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateFilterJoin` to look up the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplateFilterJoin`. Fields that are set will be updated. */
export type TemplateFilterJoinPatch = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** A connection to a list of `TemplateFilterJoin` values. */
export type TemplateFilterJoinsConnection = {
  __typename?: 'TemplateFilterJoinsConnection';
  /** A list of edges which contains the `TemplateFilterJoin` and cursor to aid in pagination. */
  edges: Array<TemplateFilterJoinsEdge>;
  /** A list of `TemplateFilterJoin` objects. */
  nodes: Array<Maybe<TemplateFilterJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateFilterJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateFilterJoin` edge in the connection. */
export type TemplateFilterJoinsEdge = {
  __typename?: 'TemplateFilterJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateFilterJoin` at the end of the edge. */
  node?: Maybe<TemplateFilterJoin>;
};

/** Methods to use when ordering `TemplateFilterJoin`. */
export enum TemplateFilterJoinsOrderBy {
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC'
}

/** The fields on `templateFilterJoin` to look up the row to connect. */
export type TemplateFilterJoinTemplateFilterJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateFilterJoin` to look up the row to delete. */
export type TemplateFilterJoinTemplateFilterJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `template` in the `TemplateFilterJoinInput` mutation. */
export type TemplateFilterJoinTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateFilterJoinTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateFilterJoin` in the `TemplateInput` mutation. */
export type TemplateFilterJoinTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyConnect>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdConnect>>;
  /** A `TemplateFilterJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyDelete>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdDelete>>;
  /** Flag indicating whether all other `templateFilterJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateFilterJoinTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateFilterJoin` to be created by this mutation. */
export type TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An input for mutations affecting `Template` */
export type TemplateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `template` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: TemplateActionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
};

/** Represents an update to a `Template`. Fields that are set will be updated. */
export type TemplatePatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

export type TemplatePermission = Node & {
  __typename?: 'TemplatePermission';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  canMakeFinalDecision: Scalars['Boolean']['output'];
  canSelfAssign: Scalars['Boolean']['output'];
  id: Scalars['Int']['output'];
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  permissionNameId?: Maybe<Scalars['Int']['output']>;
  restrictions?: Maybe<Scalars['JSON']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
};

/** A condition to be used against `TemplatePermission` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplatePermissionCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `restrictions` field. */
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplatePermissionFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplatePermissionFilter>>;
  /** Filter by the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplatePermissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplatePermissionFilter>>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: InputMaybe<PermissionNameFilter>;
  /** A related `permissionName` exists. */
  permissionNameExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `restrictions` field. */
  restrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TemplatePermission` */
export type TemplatePermissionInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplatePermissionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplatePermissionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplatePermission`. Fields that are set will be updated. */
export type TemplatePermissionPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `permissionName` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionNameNodeIdConnect>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templatePermission` in the `PermissionNameInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInverseInput = {
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdConnect>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdDelete>>;
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>>;
};

/** The `permissionName` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** A connection to a list of `TemplatePermission` values. */
export type TemplatePermissionsConnection = {
  __typename?: 'TemplatePermissionsConnection';
  /** A list of edges which contains the `TemplatePermission` and cursor to aid in pagination. */
  edges: Array<TemplatePermissionsEdge>;
  /** A list of `TemplatePermission` objects. */
  nodes: Array<Maybe<TemplatePermission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplatePermission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplatePermission` edge in the connection. */
export type TemplatePermissionsEdge = {
  __typename?: 'TemplatePermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplatePermission` at the end of the edge. */
  node?: Maybe<TemplatePermission>;
};

/** Methods to use when ordering `TemplatePermission`. */
export enum TemplatePermissionsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  CanMakeFinalDecisionAsc = 'CAN_MAKE_FINAL_DECISION_ASC',
  CanMakeFinalDecisionDesc = 'CAN_MAKE_FINAL_DECISION_DESC',
  CanSelfAssignAsc = 'CAN_SELF_ASSIGN_ASC',
  CanSelfAssignDesc = 'CAN_SELF_ASSIGN_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RestrictionsAsc = 'RESTRICTIONS_ASC',
  RestrictionsDesc = 'RESTRICTIONS_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC'
}

/** Input for the nested mutation of `template` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplatePermissionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templatePermission` in the `TemplateInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdConnect>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdDelete>>;
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The fields on `templatePermission` to look up the row to connect. */
export type TemplatePermissionTemplatePermissionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templatePermission` to look up the row to delete. */
export type TemplatePermissionTemplatePermissionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `Template` values. */
export type TemplatesConnection = {
  __typename?: 'TemplatesConnection';
  /** A list of edges which contains the `Template` and cursor to aid in pagination. */
  edges: Array<TemplatesEdge>;
  /** A list of `Template` objects. */
  nodes: Array<Maybe<Template>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Template` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

export type TemplateSection = Node & {
  __typename?: 'TemplateSection';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  index?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElementsBySectionId: TemplateElementsConnection;
  templateId: Scalars['Int']['output'];
  title?: Maybe<Scalars['String']['output']>;
};


export type TemplateSectionTemplateElementsBySectionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateElementCondition>;
  filter?: InputMaybe<TemplateElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** A condition to be used against `TemplateSection` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateSectionCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `index` field. */
  index?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateSectionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `index` field. */
  index?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateSectionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateSectionFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateElementsBySectionId` relation. */
  templateElementsBySectionId?: InputMaybe<TemplateSectionToManyTemplateElementFilter>;
  /** Some related `templateElementsBySectionId` exist. */
  templateElementsBySectionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TemplateSection` */
export type TemplateSectionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateSectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateSectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateSection` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  templateId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  templateId: Scalars['Int']['input'];
};

/** Represents an update to a `TemplateSection`. Fields that are set will be updated. */
export type TemplateSectionPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `TemplateSection` values. */
export type TemplateSectionsConnection = {
  __typename?: 'TemplateSectionsConnection';
  /** A list of edges which contains the `TemplateSection` and cursor to aid in pagination. */
  edges: Array<TemplateSectionsEdge>;
  /** A list of `TemplateSection` objects. */
  nodes: Array<Maybe<TemplateSection>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateSection` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateSection` edge in the connection. */
export type TemplateSectionsEdge = {
  __typename?: 'TemplateSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateSection` at the end of the edge. */
  node?: Maybe<TemplateSection>;
};

/** Methods to use when ordering `TemplateSection`. */
export enum TemplateSectionsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `template` in the `TemplateSectionInput` mutation. */
export type TemplateSectionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateSectionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateSection` in the `TemplateInput` mutation. */
export type TemplateSectionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateSectionTemplateSectionPkeyConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateSectionNodeIdConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionTemplateSectionTemplateIdCodeKeyConnect>>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateSectionTemplateIdFkeyTemplateSectionCreateInput>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateSectionTemplateSectionPkeyDelete>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateSectionNodeIdDelete>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionTemplateSectionTemplateIdCodeKeyDelete>>;
  /** Flag indicating whether all other `templateSection` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateSectionCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `templateSection` to look up the row to connect. */
export type TemplateSectionTemplateSectionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to delete. */
export type TemplateSectionTemplateSectionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to connect. */
export type TemplateSectionTemplateSectionTemplateIdCodeKeyConnect = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to delete. */
export type TemplateSectionTemplateSectionTemplateIdCodeKeyDelete = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** A filter to be used against many `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionToManyTemplateElementFilter = {
  /** Every related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateElementFilter>;
  /** No related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateElementFilter>;
  /** Some related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateElementFilter>;
};

/** A `Template` edge in the connection. */
export type TemplatesEdge = {
  __typename?: 'TemplatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Template` at the end of the edge. */
  node?: Maybe<Template>;
};

/** Methods to use when ordering `Template`. */
export enum TemplatesOrderBy {
  CanApplicantMakeChangesAsc = 'CAN_APPLICANT_MAKE_CHANGES_ASC',
  CanApplicantMakeChangesDesc = 'CAN_APPLICANT_MAKE_CHANGES_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DashboardRestrictionsAsc = 'DASHBOARD_RESTRICTIONS_ASC',
  DashboardRestrictionsDesc = 'DASHBOARD_RESTRICTIONS_DESC',
  IconAsc = 'ICON_ASC',
  IconDesc = 'ICON_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLinearAsc = 'IS_LINEAR_ASC',
  IsLinearDesc = 'IS_LINEAR_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  NamePluralAsc = 'NAME_PLURAL_ASC',
  NamePluralDesc = 'NAME_PLURAL_DESC',
  Natural = 'NATURAL',
  ParentVersionIdAsc = 'PARENT_VERSION_ID_ASC',
  ParentVersionIdDesc = 'PARENT_VERSION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialPatternAsc = 'SERIAL_PATTERN_ASC',
  SerialPatternDesc = 'SERIAL_PATTERN_DESC',
  StartMessageAsc = 'START_MESSAGE_ASC',
  StartMessageDesc = 'START_MESSAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubmissionMessageAsc = 'SUBMISSION_MESSAGE_ASC',
  SubmissionMessageDesc = 'SUBMISSION_MESSAGE_DESC',
  TemplateCategoryIdAsc = 'TEMPLATE_CATEGORY_ID_ASC',
  TemplateCategoryIdDesc = 'TEMPLATE_CATEGORY_ID_DESC',
  VersionCommentAsc = 'VERSION_COMMENT_ASC',
  VersionCommentDesc = 'VERSION_COMMENT_DESC',
  VersionHistoryAsc = 'VERSION_HISTORY_ASC',
  VersionHistoryDesc = 'VERSION_HISTORY_DESC',
  VersionIdAsc = 'VERSION_ID_ASC',
  VersionIdDesc = 'VERSION_ID_DESC',
  VersionTimestampAsc = 'VERSION_TIMESTAMP_ASC',
  VersionTimestampDesc = 'VERSION_TIMESTAMP_DESC'
}

export type TemplateStage = Node & {
  __typename?: 'TemplateStage';
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistoriesByStageId: ApplicationStageHistoriesConnection;
  colour?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByStageId: ReviewAssignmentsConnection;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `TemplateStageReviewLevel`. */
  templateStageReviewLevelsByStageId: TemplateStageReviewLevelsConnection;
  title?: Maybe<Scalars['String']['output']>;
};


export type TemplateStageApplicationStageHistoriesByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


export type TemplateStageReviewAssignmentsByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type TemplateStageTemplateStageReviewLevelsByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageReviewLevelCondition>;
  filter?: InputMaybe<TemplateStageReviewLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** A condition to be used against `TemplateStage` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateStageCondition = {
  /** Checks for equality with the object’s `colour` field. */
  colour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateStageFilter>>;
  /** Filter by the object’s `applicationStageHistoriesByStageId` relation. */
  applicationStageHistoriesByStageId?: InputMaybe<TemplateStageToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistoriesByStageId` exist. */
  applicationStageHistoriesByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `colour` field. */
  colour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateStageFilter>>;
  /** Filter by the object’s `reviewAssignmentsByStageId` relation. */
  reviewAssignmentsByStageId?: InputMaybe<TemplateStageToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByStageId` exist. */
  reviewAssignmentsByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateStageReviewLevelsByStageId` relation. */
  templateStageReviewLevelsByStageId?: InputMaybe<TemplateStageToManyTemplateStageReviewLevelFilter>;
  /** Some related `templateStageReviewLevelsByStageId` exist. */
  templateStageReviewLevelsByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TemplateStage` */
export type TemplateStageInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateStageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateStageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
};

/** Represents an update to a `TemplateStage`. Fields that are set will be updated. */
export type TemplateStagePatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type TemplateStageReviewLevel = Node & {
  __typename?: 'TemplateStageReviewLevel';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByLevelId: ReviewAssignmentsConnection;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
};


export type TemplateStageReviewLevelReviewAssignmentsByLevelIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** A condition to be used against `TemplateStageReviewLevel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TemplateStageReviewLevelCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplateStageReviewLevel` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageReviewLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateStageReviewLevelFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateStageReviewLevelFilter>>;
  /** Filter by the object’s `reviewAssignmentsByLevelId` relation. */
  reviewAssignmentsByLevelId?: InputMaybe<TemplateStageReviewLevelToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByLevelId` exist. */
  reviewAssignmentsByLevelIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TemplateStageReviewLevel` */
export type TemplateStageReviewLevelInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateStageReviewLevelNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateStageReviewLevelNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `templateStageReviewLevel` to look up the row to update. */
export type TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `templateStageReviewLevel` to look up the row to update. */
export type TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
};

/** Represents an update to a `TemplateStageReviewLevel`. Fields that are set will be updated. */
export type TemplateStageReviewLevelPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** A connection to a list of `TemplateStageReviewLevel` values. */
export type TemplateStageReviewLevelsConnection = {
  __typename?: 'TemplateStageReviewLevelsConnection';
  /** A list of edges which contains the `TemplateStageReviewLevel` and cursor to aid in pagination. */
  edges: Array<TemplateStageReviewLevelsEdge>;
  /** A list of `TemplateStageReviewLevel` objects. */
  nodes: Array<Maybe<TemplateStageReviewLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateStageReviewLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateStageReviewLevel` edge in the connection. */
export type TemplateStageReviewLevelsEdge = {
  __typename?: 'TemplateStageReviewLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateStageReviewLevel` at the end of the edge. */
  node?: Maybe<TemplateStageReviewLevel>;
};

/** Methods to use when ordering `TemplateStageReviewLevel`. */
export enum TemplateStageReviewLevelsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC'
}

/** Input for the nested mutation of `templateStage` in the `TemplateStageReviewLevelInput` mutation. */
export type TemplateStageReviewLevelStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateStageReviewLevel` in the `TemplateStageInput` mutation. */
export type TemplateStageReviewLevelStageIdFkeyInverseInput = {
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateStageReviewLevelNodeIdConnect>>;
  /** A `TemplateStageReviewLevelInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateStageReviewLevelNodeIdDelete>>;
  /** Flag indicating whether all other `templateStageReviewLevel` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate>>;
};

/** The `templateStage` to be created by this mutation. */
export type TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The `templateStageReviewLevel` to be created by this mutation. */
export type TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The fields on `templateStageReviewLevel` to look up the row to connect. */
export type TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateStageReviewLevel` to look up the row to delete. */
export type TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageReviewLevelToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A connection to a list of `TemplateStage` values. */
export type TemplateStagesConnection = {
  __typename?: 'TemplateStagesConnection';
  /** A list of edges which contains the `TemplateStage` and cursor to aid in pagination. */
  edges: Array<TemplateStagesEdge>;
  /** A list of `TemplateStage` objects. */
  nodes: Array<Maybe<TemplateStage>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateStage` edge in the connection. */
export type TemplateStagesEdge = {
  __typename?: 'TemplateStagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateStage` at the end of the edge. */
  node?: Maybe<TemplateStage>;
};

/** Methods to use when ordering `TemplateStage`. */
export enum TemplateStagesOrderBy {
  ColourAsc = 'COLOUR_ASC',
  ColourDesc = 'COLOUR_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** Input for the nested mutation of `template` in the `TemplateStageInput` mutation. */
export type TemplateStageTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateStageTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateStage` in the `TemplateInput` mutation. */
export type TemplateStageTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateStageTemplateStagePkeyConnect>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateStageNodeIdConnect>>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateStageTemplateIdFkeyTemplateStageCreateInput>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateStageTemplateStagePkeyDelete>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateStageNodeIdDelete>>;
  /** Flag indicating whether all other `templateStage` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate>>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateStage` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `templateStage` to look up the row to connect. */
export type TemplateStageTemplateStagePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateStage` to look up the row to delete. */
export type TemplateStageTemplateStagePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `TemplateStageReviewLevel` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyTemplateStageReviewLevelFilter = {
  /** Every related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** No related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** Some related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateStageReviewLevelFilter>;
};

export enum TemplateStatus {
  Available = 'AVAILABLE',
  Disabled = 'DISABLED',
  Draft = 'DRAFT'
}

/** A filter to be used against TemplateStatus fields. All fields are combined with a logical ‘and.’ */
export type TemplateStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TemplateStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TemplateStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TemplateStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TemplateStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TemplateStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TemplateStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TemplateStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TemplateStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TemplateStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TemplateStatus>>;
};

/** Input for the nested mutation of `templateCategory` in the `TemplateInput` mutation. */
export type TemplateTemplateCategoryIdFkeyInput = {
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectByCode?: InputMaybe<TemplateCategoryTemplateCategoryCodeKeyConnect>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateCategoryTemplateCategoryPkeyConnect>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateCategoryNodeIdConnect>;
  /** A `TemplateCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteByCode?: InputMaybe<TemplateCategoryTemplateCategoryCodeKeyDelete>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateCategoryTemplateCategoryPkeyDelete>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateByCode?: InputMaybe<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `template` in the `TemplateCategoryInput` mutation. */
export type TemplateTemplateCategoryIdFkeyInverseInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<Array<TemplateTemplateCodeVersionIdKeyConnect>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateTemplatePkeyConnect>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateNodeIdConnect>>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateTemplateCategoryIdFkeyTemplateCreateInput>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<Array<TemplateTemplateCodeVersionIdKeyDelete>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateTemplatePkeyDelete>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateNodeIdDelete>>;
  /** Flag indicating whether all other `template` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<Array<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate>>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate>>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate>>;
};

/** The `templateCategory` to be created by this mutation. */
export type TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput = {
  code: Scalars['String']['input'];
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The `template` to be created by this mutation. */
export type TemplateTemplateCategoryIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `template` to look up the row to connect. */
export type TemplateTemplateCodeVersionIdKeyConnect = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to delete. */
export type TemplateTemplateCodeVersionIdKeyDelete = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to connect. */
export type TemplateTemplatePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `template` to look up the row to delete. */
export type TemplateTemplatePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateActionFilter = {
  /** Every related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateActionFilter>;
  /** No related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateActionFilter>;
  /** Some related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateActionFilter>;
};

/** A filter to be used against many `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateFilterJoinFilter = {
  /** Every related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilterJoinFilter>;
  /** No related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilterJoinFilter>;
  /** Some related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilterJoinFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplatePermissionFilter>;
};

/** A filter to be used against many `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateSectionFilter = {
  /** Every related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateSectionFilter>;
  /** No related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateSectionFilter>;
  /** Some related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateSectionFilter>;
};

/** A filter to be used against many `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateStageFilter = {
  /** Every related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateStageFilter>;
  /** No related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateStageFilter>;
  /** Some related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateStageFilter>;
};

/** A filter to be used against many `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTriggerScheduleFilter = {
  /** Every related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerScheduleFilter>;
  /** No related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerScheduleFilter>;
  /** Some related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerScheduleFilter>;
};

export enum Trigger {
  DevTest = 'DEV_TEST',
  Error = 'ERROR',
  OnApplicationCreate = 'ON_APPLICATION_CREATE',
  OnApplicationRestart = 'ON_APPLICATION_RESTART',
  OnApplicationSave = 'ON_APPLICATION_SAVE',
  OnApplicationSubmit = 'ON_APPLICATION_SUBMIT',
  OnApplicationWithdraw = 'ON_APPLICATION_WITHDRAW',
  OnApprovalSubmit = 'ON_APPROVAL_SUBMIT',
  OnExtend = 'ON_EXTEND',
  OnPreview = 'ON_PREVIEW',
  OnReviewAssign = 'ON_REVIEW_ASSIGN',
  OnReviewCreate = 'ON_REVIEW_CREATE',
  OnReviewRestart = 'ON_REVIEW_RESTART',
  OnReviewSubmit = 'ON_REVIEW_SUBMIT',
  OnReviewUnassign = 'ON_REVIEW_UNASSIGN',
  OnSchedule = 'ON_SCHEDULE',
  OnVerification = 'ON_VERIFICATION',
  Processing = 'PROCESSING'
}

/** A filter to be used against Trigger fields. All fields are combined with a logical ‘and.’ */
export type TriggerFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Trigger>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Trigger>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Trigger>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Trigger>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Trigger>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Trigger>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Trigger>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Trigger>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Trigger>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Trigger>>;
};

export type TriggerQueue = Node & {
  __typename?: 'TriggerQueue';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueuesByTriggerEvent: ActionQueuesConnection;
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  data?: Maybe<Scalars['JSON']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  log?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  recordId?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<TriggerQueueStatus>;
  table?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  triggerType?: Maybe<Trigger>;
};


export type TriggerQueueActionQueuesByTriggerEventArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type TriggerQueueApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `TriggerQueueInput` mutation. */
export type TriggerQueueApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerQueueApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `triggerQueue` in the `ApplicationInput` mutation. */
export type TriggerQueueApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerQueueTriggerQueuePkeyConnect>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerQueueNodeIdConnect>>;
  /** A `TriggerQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerQueueApplicationIdFkeyTriggerQueueCreateInput>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerQueueTriggerQueuePkeyDelete>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerQueueNodeIdDelete>>;
  /** Flag indicating whether all other `triggerQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate>>;
};

/** The `triggerQueue` to be created by this mutation. */
export type TriggerQueueApplicationIdFkeyTriggerQueueCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** A condition to be used against `TriggerQueue` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TriggerQueueCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `log` field. */
  log?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<TriggerQueueStatus>;
  /** Checks for equality with the object’s `table` field. */
  table?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `triggerType` field. */
  triggerType?: InputMaybe<Trigger>;
};

/** A filter to be used against `TriggerQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueFilter = {
  /** Filter by the object’s `actionQueuesByTriggerEvent` relation. */
  actionQueuesByTriggerEvent?: InputMaybe<TriggerQueueToManyActionQueueFilter>;
  /** Some related `actionQueuesByTriggerEvent` exist. */
  actionQueuesByTriggerEventExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TriggerQueueFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `log` field. */
  log?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TriggerQueueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TriggerQueueFilter>>;
  /** Filter by the object’s `recordId` field. */
  recordId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<TriggerQueueStatusFilter>;
  /** Filter by the object’s `table` field. */
  table?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `triggerType` field. */
  triggerType?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TriggerQueue` */
export type TriggerQueueInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TriggerQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TriggerQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `triggerQueue` to look up the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `triggerQueue` to look up the row to update. */
export type TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** Represents an update to a `TriggerQueue`. Fields that are set will be updated. */
export type TriggerQueuePatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** A connection to a list of `TriggerQueue` values. */
export type TriggerQueuesConnection = {
  __typename?: 'TriggerQueuesConnection';
  /** A list of edges which contains the `TriggerQueue` and cursor to aid in pagination. */
  edges: Array<TriggerQueuesEdge>;
  /** A list of `TriggerQueue` objects. */
  nodes: Array<Maybe<TriggerQueue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TriggerQueue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TriggerQueue` edge in the connection. */
export type TriggerQueuesEdge = {
  __typename?: 'TriggerQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TriggerQueue` at the end of the edge. */
  node?: Maybe<TriggerQueue>;
};

/** Methods to use when ordering `TriggerQueue`. */
export enum TriggerQueuesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LogAsc = 'LOG_ASC',
  LogDesc = 'LOG_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TableAsc = 'TABLE_ASC',
  TableDesc = 'TABLE_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  TriggerTypeAsc = 'TRIGGER_TYPE_ASC',
  TriggerTypeDesc = 'TRIGGER_TYPE_DESC'
}

export enum TriggerQueueStatus {
  ActionsDispatched = 'ACTIONS_DISPATCHED',
  Completed = 'COMPLETED',
  Error = 'ERROR',
  Triggered = 'TRIGGERED'
}

/** A filter to be used against TriggerQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type TriggerQueueStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TriggerQueueStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TriggerQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TriggerQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TriggerQueueStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TriggerQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TriggerQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TriggerQueueStatus>>;
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** The fields on `triggerQueue` to look up the row to connect. */
export type TriggerQueueTriggerQueuePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `triggerQueue` to look up the row to delete. */
export type TriggerQueueTriggerQueuePkeyDelete = {
  id: Scalars['Int']['input'];
};

export type TriggerSchedule = Node & {
  __typename?: 'TriggerSchedule';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  data?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `User` that is related to this `TriggerSchedule`. */
  editorUser?: Maybe<User>;
  editorUserId?: Maybe<Scalars['Int']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  timeScheduled: Scalars['Datetime']['output'];
  trigger?: Maybe<Trigger>;
};

/** The `application` to be created by this mutation. */
export type TriggerScheduleApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `TriggerScheduleInput` mutation. */
export type TriggerScheduleApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerScheduleApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `triggerSchedule` in the `ApplicationInput` mutation. */
export type TriggerScheduleApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyConnect>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdConnect>>;
  /** A `TriggerScheduleInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyDelete>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdDelete>>;
  /** Flag indicating whether all other `triggerSchedule` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate>>;
};

/** The `triggerSchedule` to be created by this mutation. */
export type TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput = {
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** A condition to be used against `TriggerSchedule` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TriggerScheduleCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `editorUserId` field. */
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeScheduled` field. */
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** Input for the nested mutation of `user` in the `TriggerScheduleInput` mutation. */
export type TriggerScheduleEditorUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerScheduleEditorUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `triggerSchedule` in the `UserInput` mutation. */
export type TriggerScheduleEditorUserIdFkeyInverseInput = {
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyConnect>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdConnect>>;
  /** A `TriggerScheduleInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerScheduleEditorUserIdFkeyTriggerScheduleCreateInput>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyDelete>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdDelete>>;
  /** Flag indicating whether all other `triggerSchedule` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingTriggerSchedulePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyNodeIdUpdate>>;
};

/** The `triggerSchedule` to be created by this mutation. */
export type TriggerScheduleEditorUserIdFkeyTriggerScheduleCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type TriggerScheduleEditorUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A filter to be used against `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type TriggerScheduleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TriggerScheduleFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `editorUser` relation. */
  editorUser?: InputMaybe<UserFilter>;
  /** A related `editorUser` exists. */
  editorUserExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `editorUserId` field. */
  editorUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TriggerScheduleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TriggerScheduleFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeScheduled` field. */
  timeScheduled?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TriggerSchedule` */
export type TriggerScheduleInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TriggerScheduleNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TriggerScheduleNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `triggerSchedule` to look up the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `triggerSchedule` to look up the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingTriggerSchedulePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `triggerSchedule` to look up the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
};

/** Represents an update to a `TriggerSchedule`. Fields that are set will be updated. */
export type TriggerSchedulePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** A connection to a list of `TriggerSchedule` values. */
export type TriggerSchedulesConnection = {
  __typename?: 'TriggerSchedulesConnection';
  /** A list of edges which contains the `TriggerSchedule` and cursor to aid in pagination. */
  edges: Array<TriggerSchedulesEdge>;
  /** A list of `TriggerSchedule` objects. */
  nodes: Array<Maybe<TriggerSchedule>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TriggerSchedule` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TriggerSchedule` edge in the connection. */
export type TriggerSchedulesEdge = {
  __typename?: 'TriggerSchedulesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TriggerSchedule` at the end of the edge. */
  node?: Maybe<TriggerSchedule>;
};

/** Methods to use when ordering `TriggerSchedule`. */
export enum TriggerSchedulesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EditorUserIdAsc = 'EDITOR_USER_ID_ASC',
  EditorUserIdDesc = 'EDITOR_USER_ID_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeScheduledAsc = 'TIME_SCHEDULED_ASC',
  TimeScheduledDesc = 'TIME_SCHEDULED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

/** Input for the nested mutation of `template` in the `TriggerScheduleInput` mutation. */
export type TriggerScheduleTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerScheduleTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `triggerSchedule` in the `TemplateInput` mutation. */
export type TriggerScheduleTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyConnect>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdConnect>>;
  /** A `TriggerScheduleInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyDelete>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdDelete>>;
  /** Flag indicating whether all other `triggerSchedule` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TriggerScheduleTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `triggerSchedule` to be created by this mutation. */
export type TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** The fields on `triggerSchedule` to look up the row to connect. */
export type TriggerScheduleTriggerSchedulePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `triggerSchedule` to look up the row to delete. */
export type TriggerScheduleTriggerSchedulePkeyDelete = {
  id: Scalars['Int']['input'];
};

export enum UiLocation {
  Admin = 'ADMIN',
  Dashboard = 'DASHBOARD',
  List = 'LIST',
  Management = 'MANAGEMENT',
  User = 'USER'
}

/** A filter to be used against UiLocation List fields. All fields are combined with a logical ‘and.’ */
export type UiLocationListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<UiLocation>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<UiLocation>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<UiLocation>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

export type UnnestedSection = {
  __typename?: 'UnnestedSection';
  id?: Maybe<Scalars['Int']['output']>;
  section?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `UnnestedSection` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UnnestedSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `section` field. */
  section?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UnnestedSection` object types. All fields are combined with a logical ‘and.’ */
export type UnnestedSectionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UnnestedSectionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UnnestedSectionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UnnestedSectionFilter>>;
  /** Filter by the object’s `section` field. */
  section?: InputMaybe<StringFilter>;
};

/** A connection to a list of `UnnestedSection` values. */
export type UnnestedSectionsConnection = {
  __typename?: 'UnnestedSectionsConnection';
  /** A list of edges which contains the `UnnestedSection` and cursor to aid in pagination. */
  edges: Array<UnnestedSectionsEdge>;
  /** A list of `UnnestedSection` objects. */
  nodes: Array<Maybe<UnnestedSection>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UnnestedSection` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UnnestedSection` edge in the connection. */
export type UnnestedSectionsEdge = {
  __typename?: 'UnnestedSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UnnestedSection` at the end of the edge. */
  node?: Maybe<UnnestedSection>;
};

/** Methods to use when ordering `UnnestedSection`. */
export enum UnnestedSectionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  SectionAsc = 'SECTION_ASC',
  SectionDesc = 'SECTION_DESC'
}

/** All input for the `updateActionPluginByCode` mutation. */
export type UpdateActionPluginByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** All input for the `updateActionPluginByNodeId` mutation. */
export type UpdateActionPluginByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** All input for the `updateActionPlugin` mutation. */
export type UpdateActionPluginInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayload = {
  __typename?: 'UpdateActionPluginPayload';
  /** The `ActionPlugin` that was updated by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `updateActionQueueByNodeId` mutation. */
export type UpdateActionQueueByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** All input for the `updateActionQueue` mutation. */
export type UpdateActionQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayload = {
  __typename?: 'UpdateActionQueuePayload';
  /** The `ActionQueue` that was updated by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `updateActivityLogByNodeId` mutation. */
export type UpdateActivityLogByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActivityLog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActivityLog` being updated. */
  patch: ActivityLogPatch;
};

/** All input for the `updateActivityLog` mutation. */
export type UpdateActivityLogInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActivityLog` being updated. */
  patch: ActivityLogPatch;
};

/** An object where the defined keys will be set on the `activityLog` being updated. */
export type UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type?: InputMaybe<EventType>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `ActivityLog` mutation. */
export type UpdateActivityLogPayload = {
  __typename?: 'UpdateActivityLogPayload';
  /** The `ActivityLog` that was updated by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ActivityLog` mutation. */
export type UpdateActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the `updateApplicationByNodeId` mutation. */
export type UpdateApplicationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationByOutcomeRegistration` mutation. */
export type UpdateApplicationByOutcomeRegistrationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationBySerial` mutation. */
export type UpdateApplicationBySerialInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
  serial: Scalars['String']['input'];
};

/** All input for the `updateApplication` mutation. */
export type UpdateApplicationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationNoteByNodeId` mutation. */
export type UpdateApplicationNoteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationNote` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** All input for the `updateApplicationNote` mutation. */
export type UpdateApplicationNoteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForApplicationNoteUserIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<ApplicationNoteUserIdFkeyInput>;
};

/** The output of our update `ApplicationNote` mutation. */
export type UpdateApplicationNotePayload = {
  __typename?: 'UpdateApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was updated by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ApplicationNote`. */
  user?: Maybe<User>;
};


/** The output of our update `ApplicationNote` mutation. */
export type UpdateApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnFileForFileApplicationSerialFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The output of our update `Application` mutation. */
export type UpdateApplicationPayload = {
  __typename?: 'UpdateApplicationPayload';
  /** The `Application` that was updated by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
};


/** The output of our update `Application` mutation. */
export type UpdateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `updateApplicationResponseByNodeId` mutation. */
export type UpdateApplicationResponseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** All input for the `updateApplicationResponse` mutation. */
export type UpdateApplicationResponseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayload = {
  __typename?: 'UpdateApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was updated by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `updateApplicationStageHistoryByNodeId` mutation. */
export type UpdateApplicationStageHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** All input for the `updateApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayload = {
  __typename?: 'UpdateApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was updated by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `updateApplicationStatusHistoryByNodeId` mutation. */
export type UpdateApplicationStatusHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** All input for the `updateApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
export type UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayload = {
  __typename?: 'UpdateApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was updated by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `updateCounterByName` mutation. */
export type UpdateCounterByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** All input for the `updateCounterByNodeId` mutation. */
export type UpdateCounterByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Counter` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** All input for the `updateCounter` mutation. */
export type UpdateCounterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** The output of our update `Counter` mutation. */
export type UpdateCounterPayload = {
  __typename?: 'UpdateCounterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was updated by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Counter` mutation. */
export type UpdateCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the `updateDataTableActiveIngredientByNodeId` mutation. */
export type UpdateDataTableActiveIngredientByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableActiveIngredient` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableActiveIngredient` being updated. */
  patch: DataTableActiveIngredientPatch;
};

/** All input for the `updateDataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableActiveIngredient` being updated. */
  patch: DataTableActiveIngredientPatch;
};

/** The output of our update `DataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientPayload = {
  __typename?: 'UpdateDataTableActiveIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was updated by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the `updateDataTableAdministrationRouteByNodeId` mutation. */
export type UpdateDataTableAdministrationRouteByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAdministrationRoute` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAdministrationRoute` being updated. */
  patch: DataTableAdministrationRoutePatch;
};

/** All input for the `updateDataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRouteInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAdministrationRoute` being updated. */
  patch: DataTableAdministrationRoutePatch;
};

/** The output of our update `DataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRoutePayload = {
  __typename?: 'UpdateDataTableAdministrationRoutePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was updated by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the `updateDataTableAnnex2ByNodeId` mutation. */
export type UpdateDataTableAnnex2ByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAnnex2` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAnnex2` being updated. */
  patch: DataTableAnnex2Patch;
};

/** All input for the `updateDataTableAnnex2` mutation. */
export type UpdateDataTableAnnex2Input = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAnnex2` being updated. */
  patch: DataTableAnnex2Patch;
};

/** The output of our update `DataTableAnnex2` mutation. */
export type UpdateDataTableAnnex2Payload = {
  __typename?: 'UpdateDataTableAnnex2Payload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex2` that was updated by this mutation. */
  dataTableAnnex2?: Maybe<DataTableAnnex2>;
  /** An edge for our `DataTableAnnex2`. May be used by Relay 1. */
  dataTableAnnex2Edge?: Maybe<DataTableAnnex2sEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAnnex2` mutation. */
export type UpdateDataTableAnnex2PayloadDataTableAnnex2EdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnex2sOrderBy>>;
};

/** All input for the `updateDataTableAnnexByNodeId` mutation. */
export type UpdateDataTableAnnexByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAnnex` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAnnex` being updated. */
  patch: DataTableAnnexPatch;
};

/** All input for the `updateDataTableAnnex` mutation. */
export type UpdateDataTableAnnexInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAnnex` being updated. */
  patch: DataTableAnnexPatch;
};

/** The output of our update `DataTableAnnex` mutation. */
export type UpdateDataTableAnnexPayload = {
  __typename?: 'UpdateDataTableAnnexPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAnnex` that was updated by this mutation. */
  dataTableAnnex?: Maybe<DataTableAnnex>;
  /** An edge for our `DataTableAnnex`. May be used by Relay 1. */
  dataTableAnnexEdge?: Maybe<DataTableAnnexesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAnnex` mutation. */
export type UpdateDataTableAnnexPayloadDataTableAnnexEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAnnexesOrderBy>>;
};

/** All input for the `updateDataTableAtcCodeByNodeId` mutation. */
export type UpdateDataTableAtcCodeByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcCode` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcCode` being updated. */
  patch: DataTableAtcCodePatch;
};

/** All input for the `updateDataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcCode` being updated. */
  patch: DataTableAtcCodePatch;
};

/** The output of our update `DataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodePayload = {
  __typename?: 'UpdateDataTableAtcCodePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was updated by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the `updateDataTableAtcTherapeuticCategoryByNodeId` mutation. */
export type UpdateDataTableAtcTherapeuticCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcTherapeuticCategory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcTherapeuticCategory` being updated. */
  patch: DataTableAtcTherapeuticCategoryPatch;
};

/** All input for the `updateDataTableAtcTherapeuticCategory` mutation. */
export type UpdateDataTableAtcTherapeuticCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcTherapeuticCategory` being updated. */
  patch: DataTableAtcTherapeuticCategoryPatch;
};

/** The output of our update `DataTableAtcTherapeuticCategory` mutation. */
export type UpdateDataTableAtcTherapeuticCategoryPayload = {
  __typename?: 'UpdateDataTableAtcTherapeuticCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcTherapeuticCategory` that was updated by this mutation. */
  dataTableAtcTherapeuticCategory?: Maybe<DataTableAtcTherapeuticCategory>;
  /** An edge for our `DataTableAtcTherapeuticCategory`. May be used by Relay 1. */
  dataTableAtcTherapeuticCategoryEdge?: Maybe<DataTableAtcTherapeuticCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAtcTherapeuticCategory` mutation. */
export type UpdateDataTableAtcTherapeuticCategoryPayloadDataTableAtcTherapeuticCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcTherapeuticCategoriesOrderBy>>;
};

/** All input for the `updateDataTableByNodeId` mutation. */
export type UpdateDataTableByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTable` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
};

/** All input for the `updateDataTableByTableName` mutation. */
export type UpdateDataTableByTableNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
  tableName: Scalars['String']['input'];
};

/** All input for the `updateDataTableContainerByNodeId` mutation. */
export type UpdateDataTableContainerByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableContainer` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableContainer` being updated. */
  patch: DataTableContainerPatch;
};

/** All input for the `updateDataTableContainer` mutation. */
export type UpdateDataTableContainerInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableContainer` being updated. */
  patch: DataTableContainerPatch;
};

/** The output of our update `DataTableContainer` mutation. */
export type UpdateDataTableContainerPayload = {
  __typename?: 'UpdateDataTableContainerPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was updated by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableContainer` mutation. */
export type UpdateDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the `updateDataTableCountryByNodeId` mutation. */
export type UpdateDataTableCountryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableCountry` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableCountry` being updated. */
  patch: DataTableCountryPatch;
};

/** All input for the `updateDataTableCountry` mutation. */
export type UpdateDataTableCountryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableCountry` being updated. */
  patch: DataTableCountryPatch;
};

/** The output of our update `DataTableCountry` mutation. */
export type UpdateDataTableCountryPayload = {
  __typename?: 'UpdateDataTableCountryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was updated by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableCountry` mutation. */
export type UpdateDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the `updateDataTableDosageFormByNodeId` mutation. */
export type UpdateDataTableDosageFormByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageForm` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageForm` being updated. */
  patch: DataTableDosageFormPatch;
};

/** All input for the `updateDataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageForm` being updated. */
  patch: DataTableDosageFormPatch;
};

/** The output of our update `DataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormPayload = {
  __typename?: 'UpdateDataTableDosageFormPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was updated by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the `updateDataTableGenericIngredientByNodeId` mutation. */
export type UpdateDataTableGenericIngredientByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableGenericIngredient` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableGenericIngredient` being updated. */
  patch: DataTableGenericIngredientPatch;
};

/** All input for the `updateDataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableGenericIngredient` being updated. */
  patch: DataTableGenericIngredientPatch;
};

/** The output of our update `DataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientPayload = {
  __typename?: 'UpdateDataTableGenericIngredientPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was updated by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the `updateDataTableIngredientsListByNodeId` mutation. */
export type UpdateDataTableIngredientsListByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableIngredientsList` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableIngredientsList` being updated. */
  patch: DataTableIngredientsListPatch;
};

/** All input for the `updateDataTableIngredientsList` mutation. */
export type UpdateDataTableIngredientsListInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableIngredientsList` being updated. */
  patch: DataTableIngredientsListPatch;
};

/** The output of our update `DataTableIngredientsList` mutation. */
export type UpdateDataTableIngredientsListPayload = {
  __typename?: 'UpdateDataTableIngredientsListPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableIngredientsList` that was updated by this mutation. */
  dataTableIngredientsList?: Maybe<DataTableIngredientsList>;
  /** An edge for our `DataTableIngredientsList`. May be used by Relay 1. */
  dataTableIngredientsListEdge?: Maybe<DataTableIngredientsListsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableIngredientsList` mutation. */
export type UpdateDataTableIngredientsListPayloadDataTableIngredientsListEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableIngredientsListsOrderBy>>;
};

/** All input for the `updateDataTable` mutation. */
export type UpdateDataTableInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
};

/** All input for the `updateDataTableListOfSraByNodeId` mutation. */
export type UpdateDataTableListOfSraByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableListOfSra` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableListOfSra` being updated. */
  patch: DataTableListOfSraPatch;
};

/** All input for the `updateDataTableListOfSra` mutation. */
export type UpdateDataTableListOfSraInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableListOfSra` being updated. */
  patch: DataTableListOfSraPatch;
};

/** The output of our update `DataTableListOfSra` mutation. */
export type UpdateDataTableListOfSraPayload = {
  __typename?: 'UpdateDataTableListOfSraPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableListOfSra` that was updated by this mutation. */
  dataTableListOfSra?: Maybe<DataTableListOfSra>;
  /** An edge for our `DataTableListOfSra`. May be used by Relay 1. */
  dataTableListOfSraEdge?: Maybe<DataTableListOfSrasEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableListOfSra` mutation. */
export type UpdateDataTableListOfSraPayloadDataTableListOfSraEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableListOfSrasOrderBy>>;
};

/** All input for the `updateDataTableManufacturingStepByNodeId` mutation. */
export type UpdateDataTableManufacturingStepByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturingStep` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturingStep` being updated. */
  patch: DataTableManufacturingStepPatch;
};

/** All input for the `updateDataTableManufacturingStep` mutation. */
export type UpdateDataTableManufacturingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturingStep` being updated. */
  patch: DataTableManufacturingStepPatch;
};

/** The output of our update `DataTableManufacturingStep` mutation. */
export type UpdateDataTableManufacturingStepPayload = {
  __typename?: 'UpdateDataTableManufacturingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturingStep` that was updated by this mutation. */
  dataTableManufacturingStep?: Maybe<DataTableManufacturingStep>;
  /** An edge for our `DataTableManufacturingStep`. May be used by Relay 1. */
  dataTableManufacturingStepEdge?: Maybe<DataTableManufacturingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableManufacturingStep` mutation. */
export type UpdateDataTableManufacturingStepPayloadDataTableManufacturingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturingStepsOrderBy>>;
};

/** The output of our update `DataTable` mutation. */
export type UpdateDataTablePayload = {
  __typename?: 'UpdateDataTablePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was updated by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTable` mutation. */
export type UpdateDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the `updateDataTableProcessingStepByNodeId` mutation. */
export type UpdateDataTableProcessingStepByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProcessingStep` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProcessingStep` being updated. */
  patch: DataTableProcessingStepPatch;
};

/** All input for the `updateDataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProcessingStep` being updated. */
  patch: DataTableProcessingStepPatch;
};

/** The output of our update `DataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepPayload = {
  __typename?: 'UpdateDataTableProcessingStepPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was updated by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the `updateDataTableProductApplicationJoinByNodeId` mutation. */
export type UpdateDataTableProductApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProductApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** All input for the `updateDataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
export type UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
export type UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductToDataTableProductId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our update `DataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinPayload = {
  __typename?: 'UpdateDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProduct` that is related to this `DataTableProductApplicationJoin`. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** The `DataTableProductApplicationJoin` that was updated by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTableProductByNodeId` mutation. */
export type UpdateDataTableProductByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProduct` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProduct` being updated. */
  patch: DataTableProductPatch;
};

/** All input for the `updateDataTableProduct` mutation. */
export type UpdateDataTableProductInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProduct` being updated. */
  patch: DataTableProductPatch;
};

/** An object where the defined keys will be set on the `dataTableProduct` being updated. */
export type UpdateDataTableProductOnDataTableProductApplicationJoinForDataTableProductApplicationJoinDataTableProductIdFkeyPatch = {
  administrationRoute?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  applicantName?: InputMaybe<Scalars['String']['input']>;
  applicationType?: InputMaybe<Scalars['String']['input']>;
  atcClass?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinDataTableProductIdFkeyInverseInput>;
  dimensions?: InputMaybe<Scalars['JSON']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  formulations?: InputMaybe<Scalars['JSON']['input']>;
  genericNames?: InputMaybe<Scalars['JSON']['input']>;
  genericNamesFilterData?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isLocallyManufactured?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturersList?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersListFilterData?: InputMaybe<Scalars['String']['input']>;
  medicineType?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  origin?: InputMaybe<Scalars['String']['input']>;
  prescription?: InputMaybe<Scalars['String']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  responsiblePerson?: InputMaybe<Scalars['JSON']['input']>;
  shelfLifeOpened?: InputMaybe<Scalars['String']['input']>;
  shelfLifeProposed?: InputMaybe<Scalars['String']['input']>;
  shelfLifeReconstructed?: InputMaybe<Scalars['String']['input']>;
  storageConditionsOpened?: InputMaybe<Scalars['String']['input']>;
  storageConditionsProposed?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `DataTableProduct` mutation. */
export type UpdateDataTableProductPayload = {
  __typename?: 'UpdateDataTableProductPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was updated by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProduct` mutation. */
export type UpdateDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the `updateDataTableProvinceByNodeId` mutation. */
export type UpdateDataTableProvinceByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvince` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProvince` being updated. */
  patch: DataTableProvincePatch;
};

/** All input for the `updateDataTableProvince` mutation. */
export type UpdateDataTableProvinceInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProvince` being updated. */
  patch: DataTableProvincePatch;
};

/** The output of our update `DataTableProvince` mutation. */
export type UpdateDataTableProvincePayload = {
  __typename?: 'UpdateDataTableProvincePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvince` that was updated by this mutation. */
  dataTableProvince?: Maybe<DataTableProvince>;
  /** An edge for our `DataTableProvince`. May be used by Relay 1. */
  dataTableProvinceEdge?: Maybe<DataTableProvincesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProvince` mutation. */
export type UpdateDataTableProvincePayloadDataTableProvinceEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvincesOrderBy>>;
};

/** All input for the `updateDataTableStorageConditionByNodeId` mutation. */
export type UpdateDataTableStorageConditionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageCondition` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageCondition` being updated. */
  patch: DataTableStorageConditionPatch;
};

/** All input for the `updateDataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageCondition` being updated. */
  patch: DataTableStorageConditionPatch;
};

/** The output of our update `DataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionPayload = {
  __typename?: 'UpdateDataTableStorageConditionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was updated by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the `updateDataTableUnitsOfProportionByNodeId` mutation. */
export type UpdateDataTableUnitsOfProportionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableUnitsOfProportion` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableUnitsOfProportion` being updated. */
  patch: DataTableUnitsOfProportionPatch;
};

/** All input for the `updateDataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableUnitsOfProportion` being updated. */
  patch: DataTableUnitsOfProportionPatch;
};

/** The output of our update `DataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionPayload = {
  __typename?: 'UpdateDataTableUnitsOfProportionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was updated by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the `updateDataViewByIdentifier` mutation. */
export type UpdateDataViewByIdentifierInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  identifier: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** All input for the `updateDataViewByNodeId` mutation. */
export type UpdateDataViewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataView` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** All input for the `updateDataViewColumnDefinitionByNodeId` mutation. */
export type UpdateDataViewColumnDefinitionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataViewColumnDefinition` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
};

/** All input for the `updateDataViewColumnDefinitionByTableNameAndColumnName` mutation. */
export type UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  columnName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
  tableName: Scalars['String']['input'];
};

/** All input for the `updateDataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
};

/** The output of our update `DataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionPayload = {
  __typename?: 'UpdateDataViewColumnDefinitionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was updated by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the `updateDataView` mutation. */
export type UpdateDataViewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** The output of our update `DataView` mutation. */
export type UpdateDataViewPayload = {
  __typename?: 'UpdateDataViewPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was updated by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataView` mutation. */
export type UpdateDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the `updateElementTypePluginByNodeId` mutation. */
export type UpdateElementTypePluginByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
};

/** All input for the `updateElementTypePlugin` mutation. */
export type UpdateElementTypePluginInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
};

/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayload = {
  __typename?: 'UpdateElementTypePluginPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ElementTypePlugin` that was updated by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `updateFileByNodeId` mutation. */
export type UpdateFileByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** All input for the `updateFileByUniqueId` mutation. */
export type UpdateFileByUniqueIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `updateFile` mutation. */
export type UpdateFileInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationNoteIdFkeyPatch = {
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationResponseIdFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationSerialFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileTemplateIdFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileUserIdFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FileUserIdFkeyInput>;
};

/** The output of our update `File` mutation. */
export type UpdateFilePayload = {
  __typename?: 'UpdateFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `File` that was updated by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
};


/** The output of our update `File` mutation. */
export type UpdateFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the `updateFilterByCode` mutation. */
export type UpdateFilterByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** All input for the `updateFilterByNodeId` mutation. */
export type UpdateFilterByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Filter` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** All input for the `updateFilter` mutation. */
export type UpdateFilterInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** An object where the defined keys will be set on the `filter` being updated. */
export type UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** The output of our update `Filter` mutation. */
export type UpdateFilterPayload = {
  __typename?: 'UpdateFilterPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was updated by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Filter` mutation. */
export type UpdateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `updateNotificationByNodeId` mutation. */
export type UpdateNotificationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** All input for the `updateNotification` mutation. */
export type UpdateNotificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userToUserId?: InputMaybe<NotificationUserIdFkeyInput>;
};

/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayload = {
  __typename?: 'UpdateNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
};


/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `updateOrganisationApplicationJoinByNodeId` mutation. */
export type UpdateOrganisationApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganisationApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OrganisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** All input for the `updateOrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `OrganisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
export type UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
export type UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** The output of our update `OrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinPayload = {
  __typename?: 'UpdateOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was updated by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `OrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `updateOrganisationByName` mutation. */
export type UpdateOrganisationByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** All input for the `updateOrganisationByNodeId` mutation. */
export type UpdateOrganisationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** All input for the `updateOrganisationByRegistration` mutation. */
export type UpdateOrganisationByRegistrationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
  registration: Scalars['String']['input'];
};

/** All input for the `updateOrganisation` mutation. */
export type UpdateOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayload = {
  __typename?: 'UpdateOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organisation` that was updated by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `updatePermissionJoinByNodeId` mutation. */
export type UpdatePermissionJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** All input for the `updatePermissionJoin` mutation. */
export type UpdatePermissionJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userToUserId?: InputMaybe<PermissionJoinUserIdFkeyInput>;
};

/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayload = {
  __typename?: 'UpdatePermissionJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was updated by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
};


/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `updatePermissionNameByName` mutation. */
export type UpdatePermissionNameByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** All input for the `updatePermissionNameByNodeId` mutation. */
export type UpdatePermissionNameByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** All input for the `updatePermissionName` mutation. */
export type UpdatePermissionNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayload = {
  __typename?: 'UpdatePermissionNamePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionName` that was updated by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `updatePermissionPolicyByName` mutation. */
export type UpdatePermissionPolicyByNameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** All input for the `updatePermissionPolicyByNodeId` mutation. */
export type UpdatePermissionPolicyByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** All input for the `updatePermissionPolicy` mutation. */
export type UpdatePermissionPolicyInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** An object where the defined keys will be set on the `permissionPolicy` being updated. */
export type UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayload = {
  __typename?: 'UpdatePermissionPolicyPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionPolicy` that was updated by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `updateProductApplicationJoinByNodeId` mutation. */
export type UpdateProductApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ProductApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ProductApplicationJoin` being updated. */
  patch: ProductApplicationJoinPatch;
};

/** All input for the `updateProductApplicationJoin` mutation. */
export type UpdateProductApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ProductApplicationJoin` being updated. */
  patch: ProductApplicationJoinPatch;
};

/** An object where the defined keys will be set on the `productApplicationJoin` being updated. */
export type UpdateProductApplicationJoinOnProductApplicationJoinForProductApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  productId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our update `ProductApplicationJoin` mutation. */
export type UpdateProductApplicationJoinPayload = {
  __typename?: 'UpdateProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `ProductApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ProductApplicationJoin` that was updated by this mutation. */
  productApplicationJoin?: Maybe<ProductApplicationJoin>;
  /** An edge for our `ProductApplicationJoin`. May be used by Relay 1. */
  productApplicationJoinEdge?: Maybe<ProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ProductApplicationJoin` mutation. */
export type UpdateProductApplicationJoinPayloadProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductApplicationJoinsOrderBy>>;
};

/** All input for the `updateReviewAssignmentAssignerJoinByNodeId` mutation. */
export type UpdateReviewAssignmentAssignerJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignmentAssignerJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** All input for the `updateReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInput>;
};

/** The output of our update `ReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinPayload = {
  __typename?: 'UpdateReviewAssignmentAssignerJoinPayload';
  /** Reads a single `User` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was updated by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our update `ReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the `updateReviewAssignmentByNodeId` mutation. */
export type UpdateReviewAssignmentByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** All input for the `updateReviewAssignment` mutation. */
export type UpdateReviewAssignmentInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToAssignerId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInput>;
};

/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayload = {
  __typename?: 'UpdateReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was updated by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `updateReviewByNodeId` mutation. */
export type UpdateReviewByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Review` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
};

/** All input for the `updateReviewByReviewAssignmentId` mutation. */
export type UpdateReviewByReviewAssignmentIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** All input for the `updateReviewDecisionByNodeId` mutation. */
export type UpdateReviewDecisionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** All input for the `updateReviewDecision` mutation. */
export type UpdateReviewDecisionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** An object where the defined keys will be set on the `reviewDecision` being updated. */
export type UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayload = {
  __typename?: 'UpdateReviewDecisionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was updated by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `updateReview` mutation. */
export type UpdateReviewInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewReviewerIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToReviewerId?: InputMaybe<ReviewReviewerIdFkeyInput>;
};

/** The output of our update `Review` mutation. */
export type UpdateReviewPayload = {
  __typename?: 'UpdateReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was updated by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
};


/** The output of our update `Review` mutation. */
export type UpdateReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `updateReviewResponseByNodeId` mutation. */
export type UpdateReviewResponseByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** All input for the `updateReviewResponse` mutation. */
export type UpdateReviewResponseInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayload = {
  __typename?: 'UpdateReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was updated by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `updateReviewStatusHistoryByNodeId` mutation. */
export type UpdateReviewStatusHistoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** All input for the `updateReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
export type UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayload = {
  __typename?: 'UpdateReviewStatusHistoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was updated by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `updateSystemInfoByNodeId` mutation. */
export type UpdateSystemInfoByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemInfo` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SystemInfo` being updated. */
  patch: SystemInfoPatch;
};

/** All input for the `updateSystemInfo` mutation. */
export type UpdateSystemInfoInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SystemInfo` being updated. */
  patch: SystemInfoPatch;
};

/** The output of our update `SystemInfo` mutation. */
export type UpdateSystemInfoPayload = {
  __typename?: 'UpdateSystemInfoPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was updated by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our update `SystemInfo` mutation. */
export type UpdateSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the `updateTemplateActionByNodeId` mutation. */
export type UpdateTemplateActionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
};

/** All input for the `updateTemplateAction` mutation. */
export type UpdateTemplateActionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
};

/** An object where the defined keys will be set on the `templateAction` being updated. */
export type UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayload = {
  __typename?: 'UpdateTemplateActionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was updated by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `updateTemplateByCodeAndVersionId` mutation. */
export type UpdateTemplateByCodeAndVersionIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
  versionId: Scalars['String']['input'];
};

/** All input for the `updateTemplateByNodeId` mutation. */
export type UpdateTemplateByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Template` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
};

/** All input for the `updateTemplateCategoryByCode` mutation. */
export type UpdateTemplateCategoryByCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** All input for the `updateTemplateCategoryByNodeId` mutation. */
export type UpdateTemplateCategoryByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateCategory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** All input for the `updateTemplateCategory` mutation. */
export type UpdateTemplateCategoryInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** An object where the defined keys will be set on the `templateCategory` being updated. */
export type UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The output of our update `TemplateCategory` mutation. */
export type UpdateTemplateCategoryPayload = {
  __typename?: 'UpdateTemplateCategoryPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was updated by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our update `TemplateCategory` mutation. */
export type UpdateTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the `updateTemplateElementByNodeId` mutation. */
export type UpdateTemplateElementByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
};

/** All input for the `updateTemplateElementByTemplateCodeAndCodeAndTemplateVersion` mutation. */
export type UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** All input for the `updateTemplateElement` mutation. */
export type UpdateTemplateElementInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewability?: InputMaybe<Reviewability>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayload = {
  __typename?: 'UpdateTemplateElementPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was updated by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `updateTemplateFilterJoinByNodeId` mutation. */
export type UpdateTemplateFilterJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateFilterJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** All input for the `updateTemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
export type UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch = {
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
export type UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** The output of our update `TemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinPayload = {
  __typename?: 'UpdateTemplateFilterJoinPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was updated by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our update `TemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the `updateTemplate` mutation. */
export type UpdateTemplateInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnFileForFileTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our update `Template` mutation. */
export type UpdateTemplatePayload = {
  __typename?: 'UpdateTemplatePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was updated by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our update `Template` mutation. */
export type UpdateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `updateTemplatePermissionByNodeId` mutation. */
export type UpdateTemplatePermissionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** All input for the `updateTemplatePermission` mutation. */
export type UpdateTemplatePermissionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayload = {
  __typename?: 'UpdateTemplatePermissionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was updated by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `updateTemplateSectionByNodeId` mutation. */
export type UpdateTemplateSectionByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** All input for the `updateTemplateSectionByTemplateIdAndCode` mutation. */
export type UpdateTemplateSectionByTemplateIdAndCodeInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
  templateId: Scalars['Int']['input'];
};

/** All input for the `updateTemplateSection` mutation. */
export type UpdateTemplateSectionInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayload = {
  __typename?: 'UpdateTemplateSectionPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was updated by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `updateTemplateStageByNodeId` mutation. */
export type UpdateTemplateStageByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
};

/** All input for the `updateTemplateStage` mutation. */
export type UpdateTemplateStageInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayload = {
  __typename?: 'UpdateTemplateStagePayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was updated by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `updateTemplateStageReviewLevelByNodeId` mutation. */
export type UpdateTemplateStageReviewLevelByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStageReviewLevel` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** All input for the `updateTemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
export type UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
export type UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The output of our update `TemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelPayload = {
  __typename?: 'UpdateTemplateStageReviewLevelPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was updated by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our update `TemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the `updateTriggerQueueByNodeId` mutation. */
export type UpdateTriggerQueueByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** All input for the `updateTriggerQueue` mutation. */
export type UpdateTriggerQueueInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** An object where the defined keys will be set on the `triggerQueue` being updated. */
export type UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `triggerQueue` being updated. */
export type UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayload = {
  __typename?: 'UpdateTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was updated by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `updateTriggerScheduleByNodeId` mutation. */
export type UpdateTriggerScheduleByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerSchedule` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TriggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** All input for the `updateTriggerSchedule` mutation. */
export type UpdateTriggerScheduleInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TriggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** An object where the defined keys will be set on the `triggerSchedule` being updated. */
export type UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `triggerSchedule` being updated. */
export type UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `triggerSchedule` being updated. */
export type UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userToEditorUserId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInput>;
};

/** The output of our update `TriggerSchedule` mutation. */
export type UpdateTriggerSchedulePayload = {
  __typename?: 'UpdateTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `TriggerSchedule`. */
  editorUser?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was updated by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our update `TriggerSchedule` mutation. */
export type UpdateTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the `updateUserApplicationJoinByNodeId` mutation. */
export type UpdateUserApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** All input for the `updateUserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
export type UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
export type UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** The output of our update `UserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinPayload = {
  __typename?: 'UpdateUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserApplicationJoin`. */
  user?: Maybe<User>;
  /** The `UserApplicationJoin` that was updated by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our update `UserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  username: Scalars['String']['input'];
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnApplicationForApplicationUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnApplicationNoteForApplicationNoteUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnFileForFileUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnNotificationForNotificationUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewForReviewReviewerIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** All input for the `updateUserOrganisationApplicationJoinByNodeId` mutation. */
export type UpdateUserOrganisationApplicationJoinByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisationApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserOrganisationApplicationJoin` being updated. */
  patch: UserOrganisationApplicationJoinPatch;
};

/** All input for the `updateUserOrganisationApplicationJoin` mutation. */
export type UpdateUserOrganisationApplicationJoinInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserOrganisationApplicationJoin` being updated. */
  patch: UserOrganisationApplicationJoinPatch;
};

/** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
export type UpdateUserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
export type UpdateUserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** The output of our update `UserOrganisationApplicationJoin` mutation. */
export type UpdateUserOrganisationApplicationJoinPayload = {
  __typename?: 'UpdateUserOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserOrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserOrganisation` that is related to this `UserOrganisationApplicationJoin`. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** The `UserOrganisationApplicationJoin` that was updated by this mutation. */
  userOrganisationApplicationJoin?: Maybe<UserOrganisationApplicationJoin>;
  /** An edge for our `UserOrganisationApplicationJoin`. May be used by Relay 1. */
  userOrganisationApplicationJoinEdge?: Maybe<UserOrganisationApplicationJoinsEdge>;
};


/** The output of our update `UserOrganisationApplicationJoin` mutation. */
export type UpdateUserOrganisationApplicationJoinPayloadUserOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `updateUserOrganisationByNodeId` mutation. */
export type UpdateUserOrganisationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** All input for the `updateUserOrganisationByUserIdAndOrganisationId` mutation. */
export type UpdateUserOrganisationByUserIdAndOrganisationIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organisationId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
  userId: Scalars['Int']['input'];
};

/** All input for the `updateUserOrganisation` mutation. */
export type UpdateUserOrganisationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayload = {
  __typename?: 'UpdateUserOrganisationPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was updated by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateVerificationByNodeId` mutation. */
export type UpdateVerificationByNodeIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Verification` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
};

/** All input for the `updateVerificationByUniqueId` mutation. */
export type UpdateVerificationByUniqueIdInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `updateVerification` mutation. */
export type UpdateVerificationInput = {
  /** An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
};

/** An object where the defined keys will be set on the `verification` being updated. */
export type UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our update `Verification` mutation. */
export type UpdateVerificationPayload = {
  __typename?: 'UpdateVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /** The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was updated by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our update `Verification` mutation. */
export type UpdateVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type User = Node & {
  __typename?: 'User';
  address?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotes: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applications: ApplicationsConnection;
  country?: Maybe<Scalars['String']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  firstName?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  passwordHash?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoinsByAssignerId: ReviewAssignmentAssignerJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByAssignerId: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewedReviewAssignments: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `Review`. */
  reviewedReviews: ReviewsConnection;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedulesByEditorUserId: TriggerSchedulesConnection;
  /** Reads and enables pagination through a set of `UserApplicationJoin`. */
  userApplicationJoins: UserApplicationJoinsConnection;
  username?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
};


export type UserApplicationNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type UserApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type UserFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type UserNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


export type UserPermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type UserReviewAssignmentAssignerJoinsByAssignerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type UserReviewAssignmentsByAssignerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type UserReviewedReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type UserReviewedReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};


export type UserTriggerSchedulesByEditorUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};


export type UserUserApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserApplicationJoinCondition>;
  filter?: InputMaybe<UserApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};


export type UserUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

export type UserApplicationJoin = Node & {
  __typename?: 'UserApplicationJoin';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `User` that is related to this `UserApplicationJoin`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type UserApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `UserApplicationJoinInput` mutation. */
export type UserApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `userApplicationJoin` in the `ApplicationInput` mutation. */
export type UserApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdConnect>>;
  /** A `UserApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `userApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `userApplicationJoin` to be created by this mutation. */
export type UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** A condition to be used against `UserApplicationJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserApplicationJoinFilter>>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserApplicationJoin` */
export type UserApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `userApplicationJoin` to look up the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userApplicationJoin` to look up the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyPatch;
};

/** Represents an update to a `UserApplicationJoin`. Fields that are set will be updated. */
export type UserApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** A connection to a list of `UserApplicationJoin` values. */
export type UserApplicationJoinsConnection = {
  __typename?: 'UserApplicationJoinsConnection';
  /** A list of edges which contains the `UserApplicationJoin` and cursor to aid in pagination. */
  edges: Array<UserApplicationJoinsEdge>;
  /** A list of `UserApplicationJoin` objects. */
  nodes: Array<Maybe<UserApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserApplicationJoin` edge in the connection. */
export type UserApplicationJoinsEdge = {
  __typename?: 'UserApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserApplicationJoin` at the end of the edge. */
  node?: Maybe<UserApplicationJoin>;
};

/** Methods to use when ordering `UserApplicationJoin`. */
export enum UserApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The fields on `userApplicationJoin` to look up the row to connect. */
export type UserApplicationJoinUserApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userApplicationJoin` to look up the row to delete. */
export type UserApplicationJoinUserApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `user` in the `UserApplicationJoinInput` mutation. */
export type UserApplicationJoinUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserApplicationJoinUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `userApplicationJoin` in the `UserInput` mutation. */
export type UserApplicationJoinUserIdFkeyInverseInput = {
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdConnect>>;
  /** A `UserApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserApplicationJoinUserIdFkeyUserApplicationJoinCreateInput>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `userApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyNodeIdUpdate>>;
};

/** The `userApplicationJoin` to be created by this mutation. */
export type UserApplicationJoinUserIdFkeyUserApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userToUserId?: InputMaybe<UserApplicationJoinUserIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type UserApplicationJoinUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `province` field. */
  province?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `applicationNotes` relation. */
  applicationNotes?: InputMaybe<UserToManyApplicationNoteFilter>;
  /** Some related `applicationNotes` exist. */
  applicationNotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applications` relation. */
  applications?: InputMaybe<UserToManyApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<UserToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: InputMaybe<UserToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: InputMaybe<UserToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `province` field. */
  province?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `reviewAssignmentAssignerJoinsByAssignerId` relation. */
  reviewAssignmentAssignerJoinsByAssignerId?: InputMaybe<UserToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoinsByAssignerId` exist. */
  reviewAssignmentAssignerJoinsByAssignerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignmentsByAssignerId` relation. */
  reviewAssignmentsByAssignerId?: InputMaybe<UserToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByAssignerId` exist. */
  reviewAssignmentsByAssignerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewedReviewAssignments` relation. */
  reviewedReviewAssignments?: InputMaybe<UserToManyReviewAssignmentFilter>;
  /** Some related `reviewedReviewAssignments` exist. */
  reviewedReviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewedReviews` relation. */
  reviewedReviews?: InputMaybe<UserToManyReviewFilter>;
  /** Some related `reviewedReviews` exist. */
  reviewedReviewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `triggerSchedulesByEditorUserId` relation. */
  triggerSchedulesByEditorUserId?: InputMaybe<UserToManyTriggerScheduleFilter>;
  /** Some related `triggerSchedulesByEditorUserId` exist. */
  triggerSchedulesByEditorUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userApplicationJoins` relation. */
  userApplicationJoins?: InputMaybe<UserToManyUserApplicationJoinFilter>;
  /** Some related `userApplicationJoins` exist. */
  userApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: InputMaybe<UserToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `user` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnApplicationNoteForApplicationNoteUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationNoteForApplicationNoteUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationNoteForApplicationNoteUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationNoteForApplicationNoteUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationNoteForApplicationNoteUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnFileForFileUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnFileForFileUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnFileForFileUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinAssignerIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTriggerScheduleForTriggerScheduleEditorUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserApplicationJoinForUserApplicationJoinUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  username: Scalars['String']['input'];
};

export type UserOrganisation = Node & {
  __typename?: 'UserOrganisation';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  organisationId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `UserOrganisationApplicationJoin`. */
  userOrganisationApplicationJoins: UserOrganisationApplicationJoinsConnection;
  userRole?: Maybe<Scalars['String']['output']>;
};


export type UserOrganisationUserOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationApplicationJoinCondition>;
  filter?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationApplicationJoinsOrderBy>>;
};

export type UserOrganisationApplicationJoin = Node & {
  __typename?: 'UserOrganisationApplicationJoin';
  /** Reads a single `Application` that is related to this `UserOrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `UserOrganisation` that is related to this `UserOrganisationApplicationJoin`. */
  userOrganisation?: Maybe<UserOrganisation>;
  userOrganisationId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type UserOrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `UserOrganisationApplicationJoinInput` mutation. */
export type UserOrganisationApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `userOrganisationApplicationJoin` in the `ApplicationInput` mutation. */
export type UserOrganisationApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationApplicationJoinNodeIdConnect>>;
  /** A `UserOrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserOrganisationApplicationJoinApplicationIdFkeyUserOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `userOrganisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingUserOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `userOrganisationApplicationJoin` to be created by this mutation. */
export type UserOrganisationApplicationJoinApplicationIdFkeyUserOrganisationApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** A condition to be used against `UserOrganisationApplicationJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserOrganisationApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userOrganisationId` field. */
  userOrganisationId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserOrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserOrganisationApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserOrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserOrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `userOrganisation` relation. */
  userOrganisation?: InputMaybe<UserOrganisationFilter>;
  /** Filter by the object’s `userOrganisationId` field. */
  userOrganisationId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserOrganisationApplicationJoin` */
export type UserOrganisationApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserOrganisationApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userOrganisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserOrganisationApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userOrganisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `userOrganisationApplicationJoin` to look up the row to update. */
export type UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyUsingUserOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
  patch: UpdateUserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `userOrganisationApplicationJoin` to look up the row to update. */
export type UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
  patch: UpdateUserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyPatch;
};

/** Represents an update to a `UserOrganisationApplicationJoin`. Fields that are set will be updated. */
export type UserOrganisationApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** A connection to a list of `UserOrganisationApplicationJoin` values. */
export type UserOrganisationApplicationJoinsConnection = {
  __typename?: 'UserOrganisationApplicationJoinsConnection';
  /** A list of edges which contains the `UserOrganisationApplicationJoin` and cursor to aid in pagination. */
  edges: Array<UserOrganisationApplicationJoinsEdge>;
  /** A list of `UserOrganisationApplicationJoin` objects. */
  nodes: Array<Maybe<UserOrganisationApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrganisationApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserOrganisationApplicationJoin` edge in the connection. */
export type UserOrganisationApplicationJoinsEdge = {
  __typename?: 'UserOrganisationApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserOrganisationApplicationJoin` at the end of the edge. */
  node?: Maybe<UserOrganisationApplicationJoin>;
};

/** Methods to use when ordering `UserOrganisationApplicationJoin`. */
export enum UserOrganisationApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserOrganisationIdAsc = 'USER_ORGANISATION_ID_ASC',
  UserOrganisationIdDesc = 'USER_ORGANISATION_ID_DESC'
}

/** The fields on `userOrganisationApplicationJoin` to look up the row to connect. */
export type UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userOrganisationApplicationJoin` to look up the row to delete. */
export type UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `userOrganisation` in the `UserOrganisationApplicationJoinInput` mutation. */
export type UserOrganisationApplicationJoinUserOrganisationIdFkeyInput = {
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: InputMaybe<UserOrganisationUserOrganisationPkeyConnect>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserOrganisationNodeIdConnect>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByUserIdAndOrganisationId?: InputMaybe<UserOrganisationUserOrganisationUserIdOrganisationIdKeyConnect>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyUserOrganisationCreateInput>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: InputMaybe<UserOrganisationUserOrganisationPkeyDelete>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserOrganisationNodeIdDelete>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByUserIdAndOrganisationId?: InputMaybe<UserOrganisationUserOrganisationUserIdOrganisationIdKeyDelete>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: InputMaybe<UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByUserIdAndOrganisationId?: InputMaybe<UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate>;
};

/** Input for the nested mutation of `userOrganisationApplicationJoin` in the `UserOrganisationInput` mutation. */
export type UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationApplicationJoinNodeIdConnect>>;
  /** A `UserOrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserOrganisationApplicationJoinUserOrganisationIdFkeyUserOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationApplicationJoinUserOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `userOrganisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `userOrganisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationApplicationJoinOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `userOrganisationApplicationJoin` to be created by this mutation. */
export type UserOrganisationApplicationJoinUserOrganisationIdFkeyUserOrganisationApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationToUserOrganisationId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationApplicationJoinUserOrganisationIdFkeyUserOrganisationCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** A condition to be used against `UserOrganisation` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserOrganisationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserOrganisationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserOrganisationFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserOrganisationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserOrganisationFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userOrganisationApplicationJoins` relation. */
  userOrganisationApplicationJoins?: InputMaybe<UserOrganisationToManyUserOrganisationApplicationJoinFilter>;
  /** Some related `userOrganisationApplicationJoins` exist. */
  userOrganisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `UserOrganisation` */
export type UserOrganisationInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserOrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserOrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisationApplicationJoin` being updated. */
  patch: UserOrganisationApplicationJoinPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate = {
  organisationId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationApplicationJoinForUserOrganisationApplicationJoinUserOrganisationIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate = {
  organisationId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate = {
  organisationId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** Input for the nested mutation of `organisation` in the `UserOrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserOrganisationOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `userOrganisation` in the `OrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationNodeIdConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationUserOrganisationUserIdOrganisationIdKeyConnect>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationNodeIdDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationUserOrganisationUserIdOrganisationIdKeyDelete>>;
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  agent?: InputMaybe<Scalars['JSON']['input']>;
  agentId?: InputMaybe<Scalars['Int']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  authorisation?: InputMaybe<Scalars['JSON']['input']>;
  contact?: InputMaybe<Scalars['JSON']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  postalCountry?: InputMaybe<Scalars['String']['input']>;
  postalProvince?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** Represents an update to a `UserOrganisation`. Fields that are set will be updated. */
export type UserOrganisationPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** A connection to a list of `UserOrganisation` values. */
export type UserOrganisationsConnection = {
  __typename?: 'UserOrganisationsConnection';
  /** A list of edges which contains the `UserOrganisation` and cursor to aid in pagination. */
  edges: Array<UserOrganisationsEdge>;
  /** A list of `UserOrganisation` objects. */
  nodes: Array<Maybe<UserOrganisation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrganisation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserOrganisation` edge in the connection. */
export type UserOrganisationsEdge = {
  __typename?: 'UserOrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserOrganisation` at the end of the edge. */
  node?: Maybe<UserOrganisation>;
};

/** Methods to use when ordering `UserOrganisation`. */
export enum UserOrganisationsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** A filter to be used against many `UserOrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserOrganisationToManyUserOrganisationApplicationJoinFilter = {
  /** Every related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  /** No related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationApplicationJoinFilter>;
  /** Some related `UserOrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationApplicationJoinFilter>;
};

/** Input for the nested mutation of `user` in the `UserOrganisationInput` mutation. */
export type UserOrganisationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: InputMaybe<UserUserUsernameKeyConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserOrganisationUserIdFkeyUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<UserNodeIdDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: InputMaybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: InputMaybe<UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate>;
};

/** Input for the nested mutation of `userOrganisation` in the `UserInput` mutation. */
export type UserOrganisationUserIdFkeyInverseInput = {
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationNodeIdConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationUserOrganisationUserIdOrganisationIdKeyConnect>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserOrganisationUserIdFkeyUserOrganisationCreateInput>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationNodeIdDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationUserOrganisationUserIdOrganisationIdKeyDelete>>;
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByUserIdAndOrganisationId?: InputMaybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationUserIdOrganisationIdKeyUpdate>>;
};

/** The `user` to be created by this mutation. */
export type UserOrganisationUserIdFkeyUserCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationUserIdFkeyUserOrganisationCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinUserOrganisationIdFkeyInverseInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<UserOrganisationUserIdFkeyInput>;
};

/** The fields on `userOrganisation` to look up the row to connect. */
export type UserOrganisationUserOrganisationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userOrganisation` to look up the row to delete. */
export type UserOrganisationUserOrganisationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `userOrganisation` to look up the row to connect. */
export type UserOrganisationUserOrganisationUserIdOrganisationIdKeyConnect = {
  organisationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The fields on `userOrganisation` to look up the row to delete. */
export type UserOrganisationUserOrganisationUserIdOrganisationIdKeyDelete = {
  organisationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

export type UserOrgJoin = {
  __typename?: 'UserOrgJoin';
  address?: Maybe<Scalars['String']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  isSystemOrg?: Maybe<Scalars['Boolean']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  registration?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  userRole?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `UserOrgJoin` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserOrgJoinCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registration` field. */
  registration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UserOrgJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserOrgJoinFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserOrgJoinFilter>>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserOrgJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserOrgJoinFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registration` field. */
  registration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<StringFilter>;
};

/** A connection to a list of `UserOrgJoin` values. */
export type UserOrgJoinsConnection = {
  __typename?: 'UserOrgJoinsConnection';
  /** A list of edges which contains the `UserOrgJoin` and cursor to aid in pagination. */
  edges: Array<UserOrgJoinsEdge>;
  /** A list of `UserOrgJoin` objects. */
  nodes: Array<Maybe<UserOrgJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrgJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserOrgJoin` edge in the connection. */
export type UserOrgJoinsEdge = {
  __typename?: 'UserOrgJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserOrgJoin` at the end of the edge. */
  node?: Maybe<UserOrgJoin>;
};

/** Methods to use when ordering `UserOrgJoin`. */
export enum UserOrgJoinsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  IsSystemOrgAsc = 'IS_SYSTEM_ORG_ASC',
  IsSystemOrgDesc = 'IS_SYSTEM_ORG_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  LogoUrlAsc = 'LOGO_URL_ASC',
  LogoUrlDesc = 'LOGO_URL_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  RegistrationAsc = 'REGISTRATION_ASC',
  RegistrationDesc = 'REGISTRATION_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteUserIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationUserIdFkeyInverseInput>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileUserIdFkeyInverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationUserIdFkeyInverseInput>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinUserIdFkeyInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinAssignerIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewReviewerIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleEditorUserIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinUserIdFkeyInverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationUserIdFkeyInverseInput>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  Natural = 'NATURAL',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProvinceAsc = 'PROVINCE_ASC',
  ProvinceDesc = 'PROVINCE_DESC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NotificationFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewFilter>;
};

/** A filter to be used against many `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTriggerScheduleFilter = {
  /** Every related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerScheduleFilter>;
  /** No related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerScheduleFilter>;
  /** Some related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerScheduleFilter>;
};

/** A filter to be used against many `UserApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserApplicationJoinFilter = {
  /** Every related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserApplicationJoinFilter>;
  /** No related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserApplicationJoinFilter>;
  /** Some related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserApplicationJoinFilter>;
};

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationFilter>;
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `user` to look up the row to connect. */
export type UserUserUsernameKeyConnect = {
  username: Scalars['String']['input'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserUsernameKeyDelete = {
  username: Scalars['String']['input'];
};

export type Verification = Node & {
  __typename?: 'Verification';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  data?: Maybe<Scalars['JSON']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isVerified?: Maybe<Scalars['Boolean']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeExpired?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
  uniqueId: Scalars['String']['output'];
};

/** The `application` to be created by this mutation. */
export type VerificationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  productApplicationJoinsUsingId?: InputMaybe<ProductApplicationJoinApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userOrganisationApplicationJoinsUsingId?: InputMaybe<UserOrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  userToUserId?: InputMaybe<ApplicationUserIdFkeyInput>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `VerificationInput` mutation. */
export type VerificationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<VerificationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `verification` in the `ApplicationInput` mutation. */
export type VerificationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<VerificationVerificationPkeyConnect>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<VerificationNodeIdConnect>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<VerificationVerificationUniqueIdKeyConnect>>;
  /** A `VerificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<VerificationApplicationIdFkeyVerificationCreateInput>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<VerificationVerificationPkeyDelete>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<VerificationNodeIdDelete>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<VerificationVerificationUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `verification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate>>;
};

/** The `verification` to be created by this mutation. */
export type VerificationApplicationIdFkeyVerificationCreateInput = {
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId: Scalars['String']['input'];
};

/** A condition to be used against `Verification` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type VerificationCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeExpired` field. */
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
  /** Checks for equality with the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Verification` object types. All fields are combined with a logical ‘and.’ */
export type VerificationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerificationFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerificationFilter>>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeExpired` field. */
  timeExpired?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
  /** Filter by the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Verification` */
export type VerificationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type VerificationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `verification` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type VerificationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `verification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `verification` to look up the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `verification` to look up the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** Represents an update to a `Verification`. Fields that are set will be updated. */
export type VerificationPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Verification` values. */
export type VerificationsConnection = {
  __typename?: 'VerificationsConnection';
  /** A list of edges which contains the `Verification` and cursor to aid in pagination. */
  edges: Array<VerificationsEdge>;
  /** A list of `Verification` objects. */
  nodes: Array<Maybe<Verification>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Verification` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Verification` edge in the connection. */
export type VerificationsEdge = {
  __typename?: 'VerificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Verification` at the end of the edge. */
  node?: Maybe<Verification>;
};

/** Methods to use when ordering `Verification`. */
export enum VerificationsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsVerifiedAsc = 'IS_VERIFIED_ASC',
  IsVerifiedDesc = 'IS_VERIFIED_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeExpiredAsc = 'TIME_EXPIRED_ASC',
  TimeExpiredDesc = 'TIME_EXPIRED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  UniqueIdAsc = 'UNIQUE_ID_ASC',
  UniqueIdDesc = 'UNIQUE_ID_DESC'
}

/** The fields on `verification` to look up the row to connect. */
export type VerificationVerificationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `verification` to look up the row to delete. */
export type VerificationVerificationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `verification` to look up the row to connect. */
export type VerificationVerificationUniqueIdKeyConnect = {
  uniqueId: Scalars['String']['input'];
};

/** The fields on `verification` to look up the row to delete. */
export type VerificationVerificationUniqueIdKeyDelete = {
  uniqueId: Scalars['String']['input'];
};

/** A filter to be used against YesOrNo fields. All fields are combined with a logical ‘and.’ */
export type YesOrNoFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
};

export type ApplicationFragment = { __typename?: 'Application', id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null };

export type ApplicationResponseFragmentFragment = { __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, templateElement?: { __typename?: 'TemplateElement', code: string } | null };

export type ConsolidatorResponseFragmentFragment = { __typename?: 'ReviewResponse', reviewResponsesByReviewResponseLinkId: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> } };

export type DataViewFragmentFragment = { __typename?: 'DataView', id: number, identifier: string, tableName: string, title?: string | null, code: string, permissionNames?: Array<string | null> | null, rowRestrictions?: any | null, tableViewIncludeColumns?: Array<string | null> | null, tableViewExcludeColumns?: Array<string | null> | null, tableSearchColumns?: Array<string | null> | null, detailViewIncludeColumns?: Array<string | null> | null, detailViewExcludeColumns?: Array<string | null> | null, detailViewHeaderColumn: string, filterIncludeColumns?: Array<string | null> | null, filterExcludeColumns?: Array<string | null> | null, showLinkedApplications: boolean, priority?: number | null, defaultSortColumn?: string | null, defaultFilterString?: string | null, submenu?: string | null, enabled: boolean };

export type DataViewColumnDefinitionFragmentFragment = { __typename?: 'DataViewColumnDefinition', id: number, tableName?: string | null, columnName: string, title?: string | null, elementTypePluginCode?: string | null, elementParameters?: any | null, additionalFormatting?: any | null, valueExpression?: any | null, sortColumn?: string | null, filterParameters?: any | null, filterExpression?: any | null, filterDataType?: string | null };

export type ElementFragmentFragment = { __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability };

export type FullTemplateFragment = { __typename?: 'Template', nodeId: string, versionId: string, versionTimestamp?: any | null, parentVersionId?: string | null, versionComment?: string | null, versionHistory?: any | null, code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, configApplications: { __typename?: 'ApplicationsConnection', nodes: Array<{ __typename?: 'Application', serial?: string | null, id: number } | null> }, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null> } } | null> }, templateActions: { __typename?: 'TemplateActionsConnection', nodes: Array<{ __typename?: 'TemplateAction', code?: string | null, actionCode?: string | null, condition?: any | null, eventCode?: string | null, id: number, parameterQueries?: any | null, sequence?: number | null, trigger?: Trigger | null, description?: string | null, templateId: number } | null> }, templatePermissions: { __typename?: 'TemplatePermissionsConnection', nodes: Array<{ __typename?: 'TemplatePermission', allowedSections?: Array<string | null> | null, canMakeFinalDecision: boolean, canSelfAssign: boolean, id: number, levelNumber?: number | null, restrictions?: any | null, stageNumber?: number | null, permissionNameId?: number | null, permissionName?: { __typename?: 'PermissionName', id: number, name?: string | null, permissionPolicyId?: number | null, permissionPolicy?: { __typename?: 'PermissionPolicy', defaultRestrictions?: any | null, description?: string | null, name?: string | null, id: number, rules?: any | null, type?: PermissionPolicyType | null } | null } | null } | null> }, templateStages: { __typename?: 'TemplateStagesConnection', nodes: Array<{ __typename?: 'TemplateStage', id: number, number?: number | null, colour?: string | null, title?: string | null, description?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', description?: string | null, id: number, name: string, number: number } | null> } } | null> }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } };

export type OrganisationFragment = { __typename?: 'Organisation', id: number, name?: string | null, address?: string | null, registration?: string | null, logoUrl?: string | null };

export type ReviewAssignmentFragment = { __typename?: 'ReviewAssignment', id: number, status: ReviewAssignmentStatus, timeUpdated?: any | null, levelNumber?: number | null, reviewerId: number, isLastLevel?: boolean | null, isFinalDecision?: boolean | null, isSelfAssignable?: boolean | null, allowedSections?: Array<string | null> | null, assignedSections: Array<string | null>, availableSections?: Array<string | null> | null };

export type ReviewResponseFragmentFragment = { __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null };

export type SectionFragment = { __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null };

export type StageFragment = { __typename?: 'ApplicationStageStatusLatest', stage?: string | null, stageId?: number | null, stageColour?: string | null, status?: ApplicationStatus | null, stageNumber?: number | null, statusHistoryTimeCreated?: any | null, stageHistoryTimeCreated?: any | null };

export type TemplateFragmentFragment = { __typename?: 'Template', code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, versionId: string, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } };

export type TemplateStageFragment = { __typename?: 'TemplateStage', number?: number | null, title?: string | null, id: number, description?: string | null, colour?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', name: string, number: number } | null> } };

export type UserFragment = { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null };

export type CreateApplicationMutationVariables = Exact<{
  name: Scalars['String']['input'];
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  serial?: InputMaybe<Scalars['String']['input']>;
  templateId: Scalars['Int']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  sessionId: Scalars['String']['input'];
  outcome?: InputMaybe<ApplicationOutcome>;
  trigger?: InputMaybe<Trigger>;
  responses?: InputMaybe<Array<ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput> | ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput>;
}>;


export type CreateApplicationMutation = { __typename?: 'Mutation', createApplication?: { __typename?: 'CreateApplicationPayload', application?: { __typename?: 'Application', userId?: number | null, orgId?: number | null, id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null, template?: { __typename?: 'Template', code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, versionId: string, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null } | null> }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null } | null } | null };

export type CreateNoteMutationVariables = Exact<{
  applicationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
  orgId?: InputMaybe<Scalars['Int']['input']>;
  comment: Scalars['String']['input'];
}>;


export type CreateNoteMutation = { __typename?: 'Mutation', createApplicationNote?: { __typename?: 'CreateApplicationNotePayload', applicationNote?: { __typename?: 'ApplicationNote', id: number, timestamp?: any | null, comment: string } | null } | null };

export type CreateReviewMutationVariables = Exact<{
  reviewInput: ReviewInput;
}>;


export type CreateReviewMutation = { __typename?: 'Mutation', createReview?: { __typename?: 'CreateReviewPayload', review?: { __typename?: 'Review', id: number, reviewAssignment?: { __typename?: 'ReviewAssignment', id: number, reviews: { __typename?: 'ReviewsConnection', nodes: Array<{ __typename?: 'Review', id: number } | null> } } | null } | null } | null };

export type CreateReviewResponseMutationVariables = Exact<{
  templateElementId: Scalars['Int']['input'];
  applicationId: Scalars['Int']['input'];
  reviewId: Scalars['Int']['input'];
  decision: ReviewResponseDecision;
  comment?: InputMaybe<Scalars['String']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
}>;


export type CreateReviewResponseMutation = { __typename?: 'Mutation', createApplicationResponse?: { __typename?: 'CreateApplicationResponsePayload', applicationResponse?: { __typename?: 'ApplicationResponse', id: number, reviewResponses: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, comment?: string | null, decision?: ReviewResponseDecision | null } | null> } } | null } | null };

export type CreateColumnDefinitionMutationVariables = Exact<{
  tableName: Scalars['String']['input'];
  columnName: Scalars['String']['input'];
}>;


export type CreateColumnDefinitionMutation = { __typename?: 'Mutation', createDataViewColumnDefinition?: { __typename?: 'CreateDataViewColumnDefinitionPayload', dataViewColumnDefinition?: { __typename?: 'DataViewColumnDefinition', id: number, tableName?: string | null, columnName: string, title?: string | null, elementTypePluginCode?: string | null, elementParameters?: any | null, additionalFormatting?: any | null, valueExpression?: any | null, sortColumn?: string | null, filterParameters?: any | null, filterExpression?: any | null, filterDataType?: string | null } | null } | null };

export type CreateDataViewMutationVariables = Exact<{
  identifier: Scalars['String']['input'];
  tableName: Scalars['String']['input'];
  code: Scalars['String']['input'];
  detailViewHeaderColumn: Scalars['String']['input'];
}>;


export type CreateDataViewMutation = { __typename?: 'Mutation', createDataView?: { __typename?: 'CreateDataViewPayload', dataView?: { __typename?: 'DataView', id: number, identifier: string, tableName: string, title?: string | null, code: string, permissionNames?: Array<string | null> | null, rowRestrictions?: any | null, tableViewIncludeColumns?: Array<string | null> | null, tableViewExcludeColumns?: Array<string | null> | null, tableSearchColumns?: Array<string | null> | null, detailViewIncludeColumns?: Array<string | null> | null, detailViewExcludeColumns?: Array<string | null> | null, detailViewHeaderColumn: string, filterIncludeColumns?: Array<string | null> | null, filterExcludeColumns?: Array<string | null> | null, showLinkedApplications: boolean, priority?: number | null, defaultSortColumn?: string | null, defaultFilterString?: string | null, submenu?: string | null, enabled: boolean } | null } | null };

export type DeleteColumnDefinitionMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteColumnDefinitionMutation = { __typename?: 'Mutation', deleteDataViewColumnDefinition?: { __typename?: 'DeleteDataViewColumnDefinitionPayload', dataViewColumnDefinition?: { __typename?: 'DataViewColumnDefinition', id: number } | null } | null };

export type DeleteDataViewMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteDataViewMutation = { __typename?: 'Mutation', deleteDataView?: { __typename?: 'DeleteDataViewPayload', dataView?: { __typename?: 'DataView', id: number } | null } | null };

export type UpdateColumnDefinitionMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: DataViewColumnDefinitionPatch;
}>;


export type UpdateColumnDefinitionMutation = { __typename?: 'Mutation', updateDataViewColumnDefinition?: { __typename?: 'UpdateDataViewColumnDefinitionPayload', dataViewColumnDefinition?: { __typename?: 'DataViewColumnDefinition', id: number, tableName?: string | null, columnName: string, title?: string | null, elementTypePluginCode?: string | null, elementParameters?: any | null, additionalFormatting?: any | null, valueExpression?: any | null, sortColumn?: string | null, filterParameters?: any | null, filterExpression?: any | null, filterDataType?: string | null } | null } | null };

export type UpdateDataViewMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: DataViewPatch;
}>;


export type UpdateDataViewMutation = { __typename?: 'Mutation', updateDataView?: { __typename?: 'UpdateDataViewPayload', dataView?: { __typename?: 'DataView', id: number, identifier: string, tableName: string, title?: string | null, code: string, permissionNames?: Array<string | null> | null, rowRestrictions?: any | null, tableViewIncludeColumns?: Array<string | null> | null, tableViewExcludeColumns?: Array<string | null> | null, tableSearchColumns?: Array<string | null> | null, detailViewIncludeColumns?: Array<string | null> | null, detailViewExcludeColumns?: Array<string | null> | null, detailViewHeaderColumn: string, filterIncludeColumns?: Array<string | null> | null, filterExcludeColumns?: Array<string | null> | null, showLinkedApplications: boolean, priority?: number | null, defaultSortColumn?: string | null, defaultFilterString?: string | null, submenu?: string | null, enabled: boolean } | null } | null };

export type DeleteApplicationMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteApplicationMutation = { __typename?: 'Mutation', deleteApplication?: { __typename?: 'DeleteApplicationPayload', clientMutationId?: string | null } | null };

export type DeleteNoteMutationVariables = Exact<{
  noteId: Scalars['Int']['input'];
}>;


export type DeleteNoteMutation = { __typename?: 'Mutation', deleteApplicationNote?: { __typename?: 'DeleteApplicationNotePayload', applicationNote?: { __typename?: 'ApplicationNote', id: number } | null } | null };

export type RestartApplicationMutationVariables = Exact<{
  serial: Scalars['String']['input'];
  applicationPatch: ApplicationPatch;
}>;


export type RestartApplicationMutation = { __typename?: 'Mutation', updateApplicationBySerial?: { __typename?: 'UpdateApplicationPayload', application?: { __typename?: 'Application', id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, templateElement?: { __typename?: 'TemplateElement', code: string } | null } | null> } } | null } | null };

export type SubmitReviewMutationVariables = Exact<{
  reviewId: Scalars['Int']['input'];
  trigger?: InputMaybe<Trigger>;
  reviewResponses?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate> | ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate>;
}>;


export type SubmitReviewMutation = { __typename?: 'Mutation', updateReview?: { __typename?: 'UpdateReviewPayload', review?: { __typename?: 'Review', id: number, trigger?: Trigger | null } | null } | null };

export type DeleteTemplateMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteTemplateMutation = { __typename?: 'Mutation', deleteTemplate?: { __typename?: 'DeleteTemplatePayload', clientMutationId?: string | null } | null };

export type DeleteWholeApplicationMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteWholeApplicationMutation = { __typename?: 'Mutation', deleteWholeApplication?: { __typename?: 'DeleteWholeApplicationPayload', clientMutationId?: string | null } | null };

export type UpdateTemplateMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  templatePatch: TemplatePatch;
}>;


export type UpdateTemplateMutation = { __typename?: 'Mutation', updateTemplate?: { __typename?: 'UpdateTemplatePayload', template?: { __typename?: 'Template', nodeId: string, versionId: string, versionTimestamp?: any | null, parentVersionId?: string | null, versionComment?: string | null, versionHistory?: any | null, code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, configApplications: { __typename?: 'ApplicationsConnection', nodes: Array<{ __typename?: 'Application', serial?: string | null, id: number } | null> }, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null> } } | null> }, templateActions: { __typename?: 'TemplateActionsConnection', nodes: Array<{ __typename?: 'TemplateAction', code?: string | null, actionCode?: string | null, condition?: any | null, eventCode?: string | null, id: number, parameterQueries?: any | null, sequence?: number | null, trigger?: Trigger | null, description?: string | null, templateId: number } | null> }, templatePermissions: { __typename?: 'TemplatePermissionsConnection', nodes: Array<{ __typename?: 'TemplatePermission', allowedSections?: Array<string | null> | null, canMakeFinalDecision: boolean, canSelfAssign: boolean, id: number, levelNumber?: number | null, restrictions?: any | null, stageNumber?: number | null, permissionNameId?: number | null, permissionName?: { __typename?: 'PermissionName', id: number, name?: string | null, permissionPolicyId?: number | null, permissionPolicy?: { __typename?: 'PermissionPolicy', defaultRestrictions?: any | null, description?: string | null, name?: string | null, id: number, rules?: any | null, type?: PermissionPolicyType | null } | null } | null } | null> }, templateStages: { __typename?: 'TemplateStagesConnection', nodes: Array<{ __typename?: 'TemplateStage', id: number, number?: number | null, colour?: string | null, title?: string | null, description?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', description?: string | null, id: number, name: string, number: number } | null> } } | null> }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null } | null };

export type UpdateTemplateFilterJoinMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  filterJoinPatch: TemplateFilterJoinPatch;
}>;


export type UpdateTemplateFilterJoinMutation = { __typename?: 'Mutation', updateTemplateFilterJoin?: { __typename?: 'UpdateTemplateFilterJoinPayload', clientMutationId?: string | null, templateFilterJoin?: { __typename?: 'TemplateFilterJoin', id: number, filterId: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null } | null };

export type UpdateTemplateSectionMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  sectionPatch: TemplateSectionPatch;
}>;


export type UpdateTemplateSectionMutation = { __typename?: 'Mutation', updateTemplateSection?: { __typename?: 'UpdateTemplateSectionPayload', templateSection?: { __typename?: 'TemplateSection', id: number, index?: number | null, code?: string | null, templateId: number, title?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number, application?: { __typename?: 'Application', id: number, serial?: string | null, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number } | null> } } | null } | null> } } | null> } } | null } | null };

export type UpdateTemplateStageMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  templateStagePatch: TemplateStagePatch;
}>;


export type UpdateTemplateStageMutation = { __typename?: 'Mutation', updateTemplateStage?: { __typename?: 'UpdateTemplateStagePayload', templateStage?: { __typename?: 'TemplateStage', id: number, number?: number | null, colour?: string | null, title?: string | null, description?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', description?: string | null, id: number, name: string, number: number } | null> } } | null } | null };

export type UpdateApplicationMutationVariables = Exact<{
  serial: Scalars['String']['input'];
  applicationTrigger?: InputMaybe<Trigger>;
  responses?: InputMaybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate> | ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate>;
}>;


export type UpdateApplicationMutation = { __typename?: 'Mutation', updateApplicationBySerial?: { __typename?: 'UpdateApplicationPayload', application?: { __typename?: 'Application', id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null } | null } | null };

export type UpdateResponseMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  value?: InputMaybe<Scalars['JSON']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
}>;


export type UpdateResponseMutation = { __typename?: 'Mutation', updateApplicationResponse?: { __typename?: 'UpdateApplicationResponsePayload', applicationResponse?: { __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, templateElement?: { __typename?: 'TemplateElement', code: string, id: number, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null } | null } | null };

export type UpdateReviewMutationVariables = Exact<{
  reviewId: Scalars['Int']['input'];
  reviewPatch: ReviewPatch;
}>;


export type UpdateReviewMutation = { __typename?: 'Mutation', updateReview?: { __typename?: 'UpdateReviewPayload', review?: { __typename?: 'Review', id: number, trigger?: Trigger | null, reviewResponses: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, decision?: ReviewResponseDecision | null, comment?: string | null } | null> }, reviewDecisions: { __typename?: 'ReviewDecisionsConnection', nodes: Array<{ __typename?: 'ReviewDecision', id: number, decision?: Decision | null, comment?: string | null, timeUpdated?: any | null } | null> } } | null } | null };

export type UpdateReviewAssignmentMutationVariables = Exact<{
  assignmentId: Scalars['Int']['input'];
  assignmentPatch: ReviewAssignmentPatch;
}>;


export type UpdateReviewAssignmentMutation = { __typename?: 'Mutation', updateReviewAssignment?: { __typename?: 'UpdateReviewAssignmentPayload', reviewAssignment?: { __typename?: 'ReviewAssignment', id: number, status: ReviewAssignmentStatus, timeUpdated?: any | null } | null } | null };

export type UpdateReviewDecisionCommentMutationVariables = Exact<{
  reviewDecisionId: Scalars['Int']['input'];
  comment: Scalars['String']['input'];
}>;


export type UpdateReviewDecisionCommentMutation = { __typename?: 'Mutation', updateReviewDecision?: { __typename?: 'UpdateReviewDecisionPayload', reviewDecision?: { __typename?: 'ReviewDecision', id: number, decision?: Decision | null, comment?: string | null } | null } | null };

export type UpdateReviewResponseMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  decision?: InputMaybe<ReviewResponseDecision>;
  comment?: InputMaybe<Scalars['String']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
}>;


export type UpdateReviewResponseMutation = { __typename?: 'Mutation', updateReviewResponse?: { __typename?: 'UpdateReviewResponsePayload', reviewResponse?: { __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null } | null };

export type GetAppplicantFilterListQueryVariables = Exact<{
  searchValue: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
}>;


export type GetAppplicantFilterListQuery = { __typename?: 'Query', applicationListFilterApplicant?: { __typename?: 'ApplicationListFilterApplicantConnection', nodes: Array<string | null>, totalCount: number } | null };

export type GetAssignerFilterListQueryVariables = Exact<{
  searchValue: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
}>;


export type GetAssignerFilterListQuery = { __typename?: 'Query', applicationListFilterAssigner?: { __typename?: 'ApplicationListFilterAssignerConnection', nodes: Array<string | null>, totalCount: number } | null };

export type GetOrganisationFilterListQueryVariables = Exact<{
  searchValue: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
}>;


export type GetOrganisationFilterListQuery = { __typename?: 'Query', applicationListFilterOrganisation?: { __typename?: 'ApplicationListFilterOrganisationConnection', nodes: Array<string | null>, totalCount: number } | null };

export type GetReviewersFilterListQueryVariables = Exact<{
  searchValue: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
}>;


export type GetReviewersFilterListQuery = { __typename?: 'Query', applicationListFilterReviewer?: { __typename?: 'ApplicationListFilterReviewerConnection', nodes: Array<string | null>, totalCount: number } | null };

export type GetStageFilterListQueryVariables = Exact<{
  templateCode: Scalars['String']['input'];
}>;


export type GetStageFilterListQuery = { __typename?: 'Query', applicationListFilterStage?: { __typename?: 'ApplicationListFilterStageConnection', nodes: Array<string | null>, totalCount: number } | null };

export type GetColumnDefinitionsQueryVariables = Exact<{
  tableName: Scalars['String']['input'];
}>;


export type GetColumnDefinitionsQuery = { __typename?: 'Query', dataViewColumnDefinitions?: { __typename?: 'DataViewColumnDefinitionsConnection', nodes: Array<{ __typename?: 'DataViewColumnDefinition', id: number, tableName?: string | null, columnName: string, title?: string | null, elementTypePluginCode?: string | null, elementParameters?: any | null, additionalFormatting?: any | null, valueExpression?: any | null, sortColumn?: string | null, filterParameters?: any | null, filterExpression?: any | null, filterDataType?: string | null } | null> } | null };

export type GetDataTablesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDataTablesQuery = { __typename?: 'Query', dataTables?: { __typename?: 'DataTablesConnection', nodes: Array<{ __typename?: 'DataTable', tableName: string, id: number, isLookupTable?: boolean | null, displayName?: string | null } | null> } | null, dataViews?: { __typename?: 'DataViewsConnection', nodes: Array<{ __typename?: 'DataView', tableName: string } | null> } | null };

export type GetDataViewsQueryVariables = Exact<{
  tableName: Scalars['String']['input'];
}>;


export type GetDataViewsQuery = { __typename?: 'Query', dataViews?: { __typename?: 'DataViewsConnection', nodes: Array<{ __typename?: 'DataView', id: number, identifier: string, tableName: string, title?: string | null, code: string, permissionNames?: Array<string | null> | null, rowRestrictions?: any | null, tableViewIncludeColumns?: Array<string | null> | null, tableViewExcludeColumns?: Array<string | null> | null, tableSearchColumns?: Array<string | null> | null, detailViewIncludeColumns?: Array<string | null> | null, detailViewExcludeColumns?: Array<string | null> | null, detailViewHeaderColumn: string, filterIncludeColumns?: Array<string | null> | null, filterExcludeColumns?: Array<string | null> | null, showLinkedApplications: boolean, priority?: number | null, defaultSortColumn?: string | null, defaultFilterString?: string | null, submenu?: string | null, enabled: boolean } | null> } | null };

export type GetActivityLogQueryVariables = Exact<{
  applicationId: Scalars['Int']['input'];
}>;


export type GetActivityLogQuery = { __typename?: 'Query', activityLogs?: { __typename?: 'ActivityLogsConnection', nodes: Array<{ __typename?: 'ActivityLog', value: string, type: EventType, timestamp: any, table: string, recordId?: number | null, nodeId: string, id: number, details: any, applicationId?: number | null } | null> } | null };

export type GetAllLookupTableStructuresQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllLookupTableStructuresQuery = { __typename?: 'Query', dataTables?: { __typename?: 'DataTablesConnection', nodes: Array<{ __typename?: 'DataTable', id: number, tableName: string, displayName?: string | null, fieldMap?: any | null } | null> } | null };

export type GetAllResponsesQueryVariables = Exact<{
  serial: Scalars['String']['input'];
  responseStatuses?: InputMaybe<Array<ApplicationResponseStatus> | ApplicationResponseStatus>;
}>;


export type GetAllResponsesQuery = { __typename?: 'Query', applicationBySerial?: { __typename?: 'Application', id: number, serial?: string | null, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, reviewResponses: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> }, templateElement?: { __typename?: 'TemplateElement', code: string } | null } | null> } } | null };

export type GetApplicationQueryVariables = Exact<{
  serial: Scalars['String']['input'];
}>;


export type GetApplicationQuery = { __typename?: 'Query', applicationBySerial?: { __typename?: 'Application', id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null, template?: { __typename?: 'Template', code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, versionId: string, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null> } } | null> }, templateStages: { __typename?: 'TemplateStagesConnection', nodes: Array<{ __typename?: 'TemplateStage', number?: number | null, title?: string | null, id: number, description?: string | null, colour?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', name: string, number: number } | null> } } | null> }, previewActions: { __typename?: 'TemplateActionsConnection', totalCount: number }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null, user?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null, org?: { __typename?: 'Organisation', id: number, name?: string | null, address?: string | null, registration?: string | null, logoUrl?: string | null } | null, triggerSchedules: { __typename?: 'TriggerSchedulesConnection', nodes: Array<{ __typename?: 'TriggerSchedule', id: number, timeScheduled: any, eventCode?: string | null, isActive?: boolean | null } | null> } } | null, applicationStageStatusLatests?: { __typename?: 'ApplicationStageStatusLatestsConnection', nodes: Array<{ __typename?: 'ApplicationStageStatusLatest', stage?: string | null, stageId?: number | null, stageColour?: string | null, status?: ApplicationStatus | null, stageNumber?: number | null, statusHistoryTimeCreated?: any | null, stageHistoryTimeCreated?: any | null } | null> } | null };

export type GetFilteredApplicationCountQueryVariables = Exact<{
  filter?: InputMaybe<ApplicationListShapeFilter>;
  userId?: Scalars['Int']['input'];
}>;


export type GetFilteredApplicationCountQuery = { __typename?: 'Query', applicationList?: { __typename?: 'ApplicationListShapesConnection', totalCount: number } | null };

export type GetApplicationSerialQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GetApplicationSerialQuery = { __typename?: 'Query', application?: { __typename?: 'Application', serial?: string | null, name?: string | null, trigger?: Trigger | null } | null };

export type GetApplicationListQueryVariables = Exact<{
  filters?: InputMaybe<ApplicationListShapeFilter>;
  sortFields?: InputMaybe<Array<ApplicationListShapesOrderBy> | ApplicationListShapesOrderBy>;
  paginationOffset?: InputMaybe<Scalars['Int']['input']>;
  numberToFetch?: InputMaybe<Scalars['Int']['input']>;
  userId?: Scalars['Int']['input'];
  templateCode: Scalars['String']['input'];
}>;


export type GetApplicationListQuery = { __typename?: 'Query', applicationList?: { __typename?: 'ApplicationListShapesConnection', totalCount: number, nodes: Array<{ __typename?: 'ApplicationListShape', id?: number | null, serial?: string | null, name?: string | null, templateCode?: string | null, templateName?: string | null, applicant?: string | null, orgName?: string | null, stage?: string | null, stageColour?: string | null, status?: ApplicationStatus | null, outcome?: ApplicationOutcome | null, lastActiveDate?: any | null, applicantDeadline?: any | null, reviewerAction?: ReviewerAction | null, assignerAction?: AssignerAction | null, assigners?: Array<string | null> | null, reviewers?: Array<string | null> | null } | null>, pageInfo: { __typename?: 'PageInfo', hasPreviousPage: boolean, hasNextPage: boolean } } | null, templates?: { __typename?: 'TemplatesConnection', nodes: Array<{ __typename?: 'Template', code: string, name?: string | null, namePlural?: string | null } | null> } | null };

export type GetApplicationDocsQueryVariables = Exact<{
  applicationSerial: Scalars['String']['input'];
}>;


export type GetApplicationDocsQuery = { __typename?: 'Query', files?: { __typename?: 'FilesConnection', nodes: Array<{ __typename?: 'File', uniqueId: string, description?: string | null, filePath: string, originalFilename: string, thumbnailPath?: string | null, timestamp: any } | null> } | null };

export type GetHistoryForApplicantQueryVariables = Exact<{
  serial: Scalars['String']['input'];
  questionCode: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersionId: Scalars['String']['input'];
}>;


export type GetHistoryForApplicantQuery = { __typename?: 'Query', templateElementByTemplateCodeAndCodeAndTemplateVersion?: { __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability, reviewResponses: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, review?: { __typename?: 'Review', stageNumber?: number | null, id: number, status?: ReviewStatus | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null } | null> }, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, application?: { __typename?: 'Application', stageNumber?: number | null, id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null, user?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null, templateElement?: { __typename?: 'TemplateElement', code: string } | null } | null> } } | null };

export type GetHistoryForReviewerQueryVariables = Exact<{
  serial: Scalars['String']['input'];
  questionCode: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersionId: Scalars['String']['input'];
  userId: Scalars['Int']['input'];
}>;


export type GetHistoryForReviewerQuery = { __typename?: 'Query', templateElementByTemplateCodeAndCodeAndTemplateVersion?: { __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability, reviewResponses: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, review?: { __typename?: 'Review', stageNumber?: number | null, id: number, status?: ReviewStatus | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null } | null> }, applicationResponses: { __typename?: 'ApplicationResponsesConnection', nodes: Array<{ __typename?: 'ApplicationResponse', id: number, isValid?: boolean | null, value?: any | null, stageNumber?: number | null, templateElementId: number, evaluatedParameters?: any | null, timeUpdated?: any | null, application?: { __typename?: 'Application', stageNumber?: number | null, id: number, serial?: string | null, name?: string | null, outcome?: ApplicationOutcome | null, trigger?: Trigger | null, user?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null, templateElement?: { __typename?: 'TemplateElement', code: string } | null } | null> } } | null };

export type GetLookupTableStructureByIdQueryVariables = Exact<{
  lookupTableID: Scalars['Int']['input'];
}>;


export type GetLookupTableStructureByIdQuery = { __typename?: 'Query', dataTable?: { __typename?: 'DataTable', id: number, displayName?: string | null, tableName: string, fieldMap?: any | null, dataViewCode?: string | null } | null };

export type GetApplicationNotesQueryVariables = Exact<{
  applicationId: Scalars['Int']['input'];
}>;


export type GetApplicationNotesQuery = { __typename?: 'Query', applicationNotes?: { __typename?: 'ApplicationNotesConnection', nodes: Array<{ __typename?: 'ApplicationNote', id: number, comment: string, timestamp?: any | null, org?: { __typename?: 'Organisation', id: number, name?: string | null } | null, user?: { __typename?: 'User', fullName?: string | null, id: number, username?: string | null } | null, files: { __typename?: 'FilesConnection', nodes: Array<{ __typename?: 'File', filePath: string, description?: string | null, id: number, originalFilename: string, uniqueId: string } | null> } } | null> } | null };

export type GetRefDocsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRefDocsQuery = { __typename?: 'Query', files?: { __typename?: 'FilesConnection', nodes: Array<{ __typename?: 'File', uniqueId: string, description?: string | null, isInternalReferenceDoc: boolean, isExternalReferenceDoc: boolean } | null> } | null };

export type GetReviewDecisionCommentQueryVariables = Exact<{
  reviewDecisionId: Scalars['Int']['input'];
}>;


export type GetReviewDecisionCommentQuery = { __typename?: 'Query', reviewDecision?: { __typename?: 'ReviewDecision', id: number, comment?: string | null } | null };

export type GetReviewInfoQueryVariables = Exact<{
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  assignerId: Scalars['Int']['input'];
}>;


export type GetReviewInfoQuery = { __typename?: 'Query', reviewAssignments?: { __typename?: 'ReviewAssignmentsConnection', nodes: Array<{ __typename?: 'ReviewAssignment', timeStageCreated?: any | null, trigger?: Trigger | null, id: number, status: ReviewAssignmentStatus, timeUpdated?: any | null, levelNumber?: number | null, reviewerId: number, isLastLevel?: boolean | null, isFinalDecision?: boolean | null, isSelfAssignable?: boolean | null, allowedSections?: Array<string | null> | null, assignedSections: Array<string | null>, availableSections?: Array<string | null> | null, stage?: { __typename?: 'TemplateStage', id: number, number?: number | null, title?: string | null, colour?: string | null } | null, reviewer?: { __typename?: 'User', id: number, firstName?: string | null, lastName?: string | null } | null, reviews: { __typename?: 'ReviewsConnection', nodes: Array<{ __typename?: 'Review', id: number, status?: ReviewStatus | null, timeStatusCreated?: any | null, trigger?: Trigger | null, isLocked?: boolean | null, reviewDecisions: { __typename?: 'ReviewDecisionsConnection', nodes: Array<{ __typename?: 'ReviewDecision', id: number, decision?: Decision | null } | null> } } | null> }, reviewAssignmentAssignerJoins: { __typename?: 'ReviewAssignmentAssignerJoinsConnection', nodes: Array<{ __typename?: 'ReviewAssignmentAssignerJoin', assigner?: { __typename?: 'User', firstName?: string | null, lastName?: string | null, id: number } | null } | null> } } | null> } | null };

export type GetReviewResponsesQueryVariables = Exact<{
  reviewAssignmentId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
  sectionIds?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
  applicationId: Scalars['Int']['input'];
  previousLevel: Scalars['Int']['input'];
  stageNumber: Scalars['Int']['input'];
  shouldIncludePreviousStage?: Scalars['Boolean']['input'];
  previousStage?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetReviewResponsesQuery = { __typename?: 'Query', thisReviewResponses?: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, reviewResponseLink?: { __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null, reviewResponsesByReviewResponseLinkId: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> } } | null> } | null, previousLevelReviewResponses?: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> } | null, originalReviewResponses?: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> } | null, previousOriginalReviewResponses?: { __typename?: 'ReviewResponsesConnection', nodes: Array<{ __typename?: 'ReviewResponse', id: number, applicationResponseId?: number | null, decision?: ReviewResponseDecision | null, comment?: string | null, stageNumber?: number | null, status?: ReviewResponseStatus | null, timeUpdated?: any | null, originalReviewResponseId?: number | null, reviewResponseLinkId?: number | null, templateElementId?: number | null, applicationResponse?: { __typename?: 'ApplicationResponse', id: number, templateElementId: number } | null, review?: { __typename?: 'Review', id: number, status?: ReviewStatus | null, stageNumber?: number | null, levelNumber?: number | null, reviewer?: { __typename?: 'User', id: number, username?: string | null, firstName?: string | null, lastName?: string | null, email?: string | null, dateOfBirth?: any | null } | null } | null } | null> } | null };

export type GetReviewableQuestionCountsQueryVariables = Exact<{
  applicationId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  levelNumber: Scalars['Int']['input'];
}>;


export type GetReviewableQuestionCountsQuery = { __typename?: 'Query', reviewableQuestions?: { __typename?: 'ReviewableQuestionsConnection', totalCount: number } | null, assignedQuestions?: { __typename?: 'AssignedQuestionsConnection', totalCount: number } | null };

export type GetSchemaColumnsQueryVariables = Exact<{
  tableNames?: InputMaybe<Array<Scalars['SqlIdentifier']['input']> | Scalars['SqlIdentifier']['input']>;
}>;


export type GetSchemaColumnsQuery = { __typename?: 'Query', schemaColumns?: { __typename?: 'SchemaColumnsConnection', nodes: Array<{ __typename?: 'SchemaColumn', columnName?: any | null, tableName?: any | null } | null> } | null };

export type GetTemplateQueryVariables = Exact<{
  code: Scalars['String']['input'];
  status?: InputMaybe<TemplateStatus>;
}>;


export type GetTemplateQuery = { __typename?: 'Query', templates?: { __typename?: 'TemplatesConnection', nodes: Array<{ __typename?: 'Template', code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, versionId: string, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null> } } | null> }, templateStages: { __typename?: 'TemplateStagesConnection', nodes: Array<{ __typename?: 'TemplateStage', id: number, number?: number | null, title?: string | null, description?: string | null } | null> }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null> } | null };

export type GetTemplatesQueryVariables = Exact<{
  status?: InputMaybe<TemplateStatus>;
}>;


export type GetTemplatesQuery = { __typename?: 'Query', templates?: { __typename?: 'TemplatesConnection', nodes: Array<{ __typename?: 'Template', code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, versionId: string, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null> } | null };

export type GetUsersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUsersQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', username?: string | null } | null> } | null };

export type GeTemplateActionByCodeQueryVariables = Exact<{
  pluginCode: Scalars['String']['input'];
}>;


export type GeTemplateActionByCodeQuery = { __typename?: 'Query', templateActions?: { __typename?: 'TemplateActionsConnection', nodes: Array<{ __typename?: 'TemplateAction', id: number, description?: string | null, condition?: any | null, parameterQueries?: any | null, trigger?: Trigger | null, template?: { __typename?: 'Template', name?: string | null, code: string } | null } | null> } | null };

export type GetAllActionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllActionsQuery = { __typename?: 'Query', actionPlugins?: { __typename?: 'ActionPluginsConnection', nodes: Array<{ __typename?: 'ActionPlugin', id: number, code?: string | null, description?: string | null, name?: string | null, optionalParameters?: Array<string | null> | null, outputProperties?: Array<string | null> | null, requiredParameters?: Array<string | null> | null } | null> } | null };

export type GetAllFiltersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllFiltersQuery = { __typename?: 'Query', filters?: { __typename?: 'FiltersConnection', nodes: Array<{ __typename?: 'Filter', code: string, id: number, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null> } | null };

export type GetAllPermissionNamesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllPermissionNamesQuery = { __typename?: 'Query', permissionNames?: { __typename?: 'PermissionNamesConnection', nodes: Array<{ __typename?: 'PermissionName', id: number, name?: string | null, permissionPolicyId?: number | null, permissionPolicy?: { __typename?: 'PermissionPolicy', id: number, name?: string | null, rules?: any | null, type?: PermissionPolicyType | null, description?: string | null, defaultRestrictions?: any | null } | null } | null> } | null };

export type GetAllTemplatesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllTemplatesQuery = { __typename?: 'Query', templates?: { __typename?: 'TemplatesConnection', nodes: Array<{ __typename?: 'Template', code: string, status?: TemplateStatus | null, id: number, versionId: string, versionTimestamp?: any | null, parentVersionId?: string | null, versionComment?: string | null, versionHistory?: any | null, name?: string | null, templateCategory?: { __typename?: 'TemplateCategory', title?: string | null } | null, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null> } | null };

export type GetTemplateCategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTemplateCategoriesQuery = { __typename?: 'Query', templateCategories?: { __typename?: 'TemplateCategoriesConnection', nodes: Array<{ __typename?: 'TemplateCategory', code: string, icon?: string | null, id: number, title?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null> } | null };

export type GetFullTemplateInfoQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GetFullTemplateInfoQuery = { __typename?: 'Query', template?: { __typename?: 'Template', nodeId: string, versionId: string, versionTimestamp?: any | null, parentVersionId?: string | null, versionComment?: string | null, versionHistory?: any | null, code: string, id: number, name?: string | null, status?: TemplateStatus | null, namePlural?: string | null, isLinear?: boolean | null, canApplicantMakeChanges?: boolean | null, startMessage?: any | null, submissionMessage?: any | null, serialPattern?: string | null, icon?: string | null, dashboardRestrictions?: Array<string | null> | null, configApplications: { __typename?: 'ApplicationsConnection', nodes: Array<{ __typename?: 'Application', serial?: string | null, id: number } | null> }, templateSections: { __typename?: 'TemplateSectionsConnection', nodes: Array<{ __typename?: 'TemplateSection', id: number, title?: string | null, index?: number | null, code?: string | null, templateElementsBySectionId: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, index?: number | null, title?: string | null, elementTypePluginCode?: string | null, category?: TemplateElementCategory | null, visibilityCondition?: any | null, isRequired?: any | null, isEditable?: any | null, validation?: any | null, validationMessage?: string | null, helpText?: string | null, initialValue?: any | null, parameters?: any | null, reviewability: Reviewability } | null> } } | null> }, templateActions: { __typename?: 'TemplateActionsConnection', nodes: Array<{ __typename?: 'TemplateAction', code?: string | null, actionCode?: string | null, condition?: any | null, eventCode?: string | null, id: number, parameterQueries?: any | null, sequence?: number | null, trigger?: Trigger | null, description?: string | null, templateId: number } | null> }, templatePermissions: { __typename?: 'TemplatePermissionsConnection', nodes: Array<{ __typename?: 'TemplatePermission', allowedSections?: Array<string | null> | null, canMakeFinalDecision: boolean, canSelfAssign: boolean, id: number, levelNumber?: number | null, restrictions?: any | null, stageNumber?: number | null, permissionNameId?: number | null, permissionName?: { __typename?: 'PermissionName', id: number, name?: string | null, permissionPolicyId?: number | null, permissionPolicy?: { __typename?: 'PermissionPolicy', defaultRestrictions?: any | null, description?: string | null, name?: string | null, id: number, rules?: any | null, type?: PermissionPolicyType | null } | null } | null } | null> }, templateStages: { __typename?: 'TemplateStagesConnection', nodes: Array<{ __typename?: 'TemplateStage', id: number, number?: number | null, colour?: string | null, title?: string | null, description?: string | null, templateStageReviewLevelsByStageId: { __typename?: 'TemplateStageReviewLevelsConnection', nodes: Array<{ __typename?: 'TemplateStageReviewLevel', description?: string | null, id: number, name: string, number: number } | null> } } | null> }, templateCategory?: { __typename?: 'TemplateCategory', id: number, code: string, title?: string | null, icon?: string | null, uiLocation?: Array<UiLocation | null> | null, isSubmenu?: boolean | null } | null, templateFilterJoins: { __typename?: 'TemplateFilterJoinsConnection', nodes: Array<{ __typename?: 'TemplateFilterJoin', id: number, filter?: { __typename?: 'Filter', id: number, code: string, query?: any | null, title?: string | null, userRole?: PermissionPolicyType | null } | null } | null> }, applications: { __typename?: 'ApplicationsConnection', totalCount: number } } | null };

export type GetPermissionStatisticsQueryVariables = Exact<{
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  rowLeveSearch: Scalars['String']['input'];
}>;


export type GetPermissionStatisticsQuery = { __typename?: 'Query', permissionName?: { __typename?: 'PermissionName', name?: string | null, permissionJoins: { __typename?: 'PermissionJoinsConnection', nodes: Array<{ __typename?: 'PermissionJoin', id: number, organisation?: { __typename?: 'Organisation', name?: string | null } | null, user?: { __typename?: 'User', firstName?: string | null, lastName?: string | null, email?: string | null, username?: string | null } | null } | null> }, permissionPolicy?: { __typename?: 'PermissionPolicy', description?: string | null, rules?: any | null, type?: PermissionPolicyType | null, name?: string | null } | null, templatePermissions: { __typename?: 'TemplatePermissionsConnection', nodes: Array<{ __typename?: 'TemplatePermission', id: number, stageNumber?: number | null, levelNumber?: number | null, template?: { __typename?: 'Template', id: number, name?: string | null, code: string, versionId: string, status?: TemplateStatus | null } | null } | null> } } | null, templateActions?: { __typename?: 'TemplateActionsConnection', nodes: Array<{ __typename?: 'TemplateAction', id: number, actionCode?: string | null, condition?: any | null, parameterQueries?: any | null, trigger?: Trigger | null, template?: { __typename?: 'Template', code: string, name?: string | null, versionId: string, status?: TemplateStatus | null } | null } | null> } | null, templateElements?: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', id: number, code: string, parameters?: any | null, title?: string | null, section?: { __typename?: 'TemplateSection', template?: { __typename?: 'Template', code: string, name?: string | null, status?: TemplateStatus | null, versionId: string } | null } | null } | null> } | null, postgresRowLevels?: { __typename?: 'PostgresRowLevelsConnection', nodes: Array<{ __typename?: 'PostgresRowLevel', policyname?: string | null, tablename?: string | null, withCheck?: string | null, qual?: string | null, roles?: Array<string | null> | null, schemaname?: string | null, permissive?: string | null, cmd?: string | null } | null> } | null };

export type GetTemplateElementsByPluginQueryVariables = Exact<{
  pluginCode: Scalars['String']['input'];
}>;


export type GetTemplateElementsByPluginQuery = { __typename?: 'Query', templateElements?: { __typename?: 'TemplateElementsConnection', nodes: Array<{ __typename?: 'TemplateElement', category?: TemplateElementCategory | null, helpText?: string | null, isEditable?: any | null, isRequired?: any | null, parameters?: any | null, validation?: any | null, code: string, title?: string | null, id: number, initialValue?: any | null, validationMessage?: string | null, visibilityCondition?: any | null, templateCode?: string | null } | null> } | null };

export type GetTemplatesAvailableForCodeQueryVariables = Exact<{
  code: Scalars['String']['input'];
}>;


export type GetTemplatesAvailableForCodeQuery = { __typename?: 'Query', templates?: { __typename?: 'TemplatesConnection', nodes: Array<{ __typename?: 'Template', id: number, code: string, status?: TemplateStatus | null } | null> } | null };

export const ApplicationFragmentDoc = gql`
    fragment Application on Application {
  id
  serial
  name
  outcome
  trigger
}
    `;
export const ApplicationResponseFragmentFragmentDoc = gql`
    fragment applicationResponseFragment on ApplicationResponse {
  id
  isValid
  value
  stageNumber
  templateElement {
    code
  }
  templateElementId
  evaluatedParameters
  timeUpdated
}
    `;
export const UserFragmentDoc = gql`
    fragment User on User {
  id
  username
  firstName
  lastName
  email
  dateOfBirth
}
    `;
export const ReviewResponseFragmentFragmentDoc = gql`
    fragment reviewResponseFragment on ReviewResponse {
  id
  applicationResponseId
  decision
  comment
  stageNumber
  status
  timeUpdated
  originalReviewResponseId
  reviewResponseLinkId
  templateElementId
  applicationResponse {
    id
    templateElementId
  }
  review {
    id
    status
    stageNumber
    levelNumber
    reviewer {
      ...User
    }
  }
}
    ${UserFragmentDoc}`;
export const ConsolidatorResponseFragmentFragmentDoc = gql`
    fragment consolidatorResponseFragment on ReviewResponse {
  reviewResponsesByReviewResponseLinkId(orderBy: TIME_UPDATED_DESC, filter: {status: {notEqualTo: DRAFT}}) {
    nodes {
      ...reviewResponseFragment
    }
  }
}
    ${ReviewResponseFragmentFragmentDoc}`;
export const DataViewFragmentFragmentDoc = gql`
    fragment dataViewFragment on DataView {
  id
  identifier
  tableName
  title
  code
  permissionNames
  rowRestrictions
  tableViewIncludeColumns
  tableViewExcludeColumns
  tableSearchColumns
  detailViewIncludeColumns
  detailViewExcludeColumns
  detailViewHeaderColumn
  filterIncludeColumns
  filterExcludeColumns
  showLinkedApplications
  priority
  defaultSortColumn
  defaultFilterString
  submenu
  enabled
}
    `;
export const DataViewColumnDefinitionFragmentFragmentDoc = gql`
    fragment dataViewColumnDefinitionFragment on DataViewColumnDefinition {
  id
  tableName
  columnName
  title
  elementTypePluginCode
  elementParameters
  additionalFormatting
  valueExpression
  sortColumn
  filterParameters
  filterExpression
  filterDataType
}
    `;
export const TemplateFragmentFragmentDoc = gql`
    fragment templateFragment on Template {
  code
  id
  name
  status
  namePlural
  isLinear
  canApplicantMakeChanges
  startMessage
  submissionMessage
  versionId
  serialPattern
  icon
  dashboardRestrictions
  templateCategory {
    id
    code
    title
    icon
    uiLocation
    isSubmenu
  }
  templateFilterJoins {
    nodes {
      id
      filter {
        id
        code
        query
        title
        userRole
      }
    }
  }
  applications(filter: {isConfig: {equalTo: false}}) {
    totalCount
  }
}
    `;
export const SectionFragmentDoc = gql`
    fragment Section on TemplateSection {
  id
  title
  index
  code
}
    `;
export const ElementFragmentFragmentDoc = gql`
    fragment elementFragment on TemplateElement {
  id
  code
  index
  title
  elementTypePluginCode
  category
  visibilityCondition
  isRequired
  isEditable
  validation
  validationMessage
  helpText
  initialValue
  parameters
  reviewability
}
    `;
export const FullTemplateFragmentDoc = gql`
    fragment FullTemplate on Template {
  ...templateFragment
  nodeId
  configApplications: applications(filter: {isConfig: {equalTo: true}}, orderBy: ID_DESC) {
    nodes {
      serial
      id
    }
  }
  versionId
  versionTimestamp
  parentVersionId
  versionComment
  versionHistory
  templateSections(orderBy: INDEX_ASC) {
    nodes {
      ...Section
      templateElementsBySectionId(orderBy: INDEX_ASC) {
        nodes {
          ...elementFragment
        }
      }
    }
  }
  templateActions(orderBy: SEQUENCE_ASC) {
    nodes {
      code
      actionCode
      condition
      eventCode
      id
      parameterQueries
      sequence
      trigger
      description
      templateId
    }
  }
  templatePermissions {
    nodes {
      allowedSections
      canMakeFinalDecision
      canSelfAssign
      id
      levelNumber
      permissionName {
        id
        name
        permissionPolicyId
        permissionPolicy {
          defaultRestrictions
          description
          name
          id
          rules
          type
        }
      }
      restrictions
      stageNumber
      permissionNameId
    }
  }
  templateStages(orderBy: NUMBER_ASC) {
    nodes {
      id
      number
      colour
      title
      description
      templateStageReviewLevelsByStageId(orderBy: NUMBER_ASC) {
        nodes {
          description
          id
          name
          number
        }
      }
    }
  }
}
    ${TemplateFragmentFragmentDoc}
${SectionFragmentDoc}
${ElementFragmentFragmentDoc}`;
export const OrganisationFragmentDoc = gql`
    fragment Organisation on Organisation {
  id
  name
  address
  registration
  logoUrl
}
    `;
export const ReviewAssignmentFragmentDoc = gql`
    fragment ReviewAssignment on ReviewAssignment {
  id
  status
  timeUpdated
  levelNumber
  reviewerId
  isLastLevel
  isFinalDecision
  isSelfAssignable
  allowedSections
  assignedSections
  availableSections
}
    `;
export const StageFragmentDoc = gql`
    fragment Stage on ApplicationStageStatusLatest {
  stage
  stageId
  stageColour
  status
  stageNumber
  statusHistoryTimeCreated
  stageHistoryTimeCreated
}
    `;
export const TemplateStageFragmentDoc = gql`
    fragment TemplateStage on TemplateStage {
  number
  title
  id
  description
  colour
  templateStageReviewLevelsByStageId {
    nodes {
      name
      number
    }
  }
}
    `;
export const CreateApplicationDocument = gql`
    mutation createApplication($name: String!, $isConfig: Boolean = false, $serial: String, $templateId: Int!, $userId: Int, $orgId: Int, $sessionId: String!, $outcome: ApplicationOutcome = PENDING, $trigger: Trigger = ON_APPLICATION_CREATE, $responses: [ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput!]) {
  createApplication(input: {application: {isConfig: $isConfig, name: $name, serial: $serial, templateId: $templateId, userId: $userId, orgId: $orgId, sessionId: $sessionId, isActive: true, outcome: $outcome, trigger: $trigger, applicationResponsesUsingId: {create: $responses}}}) {
    application {
      userId
      orgId
      ...Application
      template {
        ...templateFragment
        templateSections {
          nodes {
            ...Section
          }
        }
      }
    }
  }
}
    ${ApplicationFragmentDoc}
${TemplateFragmentFragmentDoc}
${SectionFragmentDoc}`;
export type CreateApplicationMutationFn = Apollo.MutationFunction<CreateApplicationMutation, CreateApplicationMutationVariables>;

/**
 * __useCreateApplicationMutation__
 *
 * To run a mutation, you first call `useCreateApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createApplicationMutation, { data, loading, error }] = useCreateApplicationMutation({
 *   variables: {
 *      name: // value for 'name'
 *      isConfig: // value for 'isConfig'
 *      serial: // value for 'serial'
 *      templateId: // value for 'templateId'
 *      userId: // value for 'userId'
 *      orgId: // value for 'orgId'
 *      sessionId: // value for 'sessionId'
 *      outcome: // value for 'outcome'
 *      trigger: // value for 'trigger'
 *      responses: // value for 'responses'
 *   },
 * });
 */
export function useCreateApplicationMutation(baseOptions?: Apollo.MutationHookOptions<CreateApplicationMutation, CreateApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateApplicationMutation, CreateApplicationMutationVariables>(CreateApplicationDocument, options);
      }
export type CreateApplicationMutationHookResult = ReturnType<typeof useCreateApplicationMutation>;
export type CreateApplicationMutationResult = Apollo.MutationResult<CreateApplicationMutation>;
export type CreateApplicationMutationOptions = Apollo.BaseMutationOptions<CreateApplicationMutation, CreateApplicationMutationVariables>;
export const CreateNoteDocument = gql`
    mutation createNote($applicationId: Int!, $userId: Int!, $orgId: Int, $comment: String!) {
  createApplicationNote(input: {applicationNote: {comment: $comment, applicationId: $applicationId, orgId: $orgId, userId: $userId}}) {
    applicationNote {
      id
      timestamp
      comment
    }
  }
}
    `;
export type CreateNoteMutationFn = Apollo.MutationFunction<CreateNoteMutation, CreateNoteMutationVariables>;

/**
 * __useCreateNoteMutation__
 *
 * To run a mutation, you first call `useCreateNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNoteMutation, { data, loading, error }] = useCreateNoteMutation({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *      userId: // value for 'userId'
 *      orgId: // value for 'orgId'
 *      comment: // value for 'comment'
 *   },
 * });
 */
export function useCreateNoteMutation(baseOptions?: Apollo.MutationHookOptions<CreateNoteMutation, CreateNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNoteMutation, CreateNoteMutationVariables>(CreateNoteDocument, options);
      }
export type CreateNoteMutationHookResult = ReturnType<typeof useCreateNoteMutation>;
export type CreateNoteMutationResult = Apollo.MutationResult<CreateNoteMutation>;
export type CreateNoteMutationOptions = Apollo.BaseMutationOptions<CreateNoteMutation, CreateNoteMutationVariables>;
export const CreateReviewDocument = gql`
    mutation createReview($reviewInput: ReviewInput!) {
  createReview(input: {review: $reviewInput}) {
    review {
      id
      reviewAssignment {
        id
        reviews {
          nodes {
            id
          }
        }
      }
    }
  }
}
    `;
export type CreateReviewMutationFn = Apollo.MutationFunction<CreateReviewMutation, CreateReviewMutationVariables>;

/**
 * __useCreateReviewMutation__
 *
 * To run a mutation, you first call `useCreateReviewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateReviewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createReviewMutation, { data, loading, error }] = useCreateReviewMutation({
 *   variables: {
 *      reviewInput: // value for 'reviewInput'
 *   },
 * });
 */
export function useCreateReviewMutation(baseOptions?: Apollo.MutationHookOptions<CreateReviewMutation, CreateReviewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateReviewMutation, CreateReviewMutationVariables>(CreateReviewDocument, options);
      }
export type CreateReviewMutationHookResult = ReturnType<typeof useCreateReviewMutation>;
export type CreateReviewMutationResult = Apollo.MutationResult<CreateReviewMutation>;
export type CreateReviewMutationOptions = Apollo.BaseMutationOptions<CreateReviewMutation, CreateReviewMutationVariables>;
export const CreateReviewResponseDocument = gql`
    mutation createReviewResponse($templateElementId: Int!, $applicationId: Int!, $reviewId: Int!, $decision: ReviewResponseDecision!, $comment: String, $timeSubmitted: Datetime) {
  createApplicationResponse(input: {applicationResponse: {templateElementId: $templateElementId, value: null, reviewResponsesUsingId: {create: {comment: $comment, decision: $decision, status: DRAFT, templateElementId: $templateElementId, reviewId: $reviewId, recommendedApplicantVisibility: ORIGINAL_RESPONSE_VISIBLE_TO_APPLICANT}}, applicationId: $applicationId, status: SUBMITTED, timeSubmitted: $timeSubmitted}}) {
    applicationResponse {
      id
      reviewResponses {
        nodes {
          id
          comment
          decision
        }
      }
    }
  }
}
    `;
export type CreateReviewResponseMutationFn = Apollo.MutationFunction<CreateReviewResponseMutation, CreateReviewResponseMutationVariables>;

/**
 * __useCreateReviewResponseMutation__
 *
 * To run a mutation, you first call `useCreateReviewResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateReviewResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createReviewResponseMutation, { data, loading, error }] = useCreateReviewResponseMutation({
 *   variables: {
 *      templateElementId: // value for 'templateElementId'
 *      applicationId: // value for 'applicationId'
 *      reviewId: // value for 'reviewId'
 *      decision: // value for 'decision'
 *      comment: // value for 'comment'
 *      timeSubmitted: // value for 'timeSubmitted'
 *   },
 * });
 */
export function useCreateReviewResponseMutation(baseOptions?: Apollo.MutationHookOptions<CreateReviewResponseMutation, CreateReviewResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateReviewResponseMutation, CreateReviewResponseMutationVariables>(CreateReviewResponseDocument, options);
      }
export type CreateReviewResponseMutationHookResult = ReturnType<typeof useCreateReviewResponseMutation>;
export type CreateReviewResponseMutationResult = Apollo.MutationResult<CreateReviewResponseMutation>;
export type CreateReviewResponseMutationOptions = Apollo.BaseMutationOptions<CreateReviewResponseMutation, CreateReviewResponseMutationVariables>;
export const CreateColumnDefinitionDocument = gql`
    mutation createColumnDefinition($tableName: String!, $columnName: String!) {
  createDataViewColumnDefinition(input: {dataViewColumnDefinition: {tableName: $tableName, columnName: $columnName}}) {
    dataViewColumnDefinition {
      ...dataViewColumnDefinitionFragment
    }
  }
}
    ${DataViewColumnDefinitionFragmentFragmentDoc}`;
export type CreateColumnDefinitionMutationFn = Apollo.MutationFunction<CreateColumnDefinitionMutation, CreateColumnDefinitionMutationVariables>;

/**
 * __useCreateColumnDefinitionMutation__
 *
 * To run a mutation, you first call `useCreateColumnDefinitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateColumnDefinitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createColumnDefinitionMutation, { data, loading, error }] = useCreateColumnDefinitionMutation({
 *   variables: {
 *      tableName: // value for 'tableName'
 *      columnName: // value for 'columnName'
 *   },
 * });
 */
export function useCreateColumnDefinitionMutation(baseOptions?: Apollo.MutationHookOptions<CreateColumnDefinitionMutation, CreateColumnDefinitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateColumnDefinitionMutation, CreateColumnDefinitionMutationVariables>(CreateColumnDefinitionDocument, options);
      }
export type CreateColumnDefinitionMutationHookResult = ReturnType<typeof useCreateColumnDefinitionMutation>;
export type CreateColumnDefinitionMutationResult = Apollo.MutationResult<CreateColumnDefinitionMutation>;
export type CreateColumnDefinitionMutationOptions = Apollo.BaseMutationOptions<CreateColumnDefinitionMutation, CreateColumnDefinitionMutationVariables>;
export const CreateDataViewDocument = gql`
    mutation createDataView($identifier: String!, $tableName: String!, $code: String!, $detailViewHeaderColumn: String!) {
  createDataView(input: {dataView: {identifier: $identifier, tableName: $tableName, code: $code, detailViewHeaderColumn: $detailViewHeaderColumn}}) {
    dataView {
      ...dataViewFragment
    }
  }
}
    ${DataViewFragmentFragmentDoc}`;
export type CreateDataViewMutationFn = Apollo.MutationFunction<CreateDataViewMutation, CreateDataViewMutationVariables>;

/**
 * __useCreateDataViewMutation__
 *
 * To run a mutation, you first call `useCreateDataViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDataViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDataViewMutation, { data, loading, error }] = useCreateDataViewMutation({
 *   variables: {
 *      identifier: // value for 'identifier'
 *      tableName: // value for 'tableName'
 *      code: // value for 'code'
 *      detailViewHeaderColumn: // value for 'detailViewHeaderColumn'
 *   },
 * });
 */
export function useCreateDataViewMutation(baseOptions?: Apollo.MutationHookOptions<CreateDataViewMutation, CreateDataViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDataViewMutation, CreateDataViewMutationVariables>(CreateDataViewDocument, options);
      }
export type CreateDataViewMutationHookResult = ReturnType<typeof useCreateDataViewMutation>;
export type CreateDataViewMutationResult = Apollo.MutationResult<CreateDataViewMutation>;
export type CreateDataViewMutationOptions = Apollo.BaseMutationOptions<CreateDataViewMutation, CreateDataViewMutationVariables>;
export const DeleteColumnDefinitionDocument = gql`
    mutation deleteColumnDefinition($id: Int!) {
  deleteDataViewColumnDefinition(input: {id: $id}) {
    dataViewColumnDefinition {
      id
    }
  }
}
    `;
export type DeleteColumnDefinitionMutationFn = Apollo.MutationFunction<DeleteColumnDefinitionMutation, DeleteColumnDefinitionMutationVariables>;

/**
 * __useDeleteColumnDefinitionMutation__
 *
 * To run a mutation, you first call `useDeleteColumnDefinitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteColumnDefinitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteColumnDefinitionMutation, { data, loading, error }] = useDeleteColumnDefinitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteColumnDefinitionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteColumnDefinitionMutation, DeleteColumnDefinitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteColumnDefinitionMutation, DeleteColumnDefinitionMutationVariables>(DeleteColumnDefinitionDocument, options);
      }
export type DeleteColumnDefinitionMutationHookResult = ReturnType<typeof useDeleteColumnDefinitionMutation>;
export type DeleteColumnDefinitionMutationResult = Apollo.MutationResult<DeleteColumnDefinitionMutation>;
export type DeleteColumnDefinitionMutationOptions = Apollo.BaseMutationOptions<DeleteColumnDefinitionMutation, DeleteColumnDefinitionMutationVariables>;
export const DeleteDataViewDocument = gql`
    mutation deleteDataView($id: Int!) {
  deleteDataView(input: {id: $id}) {
    dataView {
      id
    }
  }
}
    `;
export type DeleteDataViewMutationFn = Apollo.MutationFunction<DeleteDataViewMutation, DeleteDataViewMutationVariables>;

/**
 * __useDeleteDataViewMutation__
 *
 * To run a mutation, you first call `useDeleteDataViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDataViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDataViewMutation, { data, loading, error }] = useDeleteDataViewMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteDataViewMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDataViewMutation, DeleteDataViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDataViewMutation, DeleteDataViewMutationVariables>(DeleteDataViewDocument, options);
      }
export type DeleteDataViewMutationHookResult = ReturnType<typeof useDeleteDataViewMutation>;
export type DeleteDataViewMutationResult = Apollo.MutationResult<DeleteDataViewMutation>;
export type DeleteDataViewMutationOptions = Apollo.BaseMutationOptions<DeleteDataViewMutation, DeleteDataViewMutationVariables>;
export const UpdateColumnDefinitionDocument = gql`
    mutation updateColumnDefinition($id: Int!, $patch: DataViewColumnDefinitionPatch!) {
  updateDataViewColumnDefinition(input: {patch: $patch, id: $id}) {
    dataViewColumnDefinition {
      ...dataViewColumnDefinitionFragment
    }
  }
}
    ${DataViewColumnDefinitionFragmentFragmentDoc}`;
export type UpdateColumnDefinitionMutationFn = Apollo.MutationFunction<UpdateColumnDefinitionMutation, UpdateColumnDefinitionMutationVariables>;

/**
 * __useUpdateColumnDefinitionMutation__
 *
 * To run a mutation, you first call `useUpdateColumnDefinitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateColumnDefinitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateColumnDefinitionMutation, { data, loading, error }] = useUpdateColumnDefinitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      patch: // value for 'patch'
 *   },
 * });
 */
export function useUpdateColumnDefinitionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateColumnDefinitionMutation, UpdateColumnDefinitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateColumnDefinitionMutation, UpdateColumnDefinitionMutationVariables>(UpdateColumnDefinitionDocument, options);
      }
export type UpdateColumnDefinitionMutationHookResult = ReturnType<typeof useUpdateColumnDefinitionMutation>;
export type UpdateColumnDefinitionMutationResult = Apollo.MutationResult<UpdateColumnDefinitionMutation>;
export type UpdateColumnDefinitionMutationOptions = Apollo.BaseMutationOptions<UpdateColumnDefinitionMutation, UpdateColumnDefinitionMutationVariables>;
export const UpdateDataViewDocument = gql`
    mutation updateDataView($id: Int!, $patch: DataViewPatch!) {
  updateDataView(input: {patch: $patch, id: $id}) {
    dataView {
      ...dataViewFragment
    }
  }
}
    ${DataViewFragmentFragmentDoc}`;
export type UpdateDataViewMutationFn = Apollo.MutationFunction<UpdateDataViewMutation, UpdateDataViewMutationVariables>;

/**
 * __useUpdateDataViewMutation__
 *
 * To run a mutation, you first call `useUpdateDataViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDataViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDataViewMutation, { data, loading, error }] = useUpdateDataViewMutation({
 *   variables: {
 *      id: // value for 'id'
 *      patch: // value for 'patch'
 *   },
 * });
 */
export function useUpdateDataViewMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDataViewMutation, UpdateDataViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDataViewMutation, UpdateDataViewMutationVariables>(UpdateDataViewDocument, options);
      }
export type UpdateDataViewMutationHookResult = ReturnType<typeof useUpdateDataViewMutation>;
export type UpdateDataViewMutationResult = Apollo.MutationResult<UpdateDataViewMutation>;
export type UpdateDataViewMutationOptions = Apollo.BaseMutationOptions<UpdateDataViewMutation, UpdateDataViewMutationVariables>;
export const DeleteApplicationDocument = gql`
    mutation deleteApplication($id: Int!) {
  deleteApplication(input: {id: $id}) {
    clientMutationId
  }
}
    `;
export type DeleteApplicationMutationFn = Apollo.MutationFunction<DeleteApplicationMutation, DeleteApplicationMutationVariables>;

/**
 * __useDeleteApplicationMutation__
 *
 * To run a mutation, you first call `useDeleteApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteApplicationMutation, { data, loading, error }] = useDeleteApplicationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteApplicationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteApplicationMutation, DeleteApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteApplicationMutation, DeleteApplicationMutationVariables>(DeleteApplicationDocument, options);
      }
export type DeleteApplicationMutationHookResult = ReturnType<typeof useDeleteApplicationMutation>;
export type DeleteApplicationMutationResult = Apollo.MutationResult<DeleteApplicationMutation>;
export type DeleteApplicationMutationOptions = Apollo.BaseMutationOptions<DeleteApplicationMutation, DeleteApplicationMutationVariables>;
export const DeleteNoteDocument = gql`
    mutation deleteNote($noteId: Int!) {
  deleteApplicationNote(input: {id: $noteId}) {
    applicationNote {
      id
    }
  }
}
    `;
export type DeleteNoteMutationFn = Apollo.MutationFunction<DeleteNoteMutation, DeleteNoteMutationVariables>;

/**
 * __useDeleteNoteMutation__
 *
 * To run a mutation, you first call `useDeleteNoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteNoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteNoteMutation, { data, loading, error }] = useDeleteNoteMutation({
 *   variables: {
 *      noteId: // value for 'noteId'
 *   },
 * });
 */
export function useDeleteNoteMutation(baseOptions?: Apollo.MutationHookOptions<DeleteNoteMutation, DeleteNoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteNoteMutation, DeleteNoteMutationVariables>(DeleteNoteDocument, options);
      }
export type DeleteNoteMutationHookResult = ReturnType<typeof useDeleteNoteMutation>;
export type DeleteNoteMutationResult = Apollo.MutationResult<DeleteNoteMutation>;
export type DeleteNoteMutationOptions = Apollo.BaseMutationOptions<DeleteNoteMutation, DeleteNoteMutationVariables>;
export const RestartApplicationDocument = gql`
    mutation restartApplication($serial: String!, $applicationPatch: ApplicationPatch!) {
  updateApplicationBySerial(input: {serial: $serial, patch: $applicationPatch}) {
    application {
      ...Application
      applicationResponses {
        nodes {
          ...applicationResponseFragment
        }
      }
    }
  }
}
    ${ApplicationFragmentDoc}
${ApplicationResponseFragmentFragmentDoc}`;
export type RestartApplicationMutationFn = Apollo.MutationFunction<RestartApplicationMutation, RestartApplicationMutationVariables>;

/**
 * __useRestartApplicationMutation__
 *
 * To run a mutation, you first call `useRestartApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestartApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restartApplicationMutation, { data, loading, error }] = useRestartApplicationMutation({
 *   variables: {
 *      serial: // value for 'serial'
 *      applicationPatch: // value for 'applicationPatch'
 *   },
 * });
 */
export function useRestartApplicationMutation(baseOptions?: Apollo.MutationHookOptions<RestartApplicationMutation, RestartApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestartApplicationMutation, RestartApplicationMutationVariables>(RestartApplicationDocument, options);
      }
export type RestartApplicationMutationHookResult = ReturnType<typeof useRestartApplicationMutation>;
export type RestartApplicationMutationResult = Apollo.MutationResult<RestartApplicationMutation>;
export type RestartApplicationMutationOptions = Apollo.BaseMutationOptions<RestartApplicationMutation, RestartApplicationMutationVariables>;
export const SubmitReviewDocument = gql`
    mutation submitReview($reviewId: Int!, $trigger: Trigger = ON_REVIEW_SUBMIT, $reviewResponses: [ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate!]) {
  updateReview(input: {id: $reviewId, patch: {trigger: $trigger, reviewResponsesUsingId: {updateById: $reviewResponses}}}) {
    review {
      id
      trigger
    }
  }
}
    `;
export type SubmitReviewMutationFn = Apollo.MutationFunction<SubmitReviewMutation, SubmitReviewMutationVariables>;

/**
 * __useSubmitReviewMutation__
 *
 * To run a mutation, you first call `useSubmitReviewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitReviewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitReviewMutation, { data, loading, error }] = useSubmitReviewMutation({
 *   variables: {
 *      reviewId: // value for 'reviewId'
 *      trigger: // value for 'trigger'
 *      reviewResponses: // value for 'reviewResponses'
 *   },
 * });
 */
export function useSubmitReviewMutation(baseOptions?: Apollo.MutationHookOptions<SubmitReviewMutation, SubmitReviewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitReviewMutation, SubmitReviewMutationVariables>(SubmitReviewDocument, options);
      }
export type SubmitReviewMutationHookResult = ReturnType<typeof useSubmitReviewMutation>;
export type SubmitReviewMutationResult = Apollo.MutationResult<SubmitReviewMutation>;
export type SubmitReviewMutationOptions = Apollo.BaseMutationOptions<SubmitReviewMutation, SubmitReviewMutationVariables>;
export const DeleteTemplateDocument = gql`
    mutation deleteTemplate($id: Int!) {
  deleteTemplate(input: {id: $id}) {
    clientMutationId
  }
}
    `;
export type DeleteTemplateMutationFn = Apollo.MutationFunction<DeleteTemplateMutation, DeleteTemplateMutationVariables>;

/**
 * __useDeleteTemplateMutation__
 *
 * To run a mutation, you first call `useDeleteTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTemplateMutation, { data, loading, error }] = useDeleteTemplateMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteTemplateMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTemplateMutation, DeleteTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTemplateMutation, DeleteTemplateMutationVariables>(DeleteTemplateDocument, options);
      }
export type DeleteTemplateMutationHookResult = ReturnType<typeof useDeleteTemplateMutation>;
export type DeleteTemplateMutationResult = Apollo.MutationResult<DeleteTemplateMutation>;
export type DeleteTemplateMutationOptions = Apollo.BaseMutationOptions<DeleteTemplateMutation, DeleteTemplateMutationVariables>;
export const DeleteWholeApplicationDocument = gql`
    mutation deleteWholeApplication($id: Int!) {
  deleteWholeApplication(input: {applicationId: $id}) {
    clientMutationId
  }
}
    `;
export type DeleteWholeApplicationMutationFn = Apollo.MutationFunction<DeleteWholeApplicationMutation, DeleteWholeApplicationMutationVariables>;

/**
 * __useDeleteWholeApplicationMutation__
 *
 * To run a mutation, you first call `useDeleteWholeApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWholeApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWholeApplicationMutation, { data, loading, error }] = useDeleteWholeApplicationMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteWholeApplicationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWholeApplicationMutation, DeleteWholeApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWholeApplicationMutation, DeleteWholeApplicationMutationVariables>(DeleteWholeApplicationDocument, options);
      }
export type DeleteWholeApplicationMutationHookResult = ReturnType<typeof useDeleteWholeApplicationMutation>;
export type DeleteWholeApplicationMutationResult = Apollo.MutationResult<DeleteWholeApplicationMutation>;
export type DeleteWholeApplicationMutationOptions = Apollo.BaseMutationOptions<DeleteWholeApplicationMutation, DeleteWholeApplicationMutationVariables>;
export const UpdateTemplateDocument = gql`
    mutation updateTemplate($id: Int!, $templatePatch: TemplatePatch!) {
  updateTemplate(input: {id: $id, patch: $templatePatch}) {
    template {
      ...FullTemplate
    }
  }
}
    ${FullTemplateFragmentDoc}`;
export type UpdateTemplateMutationFn = Apollo.MutationFunction<UpdateTemplateMutation, UpdateTemplateMutationVariables>;

/**
 * __useUpdateTemplateMutation__
 *
 * To run a mutation, you first call `useUpdateTemplateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTemplateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTemplateMutation, { data, loading, error }] = useUpdateTemplateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      templatePatch: // value for 'templatePatch'
 *   },
 * });
 */
export function useUpdateTemplateMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTemplateMutation, UpdateTemplateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTemplateMutation, UpdateTemplateMutationVariables>(UpdateTemplateDocument, options);
      }
export type UpdateTemplateMutationHookResult = ReturnType<typeof useUpdateTemplateMutation>;
export type UpdateTemplateMutationResult = Apollo.MutationResult<UpdateTemplateMutation>;
export type UpdateTemplateMutationOptions = Apollo.BaseMutationOptions<UpdateTemplateMutation, UpdateTemplateMutationVariables>;
export const UpdateTemplateFilterJoinDocument = gql`
    mutation updateTemplateFilterJoin($id: Int!, $filterJoinPatch: TemplateFilterJoinPatch!) {
  updateTemplateFilterJoin(input: {patch: $filterJoinPatch, id: $id}) {
    clientMutationId
    templateFilterJoin {
      id
      filterId
      filter {
        id
        code
        query
        title
        userRole
      }
    }
  }
}
    `;
export type UpdateTemplateFilterJoinMutationFn = Apollo.MutationFunction<UpdateTemplateFilterJoinMutation, UpdateTemplateFilterJoinMutationVariables>;

/**
 * __useUpdateTemplateFilterJoinMutation__
 *
 * To run a mutation, you first call `useUpdateTemplateFilterJoinMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTemplateFilterJoinMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTemplateFilterJoinMutation, { data, loading, error }] = useUpdateTemplateFilterJoinMutation({
 *   variables: {
 *      id: // value for 'id'
 *      filterJoinPatch: // value for 'filterJoinPatch'
 *   },
 * });
 */
export function useUpdateTemplateFilterJoinMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTemplateFilterJoinMutation, UpdateTemplateFilterJoinMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTemplateFilterJoinMutation, UpdateTemplateFilterJoinMutationVariables>(UpdateTemplateFilterJoinDocument, options);
      }
export type UpdateTemplateFilterJoinMutationHookResult = ReturnType<typeof useUpdateTemplateFilterJoinMutation>;
export type UpdateTemplateFilterJoinMutationResult = Apollo.MutationResult<UpdateTemplateFilterJoinMutation>;
export type UpdateTemplateFilterJoinMutationOptions = Apollo.BaseMutationOptions<UpdateTemplateFilterJoinMutation, UpdateTemplateFilterJoinMutationVariables>;
export const UpdateTemplateSectionDocument = gql`
    mutation updateTemplateSection($id: Int!, $sectionPatch: TemplateSectionPatch!) {
  updateTemplateSection(input: {id: $id, patch: $sectionPatch}) {
    templateSection {
      id
      index
      code
      templateId
      title
      templateElementsBySectionId {
        nodes {
          ...elementFragment
          applicationResponses {
            nodes {
              id
              application {
                id
                serial
                applicationResponses {
                  nodes {
                    id
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
    ${ElementFragmentFragmentDoc}`;
export type UpdateTemplateSectionMutationFn = Apollo.MutationFunction<UpdateTemplateSectionMutation, UpdateTemplateSectionMutationVariables>;

/**
 * __useUpdateTemplateSectionMutation__
 *
 * To run a mutation, you first call `useUpdateTemplateSectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTemplateSectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTemplateSectionMutation, { data, loading, error }] = useUpdateTemplateSectionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      sectionPatch: // value for 'sectionPatch'
 *   },
 * });
 */
export function useUpdateTemplateSectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTemplateSectionMutation, UpdateTemplateSectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTemplateSectionMutation, UpdateTemplateSectionMutationVariables>(UpdateTemplateSectionDocument, options);
      }
export type UpdateTemplateSectionMutationHookResult = ReturnType<typeof useUpdateTemplateSectionMutation>;
export type UpdateTemplateSectionMutationResult = Apollo.MutationResult<UpdateTemplateSectionMutation>;
export type UpdateTemplateSectionMutationOptions = Apollo.BaseMutationOptions<UpdateTemplateSectionMutation, UpdateTemplateSectionMutationVariables>;
export const UpdateTemplateStageDocument = gql`
    mutation updateTemplateStage($id: Int!, $templateStagePatch: TemplateStagePatch!) {
  updateTemplateStage(input: {id: $id, patch: $templateStagePatch}) {
    templateStage {
      id
      number
      colour
      title
      description
      templateStageReviewLevelsByStageId {
        nodes {
          description
          id
          name
          number
        }
      }
    }
  }
}
    `;
export type UpdateTemplateStageMutationFn = Apollo.MutationFunction<UpdateTemplateStageMutation, UpdateTemplateStageMutationVariables>;

/**
 * __useUpdateTemplateStageMutation__
 *
 * To run a mutation, you first call `useUpdateTemplateStageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTemplateStageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTemplateStageMutation, { data, loading, error }] = useUpdateTemplateStageMutation({
 *   variables: {
 *      id: // value for 'id'
 *      templateStagePatch: // value for 'templateStagePatch'
 *   },
 * });
 */
export function useUpdateTemplateStageMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTemplateStageMutation, UpdateTemplateStageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTemplateStageMutation, UpdateTemplateStageMutationVariables>(UpdateTemplateStageDocument, options);
      }
export type UpdateTemplateStageMutationHookResult = ReturnType<typeof useUpdateTemplateStageMutation>;
export type UpdateTemplateStageMutationResult = Apollo.MutationResult<UpdateTemplateStageMutation>;
export type UpdateTemplateStageMutationOptions = Apollo.BaseMutationOptions<UpdateTemplateStageMutation, UpdateTemplateStageMutationVariables>;
export const UpdateApplicationDocument = gql`
    mutation updateApplication($serial: String!, $applicationTrigger: Trigger = ON_APPLICATION_SUBMIT, $responses: [ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate!]) {
  updateApplicationBySerial(input: {serial: $serial, patch: {trigger: $applicationTrigger, applicationResponsesUsingId: {updateById: $responses}}}) {
    application {
      ...Application
    }
  }
}
    ${ApplicationFragmentDoc}`;
export type UpdateApplicationMutationFn = Apollo.MutationFunction<UpdateApplicationMutation, UpdateApplicationMutationVariables>;

/**
 * __useUpdateApplicationMutation__
 *
 * To run a mutation, you first call `useUpdateApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateApplicationMutation, { data, loading, error }] = useUpdateApplicationMutation({
 *   variables: {
 *      serial: // value for 'serial'
 *      applicationTrigger: // value for 'applicationTrigger'
 *      responses: // value for 'responses'
 *   },
 * });
 */
export function useUpdateApplicationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateApplicationMutation, UpdateApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateApplicationMutation, UpdateApplicationMutationVariables>(UpdateApplicationDocument, options);
      }
export type UpdateApplicationMutationHookResult = ReturnType<typeof useUpdateApplicationMutation>;
export type UpdateApplicationMutationResult = Apollo.MutationResult<UpdateApplicationMutation>;
export type UpdateApplicationMutationOptions = Apollo.BaseMutationOptions<UpdateApplicationMutation, UpdateApplicationMutationVariables>;
export const UpdateResponseDocument = gql`
    mutation updateResponse($id: Int!, $value: JSON, $isValid: Boolean, $stageNumber: Int, $evaluatedParameters: JSON) {
  updateApplicationResponse(input: {id: $id, patch: {value: $value, isValid: $isValid, stageNumber: $stageNumber, evaluatedParameters: $evaluatedParameters}}) {
    applicationResponse {
      ...applicationResponseFragment
      templateElement {
        ...elementFragment
      }
    }
  }
}
    ${ApplicationResponseFragmentFragmentDoc}
${ElementFragmentFragmentDoc}`;
export type UpdateResponseMutationFn = Apollo.MutationFunction<UpdateResponseMutation, UpdateResponseMutationVariables>;

/**
 * __useUpdateResponseMutation__
 *
 * To run a mutation, you first call `useUpdateResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateResponseMutation, { data, loading, error }] = useUpdateResponseMutation({
 *   variables: {
 *      id: // value for 'id'
 *      value: // value for 'value'
 *      isValid: // value for 'isValid'
 *      stageNumber: // value for 'stageNumber'
 *      evaluatedParameters: // value for 'evaluatedParameters'
 *   },
 * });
 */
export function useUpdateResponseMutation(baseOptions?: Apollo.MutationHookOptions<UpdateResponseMutation, UpdateResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateResponseMutation, UpdateResponseMutationVariables>(UpdateResponseDocument, options);
      }
export type UpdateResponseMutationHookResult = ReturnType<typeof useUpdateResponseMutation>;
export type UpdateResponseMutationResult = Apollo.MutationResult<UpdateResponseMutation>;
export type UpdateResponseMutationOptions = Apollo.BaseMutationOptions<UpdateResponseMutation, UpdateResponseMutationVariables>;
export const UpdateReviewDocument = gql`
    mutation updateReview($reviewId: Int!, $reviewPatch: ReviewPatch!) {
  updateReview(input: {id: $reviewId, patch: $reviewPatch}) {
    review {
      id
      trigger
      reviewResponses {
        nodes {
          id
          decision
          comment
        }
      }
      reviewDecisions {
        nodes {
          id
          decision
          comment
          timeUpdated
        }
      }
    }
  }
}
    `;
export type UpdateReviewMutationFn = Apollo.MutationFunction<UpdateReviewMutation, UpdateReviewMutationVariables>;

/**
 * __useUpdateReviewMutation__
 *
 * To run a mutation, you first call `useUpdateReviewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReviewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReviewMutation, { data, loading, error }] = useUpdateReviewMutation({
 *   variables: {
 *      reviewId: // value for 'reviewId'
 *      reviewPatch: // value for 'reviewPatch'
 *   },
 * });
 */
export function useUpdateReviewMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReviewMutation, UpdateReviewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateReviewMutation, UpdateReviewMutationVariables>(UpdateReviewDocument, options);
      }
export type UpdateReviewMutationHookResult = ReturnType<typeof useUpdateReviewMutation>;
export type UpdateReviewMutationResult = Apollo.MutationResult<UpdateReviewMutation>;
export type UpdateReviewMutationOptions = Apollo.BaseMutationOptions<UpdateReviewMutation, UpdateReviewMutationVariables>;
export const UpdateReviewAssignmentDocument = gql`
    mutation updateReviewAssignment($assignmentId: Int!, $assignmentPatch: ReviewAssignmentPatch!) {
  updateReviewAssignment(input: {id: $assignmentId, patch: $assignmentPatch}) {
    reviewAssignment {
      id
      status
      timeUpdated
    }
  }
}
    `;
export type UpdateReviewAssignmentMutationFn = Apollo.MutationFunction<UpdateReviewAssignmentMutation, UpdateReviewAssignmentMutationVariables>;

/**
 * __useUpdateReviewAssignmentMutation__
 *
 * To run a mutation, you first call `useUpdateReviewAssignmentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReviewAssignmentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReviewAssignmentMutation, { data, loading, error }] = useUpdateReviewAssignmentMutation({
 *   variables: {
 *      assignmentId: // value for 'assignmentId'
 *      assignmentPatch: // value for 'assignmentPatch'
 *   },
 * });
 */
export function useUpdateReviewAssignmentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReviewAssignmentMutation, UpdateReviewAssignmentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateReviewAssignmentMutation, UpdateReviewAssignmentMutationVariables>(UpdateReviewAssignmentDocument, options);
      }
export type UpdateReviewAssignmentMutationHookResult = ReturnType<typeof useUpdateReviewAssignmentMutation>;
export type UpdateReviewAssignmentMutationResult = Apollo.MutationResult<UpdateReviewAssignmentMutation>;
export type UpdateReviewAssignmentMutationOptions = Apollo.BaseMutationOptions<UpdateReviewAssignmentMutation, UpdateReviewAssignmentMutationVariables>;
export const UpdateReviewDecisionCommentDocument = gql`
    mutation updateReviewDecisionComment($reviewDecisionId: Int!, $comment: String!) {
  updateReviewDecision(input: {id: $reviewDecisionId, patch: {comment: $comment}}) {
    reviewDecision {
      id
      decision
      comment
    }
  }
}
    `;
export type UpdateReviewDecisionCommentMutationFn = Apollo.MutationFunction<UpdateReviewDecisionCommentMutation, UpdateReviewDecisionCommentMutationVariables>;

/**
 * __useUpdateReviewDecisionCommentMutation__
 *
 * To run a mutation, you first call `useUpdateReviewDecisionCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReviewDecisionCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReviewDecisionCommentMutation, { data, loading, error }] = useUpdateReviewDecisionCommentMutation({
 *   variables: {
 *      reviewDecisionId: // value for 'reviewDecisionId'
 *      comment: // value for 'comment'
 *   },
 * });
 */
export function useUpdateReviewDecisionCommentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReviewDecisionCommentMutation, UpdateReviewDecisionCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateReviewDecisionCommentMutation, UpdateReviewDecisionCommentMutationVariables>(UpdateReviewDecisionCommentDocument, options);
      }
export type UpdateReviewDecisionCommentMutationHookResult = ReturnType<typeof useUpdateReviewDecisionCommentMutation>;
export type UpdateReviewDecisionCommentMutationResult = Apollo.MutationResult<UpdateReviewDecisionCommentMutation>;
export type UpdateReviewDecisionCommentMutationOptions = Apollo.BaseMutationOptions<UpdateReviewDecisionCommentMutation, UpdateReviewDecisionCommentMutationVariables>;
export const UpdateReviewResponseDocument = gql`
    mutation updateReviewResponse($id: Int!, $decision: ReviewResponseDecision, $comment: String, $recommendedApplicantVisibility: ReviewResponseRecommendedApplicantVisibility = ORIGINAL_RESPONSE_NOT_VISIBLE_TO_APPLICANT) {
  updateReviewResponse(input: {id: $id, patch: {decision: $decision, comment: $comment, recommendedApplicantVisibility: $recommendedApplicantVisibility}}) {
    reviewResponse {
      ...reviewResponseFragment
    }
  }
}
    ${ReviewResponseFragmentFragmentDoc}`;
export type UpdateReviewResponseMutationFn = Apollo.MutationFunction<UpdateReviewResponseMutation, UpdateReviewResponseMutationVariables>;

/**
 * __useUpdateReviewResponseMutation__
 *
 * To run a mutation, you first call `useUpdateReviewResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateReviewResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateReviewResponseMutation, { data, loading, error }] = useUpdateReviewResponseMutation({
 *   variables: {
 *      id: // value for 'id'
 *      decision: // value for 'decision'
 *      comment: // value for 'comment'
 *      recommendedApplicantVisibility: // value for 'recommendedApplicantVisibility'
 *   },
 * });
 */
export function useUpdateReviewResponseMutation(baseOptions?: Apollo.MutationHookOptions<UpdateReviewResponseMutation, UpdateReviewResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateReviewResponseMutation, UpdateReviewResponseMutationVariables>(UpdateReviewResponseDocument, options);
      }
export type UpdateReviewResponseMutationHookResult = ReturnType<typeof useUpdateReviewResponseMutation>;
export type UpdateReviewResponseMutationResult = Apollo.MutationResult<UpdateReviewResponseMutation>;
export type UpdateReviewResponseMutationOptions = Apollo.BaseMutationOptions<UpdateReviewResponseMutation, UpdateReviewResponseMutationVariables>;
export const GetAppplicantFilterListDocument = gql`
    query getAppplicantFilterList($searchValue: String!, $templateCode: String!) {
  applicationListFilterApplicant(applicant: $searchValue, templateCode: $templateCode) {
    nodes
    totalCount
  }
}
    `;

/**
 * __useGetAppplicantFilterListQuery__
 *
 * To run a query within a React component, call `useGetAppplicantFilterListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAppplicantFilterListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAppplicantFilterListQuery({
 *   variables: {
 *      searchValue: // value for 'searchValue'
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetAppplicantFilterListQuery(baseOptions: Apollo.QueryHookOptions<GetAppplicantFilterListQuery, GetAppplicantFilterListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAppplicantFilterListQuery, GetAppplicantFilterListQueryVariables>(GetAppplicantFilterListDocument, options);
      }
export function useGetAppplicantFilterListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAppplicantFilterListQuery, GetAppplicantFilterListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAppplicantFilterListQuery, GetAppplicantFilterListQueryVariables>(GetAppplicantFilterListDocument, options);
        }
export type GetAppplicantFilterListQueryHookResult = ReturnType<typeof useGetAppplicantFilterListQuery>;
export type GetAppplicantFilterListLazyQueryHookResult = ReturnType<typeof useGetAppplicantFilterListLazyQuery>;
export type GetAppplicantFilterListQueryResult = Apollo.QueryResult<GetAppplicantFilterListQuery, GetAppplicantFilterListQueryVariables>;
export const GetAssignerFilterListDocument = gql`
    query getAssignerFilterList($searchValue: String!, $templateCode: String!) {
  applicationListFilterAssigner(assigner: $searchValue, templateCode: $templateCode) {
    nodes
    totalCount
  }
}
    `;

/**
 * __useGetAssignerFilterListQuery__
 *
 * To run a query within a React component, call `useGetAssignerFilterListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAssignerFilterListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAssignerFilterListQuery({
 *   variables: {
 *      searchValue: // value for 'searchValue'
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetAssignerFilterListQuery(baseOptions: Apollo.QueryHookOptions<GetAssignerFilterListQuery, GetAssignerFilterListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAssignerFilterListQuery, GetAssignerFilterListQueryVariables>(GetAssignerFilterListDocument, options);
      }
export function useGetAssignerFilterListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAssignerFilterListQuery, GetAssignerFilterListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAssignerFilterListQuery, GetAssignerFilterListQueryVariables>(GetAssignerFilterListDocument, options);
        }
export type GetAssignerFilterListQueryHookResult = ReturnType<typeof useGetAssignerFilterListQuery>;
export type GetAssignerFilterListLazyQueryHookResult = ReturnType<typeof useGetAssignerFilterListLazyQuery>;
export type GetAssignerFilterListQueryResult = Apollo.QueryResult<GetAssignerFilterListQuery, GetAssignerFilterListQueryVariables>;
export const GetOrganisationFilterListDocument = gql`
    query getOrganisationFilterList($searchValue: String!, $templateCode: String!) {
  applicationListFilterOrganisation(organisation: $searchValue, templateCode: $templateCode) {
    nodes
    totalCount
  }
}
    `;

/**
 * __useGetOrganisationFilterListQuery__
 *
 * To run a query within a React component, call `useGetOrganisationFilterListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganisationFilterListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganisationFilterListQuery({
 *   variables: {
 *      searchValue: // value for 'searchValue'
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetOrganisationFilterListQuery(baseOptions: Apollo.QueryHookOptions<GetOrganisationFilterListQuery, GetOrganisationFilterListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganisationFilterListQuery, GetOrganisationFilterListQueryVariables>(GetOrganisationFilterListDocument, options);
      }
export function useGetOrganisationFilterListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganisationFilterListQuery, GetOrganisationFilterListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganisationFilterListQuery, GetOrganisationFilterListQueryVariables>(GetOrganisationFilterListDocument, options);
        }
export type GetOrganisationFilterListQueryHookResult = ReturnType<typeof useGetOrganisationFilterListQuery>;
export type GetOrganisationFilterListLazyQueryHookResult = ReturnType<typeof useGetOrganisationFilterListLazyQuery>;
export type GetOrganisationFilterListQueryResult = Apollo.QueryResult<GetOrganisationFilterListQuery, GetOrganisationFilterListQueryVariables>;
export const GetReviewersFilterListDocument = gql`
    query getReviewersFilterList($searchValue: String!, $templateCode: String!) {
  applicationListFilterReviewer(reviewer: $searchValue, templateCode: $templateCode) {
    nodes
    totalCount
  }
}
    `;

/**
 * __useGetReviewersFilterListQuery__
 *
 * To run a query within a React component, call `useGetReviewersFilterListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReviewersFilterListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReviewersFilterListQuery({
 *   variables: {
 *      searchValue: // value for 'searchValue'
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetReviewersFilterListQuery(baseOptions: Apollo.QueryHookOptions<GetReviewersFilterListQuery, GetReviewersFilterListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReviewersFilterListQuery, GetReviewersFilterListQueryVariables>(GetReviewersFilterListDocument, options);
      }
export function useGetReviewersFilterListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReviewersFilterListQuery, GetReviewersFilterListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReviewersFilterListQuery, GetReviewersFilterListQueryVariables>(GetReviewersFilterListDocument, options);
        }
export type GetReviewersFilterListQueryHookResult = ReturnType<typeof useGetReviewersFilterListQuery>;
export type GetReviewersFilterListLazyQueryHookResult = ReturnType<typeof useGetReviewersFilterListLazyQuery>;
export type GetReviewersFilterListQueryResult = Apollo.QueryResult<GetReviewersFilterListQuery, GetReviewersFilterListQueryVariables>;
export const GetStageFilterListDocument = gql`
    query getStageFilterList($templateCode: String!) {
  applicationListFilterStage(templateCode: $templateCode) {
    nodes
    totalCount
  }
}
    `;

/**
 * __useGetStageFilterListQuery__
 *
 * To run a query within a React component, call `useGetStageFilterListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStageFilterListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStageFilterListQuery({
 *   variables: {
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetStageFilterListQuery(baseOptions: Apollo.QueryHookOptions<GetStageFilterListQuery, GetStageFilterListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStageFilterListQuery, GetStageFilterListQueryVariables>(GetStageFilterListDocument, options);
      }
export function useGetStageFilterListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStageFilterListQuery, GetStageFilterListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStageFilterListQuery, GetStageFilterListQueryVariables>(GetStageFilterListDocument, options);
        }
export type GetStageFilterListQueryHookResult = ReturnType<typeof useGetStageFilterListQuery>;
export type GetStageFilterListLazyQueryHookResult = ReturnType<typeof useGetStageFilterListLazyQuery>;
export type GetStageFilterListQueryResult = Apollo.QueryResult<GetStageFilterListQuery, GetStageFilterListQueryVariables>;
export const GetColumnDefinitionsDocument = gql`
    query getColumnDefinitions($tableName: String!) {
  dataViewColumnDefinitions(condition: {tableName: $tableName}, orderBy: COLUMN_NAME_ASC) {
    nodes {
      ...dataViewColumnDefinitionFragment
    }
  }
}
    ${DataViewColumnDefinitionFragmentFragmentDoc}`;

/**
 * __useGetColumnDefinitionsQuery__
 *
 * To run a query within a React component, call `useGetColumnDefinitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetColumnDefinitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetColumnDefinitionsQuery({
 *   variables: {
 *      tableName: // value for 'tableName'
 *   },
 * });
 */
export function useGetColumnDefinitionsQuery(baseOptions: Apollo.QueryHookOptions<GetColumnDefinitionsQuery, GetColumnDefinitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetColumnDefinitionsQuery, GetColumnDefinitionsQueryVariables>(GetColumnDefinitionsDocument, options);
      }
export function useGetColumnDefinitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetColumnDefinitionsQuery, GetColumnDefinitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetColumnDefinitionsQuery, GetColumnDefinitionsQueryVariables>(GetColumnDefinitionsDocument, options);
        }
export type GetColumnDefinitionsQueryHookResult = ReturnType<typeof useGetColumnDefinitionsQuery>;
export type GetColumnDefinitionsLazyQueryHookResult = ReturnType<typeof useGetColumnDefinitionsLazyQuery>;
export type GetColumnDefinitionsQueryResult = Apollo.QueryResult<GetColumnDefinitionsQuery, GetColumnDefinitionsQueryVariables>;
export const GetDataTablesDocument = gql`
    query getDataTables {
  dataTables {
    nodes {
      tableName
      id
      isLookupTable
      displayName
    }
  }
  dataViews {
    nodes {
      tableName
    }
  }
}
    `;

/**
 * __useGetDataTablesQuery__
 *
 * To run a query within a React component, call `useGetDataTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDataTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDataTablesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetDataTablesQuery(baseOptions?: Apollo.QueryHookOptions<GetDataTablesQuery, GetDataTablesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDataTablesQuery, GetDataTablesQueryVariables>(GetDataTablesDocument, options);
      }
export function useGetDataTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDataTablesQuery, GetDataTablesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDataTablesQuery, GetDataTablesQueryVariables>(GetDataTablesDocument, options);
        }
export type GetDataTablesQueryHookResult = ReturnType<typeof useGetDataTablesQuery>;
export type GetDataTablesLazyQueryHookResult = ReturnType<typeof useGetDataTablesLazyQuery>;
export type GetDataTablesQueryResult = Apollo.QueryResult<GetDataTablesQuery, GetDataTablesQueryVariables>;
export const GetDataViewsDocument = gql`
    query getDataViews($tableName: String!) {
  dataViews(condition: {tableName: $tableName}, orderBy: TABLE_NAME_ASC) {
    nodes {
      ...dataViewFragment
    }
  }
}
    ${DataViewFragmentFragmentDoc}`;

/**
 * __useGetDataViewsQuery__
 *
 * To run a query within a React component, call `useGetDataViewsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDataViewsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDataViewsQuery({
 *   variables: {
 *      tableName: // value for 'tableName'
 *   },
 * });
 */
export function useGetDataViewsQuery(baseOptions: Apollo.QueryHookOptions<GetDataViewsQuery, GetDataViewsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDataViewsQuery, GetDataViewsQueryVariables>(GetDataViewsDocument, options);
      }
export function useGetDataViewsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDataViewsQuery, GetDataViewsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDataViewsQuery, GetDataViewsQueryVariables>(GetDataViewsDocument, options);
        }
export type GetDataViewsQueryHookResult = ReturnType<typeof useGetDataViewsQuery>;
export type GetDataViewsLazyQueryHookResult = ReturnType<typeof useGetDataViewsLazyQuery>;
export type GetDataViewsQueryResult = Apollo.QueryResult<GetDataViewsQuery, GetDataViewsQueryVariables>;
export const GetActivityLogDocument = gql`
    query getActivityLog($applicationId: Int!) {
  activityLogs(condition: {applicationId: $applicationId}, orderBy: TIMESTAMP_ASC) {
    nodes {
      value
      type
      timestamp
      table
      recordId
      nodeId
      id
      details
      applicationId
    }
  }
}
    `;

/**
 * __useGetActivityLogQuery__
 *
 * To run a query within a React component, call `useGetActivityLogQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActivityLogQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActivityLogQuery({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *   },
 * });
 */
export function useGetActivityLogQuery(baseOptions: Apollo.QueryHookOptions<GetActivityLogQuery, GetActivityLogQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActivityLogQuery, GetActivityLogQueryVariables>(GetActivityLogDocument, options);
      }
export function useGetActivityLogLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActivityLogQuery, GetActivityLogQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActivityLogQuery, GetActivityLogQueryVariables>(GetActivityLogDocument, options);
        }
export type GetActivityLogQueryHookResult = ReturnType<typeof useGetActivityLogQuery>;
export type GetActivityLogLazyQueryHookResult = ReturnType<typeof useGetActivityLogLazyQuery>;
export type GetActivityLogQueryResult = Apollo.QueryResult<GetActivityLogQuery, GetActivityLogQueryVariables>;
export const GetAllLookupTableStructuresDocument = gql`
    query getAllLookupTableStructures {
  dataTables(condition: {isLookupTable: true}) {
    nodes {
      id
      tableName
      displayName
      fieldMap
    }
  }
}
    `;

/**
 * __useGetAllLookupTableStructuresQuery__
 *
 * To run a query within a React component, call `useGetAllLookupTableStructuresQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllLookupTableStructuresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllLookupTableStructuresQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllLookupTableStructuresQuery(baseOptions?: Apollo.QueryHookOptions<GetAllLookupTableStructuresQuery, GetAllLookupTableStructuresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllLookupTableStructuresQuery, GetAllLookupTableStructuresQueryVariables>(GetAllLookupTableStructuresDocument, options);
      }
export function useGetAllLookupTableStructuresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllLookupTableStructuresQuery, GetAllLookupTableStructuresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllLookupTableStructuresQuery, GetAllLookupTableStructuresQueryVariables>(GetAllLookupTableStructuresDocument, options);
        }
export type GetAllLookupTableStructuresQueryHookResult = ReturnType<typeof useGetAllLookupTableStructuresQuery>;
export type GetAllLookupTableStructuresLazyQueryHookResult = ReturnType<typeof useGetAllLookupTableStructuresLazyQuery>;
export type GetAllLookupTableStructuresQueryResult = Apollo.QueryResult<GetAllLookupTableStructuresQuery, GetAllLookupTableStructuresQueryVariables>;
export const GetAllResponsesDocument = gql`
    query getAllResponses($serial: String!, $responseStatuses: [ApplicationResponseStatus!]) {
  applicationBySerial(serial: $serial) {
    id
    serial
    applicationResponses(orderBy: TIME_UPDATED_DESC, filter: {status: {in: $responseStatuses}}) {
      nodes {
        ...applicationResponseFragment
        reviewResponses(condition: {isVisibleToApplicant: true}) {
          nodes {
            ...reviewResponseFragment
          }
        }
      }
    }
  }
}
    ${ApplicationResponseFragmentFragmentDoc}
${ReviewResponseFragmentFragmentDoc}`;

/**
 * __useGetAllResponsesQuery__
 *
 * To run a query within a React component, call `useGetAllResponsesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllResponsesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllResponsesQuery({
 *   variables: {
 *      serial: // value for 'serial'
 *      responseStatuses: // value for 'responseStatuses'
 *   },
 * });
 */
export function useGetAllResponsesQuery(baseOptions: Apollo.QueryHookOptions<GetAllResponsesQuery, GetAllResponsesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllResponsesQuery, GetAllResponsesQueryVariables>(GetAllResponsesDocument, options);
      }
export function useGetAllResponsesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllResponsesQuery, GetAllResponsesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllResponsesQuery, GetAllResponsesQueryVariables>(GetAllResponsesDocument, options);
        }
export type GetAllResponsesQueryHookResult = ReturnType<typeof useGetAllResponsesQuery>;
export type GetAllResponsesLazyQueryHookResult = ReturnType<typeof useGetAllResponsesLazyQuery>;
export type GetAllResponsesQueryResult = Apollo.QueryResult<GetAllResponsesQuery, GetAllResponsesQueryVariables>;
export const GetApplicationDocument = gql`
    query getApplication($serial: String!) {
  applicationBySerial(serial: $serial) {
    ...Application
    template {
      ...templateFragment
      templateSections(orderBy: INDEX_ASC) {
        nodes {
          ...Section
          templateElementsBySectionId(orderBy: INDEX_ASC) {
            nodes {
              ...elementFragment
            }
          }
        }
      }
      templateStages {
        nodes {
          ...TemplateStage
        }
      }
      previewActions: templateActions(condition: {trigger: ON_PREVIEW}) {
        totalCount
      }
    }
    user {
      ...User
    }
    org {
      ...Organisation
    }
    triggerSchedules {
      nodes {
        id
        timeScheduled
        eventCode
        isActive
      }
    }
  }
  applicationStageStatusLatests(condition: {serial: $serial}) {
    nodes {
      ...Stage
    }
  }
}
    ${ApplicationFragmentDoc}
${TemplateFragmentFragmentDoc}
${SectionFragmentDoc}
${ElementFragmentFragmentDoc}
${TemplateStageFragmentDoc}
${UserFragmentDoc}
${OrganisationFragmentDoc}
${StageFragmentDoc}`;

/**
 * __useGetApplicationQuery__
 *
 * To run a query within a React component, call `useGetApplicationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationQuery({
 *   variables: {
 *      serial: // value for 'serial'
 *   },
 * });
 */
export function useGetApplicationQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationQuery, GetApplicationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationQuery, GetApplicationQueryVariables>(GetApplicationDocument, options);
      }
export function useGetApplicationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationQuery, GetApplicationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationQuery, GetApplicationQueryVariables>(GetApplicationDocument, options);
        }
export type GetApplicationQueryHookResult = ReturnType<typeof useGetApplicationQuery>;
export type GetApplicationLazyQueryHookResult = ReturnType<typeof useGetApplicationLazyQuery>;
export type GetApplicationQueryResult = Apollo.QueryResult<GetApplicationQuery, GetApplicationQueryVariables>;
export const GetFilteredApplicationCountDocument = gql`
    query getFilteredApplicationCount($filter: ApplicationListShapeFilter, $userId: Int! = 0) {
  applicationList(filter: $filter, userid: $userId) {
    totalCount
  }
}
    `;

/**
 * __useGetFilteredApplicationCountQuery__
 *
 * To run a query within a React component, call `useGetFilteredApplicationCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFilteredApplicationCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFilteredApplicationCountQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetFilteredApplicationCountQuery(baseOptions?: Apollo.QueryHookOptions<GetFilteredApplicationCountQuery, GetFilteredApplicationCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFilteredApplicationCountQuery, GetFilteredApplicationCountQueryVariables>(GetFilteredApplicationCountDocument, options);
      }
export function useGetFilteredApplicationCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFilteredApplicationCountQuery, GetFilteredApplicationCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFilteredApplicationCountQuery, GetFilteredApplicationCountQueryVariables>(GetFilteredApplicationCountDocument, options);
        }
export type GetFilteredApplicationCountQueryHookResult = ReturnType<typeof useGetFilteredApplicationCountQuery>;
export type GetFilteredApplicationCountLazyQueryHookResult = ReturnType<typeof useGetFilteredApplicationCountLazyQuery>;
export type GetFilteredApplicationCountQueryResult = Apollo.QueryResult<GetFilteredApplicationCountQuery, GetFilteredApplicationCountQueryVariables>;
export const GetApplicationSerialDocument = gql`
    query getApplicationSerial($id: Int!) {
  application(id: $id) {
    serial
    name
    trigger
  }
}
    `;

/**
 * __useGetApplicationSerialQuery__
 *
 * To run a query within a React component, call `useGetApplicationSerialQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationSerialQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationSerialQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetApplicationSerialQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationSerialQuery, GetApplicationSerialQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationSerialQuery, GetApplicationSerialQueryVariables>(GetApplicationSerialDocument, options);
      }
export function useGetApplicationSerialLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationSerialQuery, GetApplicationSerialQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationSerialQuery, GetApplicationSerialQueryVariables>(GetApplicationSerialDocument, options);
        }
export type GetApplicationSerialQueryHookResult = ReturnType<typeof useGetApplicationSerialQuery>;
export type GetApplicationSerialLazyQueryHookResult = ReturnType<typeof useGetApplicationSerialLazyQuery>;
export type GetApplicationSerialQueryResult = Apollo.QueryResult<GetApplicationSerialQuery, GetApplicationSerialQueryVariables>;
export const GetApplicationListDocument = gql`
    query getApplicationList($filters: ApplicationListShapeFilter, $sortFields: [ApplicationListShapesOrderBy!], $paginationOffset: Int, $numberToFetch: Int, $userId: Int! = 0, $templateCode: String!) {
  applicationList(filter: $filters, orderBy: $sortFields, offset: $paginationOffset, first: $numberToFetch, userid: $userId) {
    nodes {
      id
      serial
      name
      templateCode
      templateName
      applicant
      orgName
      stage
      stageColour
      status
      outcome
      lastActiveDate
      applicantDeadline
      reviewerAction
      assignerAction
      assigners
      reviewers
    }
    pageInfo {
      hasPreviousPage
      hasNextPage
    }
    totalCount
  }
  templates(condition: {status: AVAILABLE, code: $templateCode}) {
    nodes {
      code
      name
      namePlural
    }
  }
}
    `;

/**
 * __useGetApplicationListQuery__
 *
 * To run a query within a React component, call `useGetApplicationListQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationListQuery({
 *   variables: {
 *      filters: // value for 'filters'
 *      sortFields: // value for 'sortFields'
 *      paginationOffset: // value for 'paginationOffset'
 *      numberToFetch: // value for 'numberToFetch'
 *      userId: // value for 'userId'
 *      templateCode: // value for 'templateCode'
 *   },
 * });
 */
export function useGetApplicationListQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationListQuery, GetApplicationListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationListQuery, GetApplicationListQueryVariables>(GetApplicationListDocument, options);
      }
export function useGetApplicationListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationListQuery, GetApplicationListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationListQuery, GetApplicationListQueryVariables>(GetApplicationListDocument, options);
        }
export type GetApplicationListQueryHookResult = ReturnType<typeof useGetApplicationListQuery>;
export type GetApplicationListLazyQueryHookResult = ReturnType<typeof useGetApplicationListLazyQuery>;
export type GetApplicationListQueryResult = Apollo.QueryResult<GetApplicationListQuery, GetApplicationListQueryVariables>;
export const GetApplicationDocsDocument = gql`
    query getApplicationDocs($applicationSerial: String!) {
  files(condition: {applicationSerial: $applicationSerial, isOutputDoc: true}) {
    nodes {
      uniqueId
      description
      filePath
      originalFilename
      thumbnailPath
      timestamp
    }
  }
}
    `;

/**
 * __useGetApplicationDocsQuery__
 *
 * To run a query within a React component, call `useGetApplicationDocsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationDocsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationDocsQuery({
 *   variables: {
 *      applicationSerial: // value for 'applicationSerial'
 *   },
 * });
 */
export function useGetApplicationDocsQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationDocsQuery, GetApplicationDocsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationDocsQuery, GetApplicationDocsQueryVariables>(GetApplicationDocsDocument, options);
      }
export function useGetApplicationDocsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationDocsQuery, GetApplicationDocsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationDocsQuery, GetApplicationDocsQueryVariables>(GetApplicationDocsDocument, options);
        }
export type GetApplicationDocsQueryHookResult = ReturnType<typeof useGetApplicationDocsQuery>;
export type GetApplicationDocsLazyQueryHookResult = ReturnType<typeof useGetApplicationDocsLazyQuery>;
export type GetApplicationDocsQueryResult = Apollo.QueryResult<GetApplicationDocsQuery, GetApplicationDocsQueryVariables>;
export const GetHistoryForApplicantDocument = gql`
    query getHistoryForApplicant($serial: String!, $questionCode: String!, $templateCode: String!, $templateVersionId: String!) {
  templateElementByTemplateCodeAndCodeAndTemplateVersion(code: $questionCode, templateCode: $templateCode, templateVersion: $templateVersionId) {
    ...elementFragment
    reviewResponses(filter: {isVisibleToApplicant: {equalTo: true}}) {
      nodes {
        ...reviewResponseFragment
        review {
          stageNumber
        }
      }
    }
    applicationResponses(filter: {application: {serial: {equalTo: $serial}}}) {
      nodes {
        ...applicationResponseFragment
        application {
          ...Application
          user {
            ...User
          }
          stageNumber
        }
      }
    }
  }
}
    ${ElementFragmentFragmentDoc}
${ReviewResponseFragmentFragmentDoc}
${ApplicationResponseFragmentFragmentDoc}
${ApplicationFragmentDoc}
${UserFragmentDoc}`;

/**
 * __useGetHistoryForApplicantQuery__
 *
 * To run a query within a React component, call `useGetHistoryForApplicantQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHistoryForApplicantQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHistoryForApplicantQuery({
 *   variables: {
 *      serial: // value for 'serial'
 *      questionCode: // value for 'questionCode'
 *      templateCode: // value for 'templateCode'
 *      templateVersionId: // value for 'templateVersionId'
 *   },
 * });
 */
export function useGetHistoryForApplicantQuery(baseOptions: Apollo.QueryHookOptions<GetHistoryForApplicantQuery, GetHistoryForApplicantQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHistoryForApplicantQuery, GetHistoryForApplicantQueryVariables>(GetHistoryForApplicantDocument, options);
      }
export function useGetHistoryForApplicantLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHistoryForApplicantQuery, GetHistoryForApplicantQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHistoryForApplicantQuery, GetHistoryForApplicantQueryVariables>(GetHistoryForApplicantDocument, options);
        }
export type GetHistoryForApplicantQueryHookResult = ReturnType<typeof useGetHistoryForApplicantQuery>;
export type GetHistoryForApplicantLazyQueryHookResult = ReturnType<typeof useGetHistoryForApplicantLazyQuery>;
export type GetHistoryForApplicantQueryResult = Apollo.QueryResult<GetHistoryForApplicantQuery, GetHistoryForApplicantQueryVariables>;
export const GetHistoryForReviewerDocument = gql`
    query getHistoryForReviewer($serial: String!, $questionCode: String!, $templateCode: String!, $templateVersionId: String!, $userId: Int!) {
  templateElementByTemplateCodeAndCodeAndTemplateVersion(code: $questionCode, templateCode: $templateCode, templateVersion: $templateVersionId) {
    ...elementFragment
    reviewResponses(filter: {review: {application: {serial: {equalTo: $serial}}}, or: [{status: {equalTo: SUBMITTED}}, {and: [{status: {equalTo: DRAFT}}, {review: {reviewer: {id: {equalTo: $userId}}}}]}]}) {
      nodes {
        ...reviewResponseFragment
        review {
          stageNumber
        }
      }
    }
    applicationResponses(filter: {application: {serial: {equalTo: $serial}}, status: {equalTo: SUBMITTED}}) {
      nodes {
        ...applicationResponseFragment
        application {
          ...Application
          user {
            ...User
          }
          stageNumber
        }
      }
    }
  }
}
    ${ElementFragmentFragmentDoc}
${ReviewResponseFragmentFragmentDoc}
${ApplicationResponseFragmentFragmentDoc}
${ApplicationFragmentDoc}
${UserFragmentDoc}`;

/**
 * __useGetHistoryForReviewerQuery__
 *
 * To run a query within a React component, call `useGetHistoryForReviewerQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHistoryForReviewerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHistoryForReviewerQuery({
 *   variables: {
 *      serial: // value for 'serial'
 *      questionCode: // value for 'questionCode'
 *      templateCode: // value for 'templateCode'
 *      templateVersionId: // value for 'templateVersionId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetHistoryForReviewerQuery(baseOptions: Apollo.QueryHookOptions<GetHistoryForReviewerQuery, GetHistoryForReviewerQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHistoryForReviewerQuery, GetHistoryForReviewerQueryVariables>(GetHistoryForReviewerDocument, options);
      }
export function useGetHistoryForReviewerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHistoryForReviewerQuery, GetHistoryForReviewerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHistoryForReviewerQuery, GetHistoryForReviewerQueryVariables>(GetHistoryForReviewerDocument, options);
        }
export type GetHistoryForReviewerQueryHookResult = ReturnType<typeof useGetHistoryForReviewerQuery>;
export type GetHistoryForReviewerLazyQueryHookResult = ReturnType<typeof useGetHistoryForReviewerLazyQuery>;
export type GetHistoryForReviewerQueryResult = Apollo.QueryResult<GetHistoryForReviewerQuery, GetHistoryForReviewerQueryVariables>;
export const GetLookupTableStructureByIdDocument = gql`
    query getLookupTableStructureById($lookupTableID: Int!) {
  dataTable(id: $lookupTableID) {
    id
    displayName
    tableName
    fieldMap
    dataViewCode
  }
}
    `;

/**
 * __useGetLookupTableStructureByIdQuery__
 *
 * To run a query within a React component, call `useGetLookupTableStructureByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLookupTableStructureByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLookupTableStructureByIdQuery({
 *   variables: {
 *      lookupTableID: // value for 'lookupTableID'
 *   },
 * });
 */
export function useGetLookupTableStructureByIdQuery(baseOptions: Apollo.QueryHookOptions<GetLookupTableStructureByIdQuery, GetLookupTableStructureByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLookupTableStructureByIdQuery, GetLookupTableStructureByIdQueryVariables>(GetLookupTableStructureByIdDocument, options);
      }
export function useGetLookupTableStructureByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLookupTableStructureByIdQuery, GetLookupTableStructureByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLookupTableStructureByIdQuery, GetLookupTableStructureByIdQueryVariables>(GetLookupTableStructureByIdDocument, options);
        }
export type GetLookupTableStructureByIdQueryHookResult = ReturnType<typeof useGetLookupTableStructureByIdQuery>;
export type GetLookupTableStructureByIdLazyQueryHookResult = ReturnType<typeof useGetLookupTableStructureByIdLazyQuery>;
export type GetLookupTableStructureByIdQueryResult = Apollo.QueryResult<GetLookupTableStructureByIdQuery, GetLookupTableStructureByIdQueryVariables>;
export const GetApplicationNotesDocument = gql`
    query getApplicationNotes($applicationId: Int!) {
  applicationNotes(condition: {applicationId: $applicationId}, orderBy: TIMESTAMP_DESC) {
    nodes {
      id
      comment
      org {
        id
        name
      }
      user {
        fullName
        id
        username
      }
      files {
        nodes {
          filePath
          description
          id
          originalFilename
          uniqueId
        }
      }
      timestamp
    }
  }
}
    `;

/**
 * __useGetApplicationNotesQuery__
 *
 * To run a query within a React component, call `useGetApplicationNotesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationNotesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationNotesQuery({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *   },
 * });
 */
export function useGetApplicationNotesQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationNotesQuery, GetApplicationNotesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationNotesQuery, GetApplicationNotesQueryVariables>(GetApplicationNotesDocument, options);
      }
export function useGetApplicationNotesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationNotesQuery, GetApplicationNotesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationNotesQuery, GetApplicationNotesQueryVariables>(GetApplicationNotesDocument, options);
        }
export type GetApplicationNotesQueryHookResult = ReturnType<typeof useGetApplicationNotesQuery>;
export type GetApplicationNotesLazyQueryHookResult = ReturnType<typeof useGetApplicationNotesLazyQuery>;
export type GetApplicationNotesQueryResult = Apollo.QueryResult<GetApplicationNotesQuery, GetApplicationNotesQueryVariables>;
export const GetRefDocsDocument = gql`
    query getRefDocs {
  files(filter: {or: [{isInternalReferenceDoc: {equalTo: true}}, {isExternalReferenceDoc: {equalTo: true}}]}) {
    nodes {
      uniqueId
      description
      isInternalReferenceDoc
      isExternalReferenceDoc
    }
  }
}
    `;

/**
 * __useGetRefDocsQuery__
 *
 * To run a query within a React component, call `useGetRefDocsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRefDocsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRefDocsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetRefDocsQuery(baseOptions?: Apollo.QueryHookOptions<GetRefDocsQuery, GetRefDocsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRefDocsQuery, GetRefDocsQueryVariables>(GetRefDocsDocument, options);
      }
export function useGetRefDocsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRefDocsQuery, GetRefDocsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRefDocsQuery, GetRefDocsQueryVariables>(GetRefDocsDocument, options);
        }
export type GetRefDocsQueryHookResult = ReturnType<typeof useGetRefDocsQuery>;
export type GetRefDocsLazyQueryHookResult = ReturnType<typeof useGetRefDocsLazyQuery>;
export type GetRefDocsQueryResult = Apollo.QueryResult<GetRefDocsQuery, GetRefDocsQueryVariables>;
export const GetReviewDecisionCommentDocument = gql`
    query getReviewDecisionComment($reviewDecisionId: Int!) {
  reviewDecision(id: $reviewDecisionId) {
    id
    comment
  }
}
    `;

/**
 * __useGetReviewDecisionCommentQuery__
 *
 * To run a query within a React component, call `useGetReviewDecisionCommentQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReviewDecisionCommentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReviewDecisionCommentQuery({
 *   variables: {
 *      reviewDecisionId: // value for 'reviewDecisionId'
 *   },
 * });
 */
export function useGetReviewDecisionCommentQuery(baseOptions: Apollo.QueryHookOptions<GetReviewDecisionCommentQuery, GetReviewDecisionCommentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReviewDecisionCommentQuery, GetReviewDecisionCommentQueryVariables>(GetReviewDecisionCommentDocument, options);
      }
export function useGetReviewDecisionCommentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReviewDecisionCommentQuery, GetReviewDecisionCommentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReviewDecisionCommentQuery, GetReviewDecisionCommentQueryVariables>(GetReviewDecisionCommentDocument, options);
        }
export type GetReviewDecisionCommentQueryHookResult = ReturnType<typeof useGetReviewDecisionCommentQuery>;
export type GetReviewDecisionCommentLazyQueryHookResult = ReturnType<typeof useGetReviewDecisionCommentLazyQuery>;
export type GetReviewDecisionCommentQueryResult = Apollo.QueryResult<GetReviewDecisionCommentQuery, GetReviewDecisionCommentQueryVariables>;
export const GetReviewInfoDocument = gql`
    query getReviewInfo($applicationId: Int, $assignerId: Int!) {
  reviewAssignments(condition: {applicationId: $applicationId}, orderBy: TIME_UPDATED_DESC) {
    nodes {
      ...ReviewAssignment
      stage {
        id
        number
        title
        colour
      }
      timeStageCreated
      trigger
      reviewer {
        id
        firstName
        lastName
      }
      reviews {
        nodes {
          id
          status
          timeStatusCreated
          trigger
          isLocked
          reviewDecisions(orderBy: TIME_UPDATED_DESC) {
            nodes {
              id
              decision
            }
          }
        }
      }
      reviewAssignmentAssignerJoins(filter: {assignerId: {equalTo: $assignerId}}) {
        nodes {
          assigner {
            firstName
            lastName
            id
          }
        }
      }
    }
  }
}
    ${ReviewAssignmentFragmentDoc}`;

/**
 * __useGetReviewInfoQuery__
 *
 * To run a query within a React component, call `useGetReviewInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReviewInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReviewInfoQuery({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *      assignerId: // value for 'assignerId'
 *   },
 * });
 */
export function useGetReviewInfoQuery(baseOptions: Apollo.QueryHookOptions<GetReviewInfoQuery, GetReviewInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReviewInfoQuery, GetReviewInfoQueryVariables>(GetReviewInfoDocument, options);
      }
export function useGetReviewInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReviewInfoQuery, GetReviewInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReviewInfoQuery, GetReviewInfoQueryVariables>(GetReviewInfoDocument, options);
        }
export type GetReviewInfoQueryHookResult = ReturnType<typeof useGetReviewInfoQuery>;
export type GetReviewInfoLazyQueryHookResult = ReturnType<typeof useGetReviewInfoLazyQuery>;
export type GetReviewInfoQueryResult = Apollo.QueryResult<GetReviewInfoQuery, GetReviewInfoQueryVariables>;
export const GetReviewResponsesDocument = gql`
    query getReviewResponses($reviewAssignmentId: Int!, $userId: Int!, $sectionIds: [Int!], $applicationId: Int!, $previousLevel: Int!, $stageNumber: Int!, $shouldIncludePreviousStage: Boolean! = false, $previousStage: Int) {
  thisReviewResponses: reviewResponses(orderBy: TIME_UPDATED_DESC, filter: {review: {reviewAssignmentId: {equalTo: $reviewAssignmentId}}, templateElement: {section: {id: {in: $sectionIds}}}, or: [{status: {notEqualTo: DRAFT}}, {and: [{status: {equalTo: DRAFT}}, {review: {reviewer: {id: {equalTo: $userId}}}}]}]}) {
    nodes {
      ...reviewResponseFragment
      ...consolidatorResponseFragment
      reviewResponseLink {
        ...reviewResponseFragment
      }
    }
  }
  previousLevelReviewResponses: reviewResponses(orderBy: TIME_UPDATED_DESC, filter: {review: {applicationId: {equalTo: $applicationId}, levelNumber: {equalTo: $previousLevel}, stageNumber: {equalTo: $stageNumber}}, templateElement: {section: {id: {in: $sectionIds}}}, status: {notEqualTo: DRAFT}}) {
    nodes {
      ...reviewResponseFragment
    }
  }
  originalReviewResponses: reviewResponses(orderBy: TIME_UPDATED_DESC, filter: {review: {applicationId: {equalTo: $applicationId}, levelNumber: {equalTo: 1}, stageNumber: {equalTo: $stageNumber}}, templateElement: {section: {id: {in: $sectionIds}}}, status: {notEqualTo: DRAFT}}) {
    nodes {
      ...reviewResponseFragment
    }
  }
  previousOriginalReviewResponses: reviewResponses(orderBy: TIME_UPDATED_DESC, filter: {review: {applicationId: {equalTo: $applicationId}, levelNumber: {equalTo: 1}, stageNumber: {equalTo: $previousStage}}, templateElement: {section: {id: {in: $sectionIds}}}, status: {notEqualTo: DRAFT}}) @include(if: $shouldIncludePreviousStage) {
    nodes {
      ...reviewResponseFragment
    }
  }
}
    ${ReviewResponseFragmentFragmentDoc}
${ConsolidatorResponseFragmentFragmentDoc}`;

/**
 * __useGetReviewResponsesQuery__
 *
 * To run a query within a React component, call `useGetReviewResponsesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReviewResponsesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReviewResponsesQuery({
 *   variables: {
 *      reviewAssignmentId: // value for 'reviewAssignmentId'
 *      userId: // value for 'userId'
 *      sectionIds: // value for 'sectionIds'
 *      applicationId: // value for 'applicationId'
 *      previousLevel: // value for 'previousLevel'
 *      stageNumber: // value for 'stageNumber'
 *      shouldIncludePreviousStage: // value for 'shouldIncludePreviousStage'
 *      previousStage: // value for 'previousStage'
 *   },
 * });
 */
export function useGetReviewResponsesQuery(baseOptions: Apollo.QueryHookOptions<GetReviewResponsesQuery, GetReviewResponsesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReviewResponsesQuery, GetReviewResponsesQueryVariables>(GetReviewResponsesDocument, options);
      }
export function useGetReviewResponsesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReviewResponsesQuery, GetReviewResponsesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReviewResponsesQuery, GetReviewResponsesQueryVariables>(GetReviewResponsesDocument, options);
        }
export type GetReviewResponsesQueryHookResult = ReturnType<typeof useGetReviewResponsesQuery>;
export type GetReviewResponsesLazyQueryHookResult = ReturnType<typeof useGetReviewResponsesLazyQuery>;
export type GetReviewResponsesQueryResult = Apollo.QueryResult<GetReviewResponsesQuery, GetReviewResponsesQueryVariables>;
export const GetReviewableQuestionCountsDocument = gql`
    query getReviewableQuestionCounts($applicationId: Int!, $stageId: Int!, $levelNumber: Int!) {
  reviewableQuestions(appId: $applicationId) {
    totalCount
  }
  assignedQuestions(appId: $applicationId, stageId: $stageId, levelNumber: $levelNumber, filter: {or: [{decision: {equalTo: APPROVE}}, {decision: {equalTo: AGREE}}]}) {
    totalCount
  }
}
    `;

/**
 * __useGetReviewableQuestionCountsQuery__
 *
 * To run a query within a React component, call `useGetReviewableQuestionCountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReviewableQuestionCountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReviewableQuestionCountsQuery({
 *   variables: {
 *      applicationId: // value for 'applicationId'
 *      stageId: // value for 'stageId'
 *      levelNumber: // value for 'levelNumber'
 *   },
 * });
 */
export function useGetReviewableQuestionCountsQuery(baseOptions: Apollo.QueryHookOptions<GetReviewableQuestionCountsQuery, GetReviewableQuestionCountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReviewableQuestionCountsQuery, GetReviewableQuestionCountsQueryVariables>(GetReviewableQuestionCountsDocument, options);
      }
export function useGetReviewableQuestionCountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReviewableQuestionCountsQuery, GetReviewableQuestionCountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReviewableQuestionCountsQuery, GetReviewableQuestionCountsQueryVariables>(GetReviewableQuestionCountsDocument, options);
        }
export type GetReviewableQuestionCountsQueryHookResult = ReturnType<typeof useGetReviewableQuestionCountsQuery>;
export type GetReviewableQuestionCountsLazyQueryHookResult = ReturnType<typeof useGetReviewableQuestionCountsLazyQuery>;
export type GetReviewableQuestionCountsQueryResult = Apollo.QueryResult<GetReviewableQuestionCountsQuery, GetReviewableQuestionCountsQueryVariables>;
export const GetSchemaColumnsDocument = gql`
    query getSchemaColumns($tableNames: [SqlIdentifier!]) {
  schemaColumns(filter: {tableName: {in: $tableNames}}) {
    nodes {
      columnName
      tableName
    }
  }
}
    `;

/**
 * __useGetSchemaColumnsQuery__
 *
 * To run a query within a React component, call `useGetSchemaColumnsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSchemaColumnsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSchemaColumnsQuery({
 *   variables: {
 *      tableNames: // value for 'tableNames'
 *   },
 * });
 */
export function useGetSchemaColumnsQuery(baseOptions?: Apollo.QueryHookOptions<GetSchemaColumnsQuery, GetSchemaColumnsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSchemaColumnsQuery, GetSchemaColumnsQueryVariables>(GetSchemaColumnsDocument, options);
      }
export function useGetSchemaColumnsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSchemaColumnsQuery, GetSchemaColumnsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSchemaColumnsQuery, GetSchemaColumnsQueryVariables>(GetSchemaColumnsDocument, options);
        }
export type GetSchemaColumnsQueryHookResult = ReturnType<typeof useGetSchemaColumnsQuery>;
export type GetSchemaColumnsLazyQueryHookResult = ReturnType<typeof useGetSchemaColumnsLazyQuery>;
export type GetSchemaColumnsQueryResult = Apollo.QueryResult<GetSchemaColumnsQuery, GetSchemaColumnsQueryVariables>;
export const GetTemplateDocument = gql`
    query getTemplate($code: String!, $status: TemplateStatus = AVAILABLE) {
  templates(condition: {code: $code, status: $status}) {
    nodes {
      ...templateFragment
      templateSections(orderBy: INDEX_ASC) {
        nodes {
          ...Section
          templateElementsBySectionId {
            nodes {
              ...elementFragment
            }
          }
        }
      }
      templateStages {
        nodes {
          id
          number
          title
          description
        }
      }
    }
  }
}
    ${TemplateFragmentFragmentDoc}
${SectionFragmentDoc}
${ElementFragmentFragmentDoc}`;

/**
 * __useGetTemplateQuery__
 *
 * To run a query within a React component, call `useGetTemplateQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTemplateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTemplateQuery({
 *   variables: {
 *      code: // value for 'code'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetTemplateQuery(baseOptions: Apollo.QueryHookOptions<GetTemplateQuery, GetTemplateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTemplateQuery, GetTemplateQueryVariables>(GetTemplateDocument, options);
      }
export function useGetTemplateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTemplateQuery, GetTemplateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTemplateQuery, GetTemplateQueryVariables>(GetTemplateDocument, options);
        }
export type GetTemplateQueryHookResult = ReturnType<typeof useGetTemplateQuery>;
export type GetTemplateLazyQueryHookResult = ReturnType<typeof useGetTemplateLazyQuery>;
export type GetTemplateQueryResult = Apollo.QueryResult<GetTemplateQuery, GetTemplateQueryVariables>;
export const GetTemplatesDocument = gql`
    query getTemplates($status: TemplateStatus = AVAILABLE) {
  templates(condition: {status: $status}, orderBy: CODE_ASC) {
    nodes {
      ...templateFragment
    }
  }
}
    ${TemplateFragmentFragmentDoc}`;

/**
 * __useGetTemplatesQuery__
 *
 * To run a query within a React component, call `useGetTemplatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTemplatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTemplatesQuery({
 *   variables: {
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetTemplatesQuery(baseOptions?: Apollo.QueryHookOptions<GetTemplatesQuery, GetTemplatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTemplatesQuery, GetTemplatesQueryVariables>(GetTemplatesDocument, options);
      }
export function useGetTemplatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTemplatesQuery, GetTemplatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTemplatesQuery, GetTemplatesQueryVariables>(GetTemplatesDocument, options);
        }
export type GetTemplatesQueryHookResult = ReturnType<typeof useGetTemplatesQuery>;
export type GetTemplatesLazyQueryHookResult = ReturnType<typeof useGetTemplatesLazyQuery>;
export type GetTemplatesQueryResult = Apollo.QueryResult<GetTemplatesQuery, GetTemplatesQueryVariables>;
export const GetUsersDocument = gql`
    query getUsers {
  users {
    nodes {
      username
    }
  }
}
    `;

/**
 * __useGetUsersQuery__
 *
 * To run a query within a React component, call `useGetUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUsersQuery(baseOptions?: Apollo.QueryHookOptions<GetUsersQuery, GetUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, options);
      }
export function useGetUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsersQuery, GetUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, options);
        }
export type GetUsersQueryHookResult = ReturnType<typeof useGetUsersQuery>;
export type GetUsersLazyQueryHookResult = ReturnType<typeof useGetUsersLazyQuery>;
export type GetUsersQueryResult = Apollo.QueryResult<GetUsersQuery, GetUsersQueryVariables>;
export const GeTemplateActionByCodeDocument = gql`
    query geTemplateActionByCode($pluginCode: String!) {
  templateActions(filter: {actionCode: {equalTo: $pluginCode}}) {
    nodes {
      id
      description
      condition
      parameterQueries
      trigger
      description
      template {
        name
        code
      }
    }
  }
}
    `;

/**
 * __useGeTemplateActionByCodeQuery__
 *
 * To run a query within a React component, call `useGeTemplateActionByCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGeTemplateActionByCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGeTemplateActionByCodeQuery({
 *   variables: {
 *      pluginCode: // value for 'pluginCode'
 *   },
 * });
 */
export function useGeTemplateActionByCodeQuery(baseOptions: Apollo.QueryHookOptions<GeTemplateActionByCodeQuery, GeTemplateActionByCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GeTemplateActionByCodeQuery, GeTemplateActionByCodeQueryVariables>(GeTemplateActionByCodeDocument, options);
      }
export function useGeTemplateActionByCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GeTemplateActionByCodeQuery, GeTemplateActionByCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GeTemplateActionByCodeQuery, GeTemplateActionByCodeQueryVariables>(GeTemplateActionByCodeDocument, options);
        }
export type GeTemplateActionByCodeQueryHookResult = ReturnType<typeof useGeTemplateActionByCodeQuery>;
export type GeTemplateActionByCodeLazyQueryHookResult = ReturnType<typeof useGeTemplateActionByCodeLazyQuery>;
export type GeTemplateActionByCodeQueryResult = Apollo.QueryResult<GeTemplateActionByCodeQuery, GeTemplateActionByCodeQueryVariables>;
export const GetAllActionsDocument = gql`
    query getAllActions {
  actionPlugins(orderBy: NAME_ASC) {
    nodes {
      id
      code
      description
      name
      optionalParameters
      outputProperties
      requiredParameters
    }
  }
}
    `;

/**
 * __useGetAllActionsQuery__
 *
 * To run a query within a React component, call `useGetAllActionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllActionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllActionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllActionsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllActionsQuery, GetAllActionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllActionsQuery, GetAllActionsQueryVariables>(GetAllActionsDocument, options);
      }
export function useGetAllActionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllActionsQuery, GetAllActionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllActionsQuery, GetAllActionsQueryVariables>(GetAllActionsDocument, options);
        }
export type GetAllActionsQueryHookResult = ReturnType<typeof useGetAllActionsQuery>;
export type GetAllActionsLazyQueryHookResult = ReturnType<typeof useGetAllActionsLazyQuery>;
export type GetAllActionsQueryResult = Apollo.QueryResult<GetAllActionsQuery, GetAllActionsQueryVariables>;
export const GetAllFiltersDocument = gql`
    query getAllFilters {
  filters {
    nodes {
      code
      id
      query
      title
      userRole
    }
  }
}
    `;

/**
 * __useGetAllFiltersQuery__
 *
 * To run a query within a React component, call `useGetAllFiltersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllFiltersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllFiltersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllFiltersQuery(baseOptions?: Apollo.QueryHookOptions<GetAllFiltersQuery, GetAllFiltersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllFiltersQuery, GetAllFiltersQueryVariables>(GetAllFiltersDocument, options);
      }
export function useGetAllFiltersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllFiltersQuery, GetAllFiltersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllFiltersQuery, GetAllFiltersQueryVariables>(GetAllFiltersDocument, options);
        }
export type GetAllFiltersQueryHookResult = ReturnType<typeof useGetAllFiltersQuery>;
export type GetAllFiltersLazyQueryHookResult = ReturnType<typeof useGetAllFiltersLazyQuery>;
export type GetAllFiltersQueryResult = Apollo.QueryResult<GetAllFiltersQuery, GetAllFiltersQueryVariables>;
export const GetAllPermissionNamesDocument = gql`
    query getAllPermissionNames {
  permissionNames {
    nodes {
      id
      name
      permissionPolicyId
      permissionPolicy {
        id
        name
        rules
        type
        description
        defaultRestrictions
      }
    }
  }
}
    `;

/**
 * __useGetAllPermissionNamesQuery__
 *
 * To run a query within a React component, call `useGetAllPermissionNamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPermissionNamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPermissionNamesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllPermissionNamesQuery(baseOptions?: Apollo.QueryHookOptions<GetAllPermissionNamesQuery, GetAllPermissionNamesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllPermissionNamesQuery, GetAllPermissionNamesQueryVariables>(GetAllPermissionNamesDocument, options);
      }
export function useGetAllPermissionNamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPermissionNamesQuery, GetAllPermissionNamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllPermissionNamesQuery, GetAllPermissionNamesQueryVariables>(GetAllPermissionNamesDocument, options);
        }
export type GetAllPermissionNamesQueryHookResult = ReturnType<typeof useGetAllPermissionNamesQuery>;
export type GetAllPermissionNamesLazyQueryHookResult = ReturnType<typeof useGetAllPermissionNamesLazyQuery>;
export type GetAllPermissionNamesQueryResult = Apollo.QueryResult<GetAllPermissionNamesQuery, GetAllPermissionNamesQueryVariables>;
export const GetAllTemplatesDocument = gql`
    query getAllTemplates {
  templates {
    nodes {
      code
      status
      id
      versionId
      versionTimestamp
      parentVersionId
      versionComment
      versionHistory
      name
      status
      templateCategory {
        title
      }
      applications(filter: {isConfig: {equalTo: false}}) {
        totalCount
      }
    }
  }
}
    `;

/**
 * __useGetAllTemplatesQuery__
 *
 * To run a query within a React component, call `useGetAllTemplatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllTemplatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllTemplatesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllTemplatesQuery(baseOptions?: Apollo.QueryHookOptions<GetAllTemplatesQuery, GetAllTemplatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllTemplatesQuery, GetAllTemplatesQueryVariables>(GetAllTemplatesDocument, options);
      }
export function useGetAllTemplatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllTemplatesQuery, GetAllTemplatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllTemplatesQuery, GetAllTemplatesQueryVariables>(GetAllTemplatesDocument, options);
        }
export type GetAllTemplatesQueryHookResult = ReturnType<typeof useGetAllTemplatesQuery>;
export type GetAllTemplatesLazyQueryHookResult = ReturnType<typeof useGetAllTemplatesLazyQuery>;
export type GetAllTemplatesQueryResult = Apollo.QueryResult<GetAllTemplatesQuery, GetAllTemplatesQueryVariables>;
export const GetTemplateCategoriesDocument = gql`
    query getTemplateCategories {
  templateCategories(orderBy: CODE_ASC) {
    nodes {
      code
      icon
      id
      title
      uiLocation
      isSubmenu
    }
  }
}
    `;

/**
 * __useGetTemplateCategoriesQuery__
 *
 * To run a query within a React component, call `useGetTemplateCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTemplateCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTemplateCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTemplateCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<GetTemplateCategoriesQuery, GetTemplateCategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTemplateCategoriesQuery, GetTemplateCategoriesQueryVariables>(GetTemplateCategoriesDocument, options);
      }
export function useGetTemplateCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTemplateCategoriesQuery, GetTemplateCategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTemplateCategoriesQuery, GetTemplateCategoriesQueryVariables>(GetTemplateCategoriesDocument, options);
        }
export type GetTemplateCategoriesQueryHookResult = ReturnType<typeof useGetTemplateCategoriesQuery>;
export type GetTemplateCategoriesLazyQueryHookResult = ReturnType<typeof useGetTemplateCategoriesLazyQuery>;
export type GetTemplateCategoriesQueryResult = Apollo.QueryResult<GetTemplateCategoriesQuery, GetTemplateCategoriesQueryVariables>;
export const GetFullTemplateInfoDocument = gql`
    query getFullTemplateInfo($id: Int!) {
  template(id: $id) {
    ...FullTemplate
  }
}
    ${FullTemplateFragmentDoc}`;

/**
 * __useGetFullTemplateInfoQuery__
 *
 * To run a query within a React component, call `useGetFullTemplateInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFullTemplateInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFullTemplateInfoQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetFullTemplateInfoQuery(baseOptions: Apollo.QueryHookOptions<GetFullTemplateInfoQuery, GetFullTemplateInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFullTemplateInfoQuery, GetFullTemplateInfoQueryVariables>(GetFullTemplateInfoDocument, options);
      }
export function useGetFullTemplateInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFullTemplateInfoQuery, GetFullTemplateInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFullTemplateInfoQuery, GetFullTemplateInfoQueryVariables>(GetFullTemplateInfoDocument, options);
        }
export type GetFullTemplateInfoQueryHookResult = ReturnType<typeof useGetFullTemplateInfoQuery>;
export type GetFullTemplateInfoLazyQueryHookResult = ReturnType<typeof useGetFullTemplateInfoLazyQuery>;
export type GetFullTemplateInfoQueryResult = Apollo.QueryResult<GetFullTemplateInfoQuery, GetFullTemplateInfoQueryVariables>;
export const GetPermissionStatisticsDocument = gql`
    query getPermissionStatistics($id: Int!, $name: String!, $rowLeveSearch: String!) {
  permissionName(id: $id) {
    name
    permissionJoins {
      nodes {
        id
        organisation {
          name
        }
        user {
          firstName
          lastName
          email
          username
        }
      }
    }
    permissionPolicy {
      description
      rules
      type
      name
    }
    templatePermissions {
      nodes {
        id
        stageNumber
        levelNumber
        template {
          id
          name
          code
          versionId
          status
        }
      }
    }
  }
  templateActions(filter: {parametersQueriesString: {includes: $name}}) {
    nodes {
      id
      actionCode
      condition
      parameterQueries
      trigger
      template {
        code
        name
        versionId
        status
      }
    }
  }
  templateElements(filter: {parametersString: {includes: $name}}) {
    nodes {
      id
      code
      parameters
      title
      section {
        template {
          code
          name
          status
          versionId
        }
      }
    }
  }
  postgresRowLevels(filter: {policyname: {endsWith: $rowLeveSearch}}) {
    nodes {
      policyname
      tablename
      withCheck
      qual
      roles
      schemaname
      permissive
      cmd
    }
  }
}
    `;

/**
 * __useGetPermissionStatisticsQuery__
 *
 * To run a query within a React component, call `useGetPermissionStatisticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPermissionStatisticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPermissionStatisticsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      rowLeveSearch: // value for 'rowLeveSearch'
 *   },
 * });
 */
export function useGetPermissionStatisticsQuery(baseOptions: Apollo.QueryHookOptions<GetPermissionStatisticsQuery, GetPermissionStatisticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPermissionStatisticsQuery, GetPermissionStatisticsQueryVariables>(GetPermissionStatisticsDocument, options);
      }
export function useGetPermissionStatisticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPermissionStatisticsQuery, GetPermissionStatisticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPermissionStatisticsQuery, GetPermissionStatisticsQueryVariables>(GetPermissionStatisticsDocument, options);
        }
export type GetPermissionStatisticsQueryHookResult = ReturnType<typeof useGetPermissionStatisticsQuery>;
export type GetPermissionStatisticsLazyQueryHookResult = ReturnType<typeof useGetPermissionStatisticsLazyQuery>;
export type GetPermissionStatisticsQueryResult = Apollo.QueryResult<GetPermissionStatisticsQuery, GetPermissionStatisticsQueryVariables>;
export const GetTemplateElementsByPluginDocument = gql`
    query getTemplateElementsByPlugin($pluginCode: String!) {
  templateElements(filter: {elementTypePluginCode: {equalTo: $pluginCode}}) {
    nodes {
      category
      helpText
      isEditable
      isRequired
      parameters
      validation
      code
      title
      id
      initialValue
      validationMessage
      visibilityCondition
      templateCode
    }
  }
}
    `;

/**
 * __useGetTemplateElementsByPluginQuery__
 *
 * To run a query within a React component, call `useGetTemplateElementsByPluginQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTemplateElementsByPluginQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTemplateElementsByPluginQuery({
 *   variables: {
 *      pluginCode: // value for 'pluginCode'
 *   },
 * });
 */
export function useGetTemplateElementsByPluginQuery(baseOptions: Apollo.QueryHookOptions<GetTemplateElementsByPluginQuery, GetTemplateElementsByPluginQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTemplateElementsByPluginQuery, GetTemplateElementsByPluginQueryVariables>(GetTemplateElementsByPluginDocument, options);
      }
export function useGetTemplateElementsByPluginLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTemplateElementsByPluginQuery, GetTemplateElementsByPluginQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTemplateElementsByPluginQuery, GetTemplateElementsByPluginQueryVariables>(GetTemplateElementsByPluginDocument, options);
        }
export type GetTemplateElementsByPluginQueryHookResult = ReturnType<typeof useGetTemplateElementsByPluginQuery>;
export type GetTemplateElementsByPluginLazyQueryHookResult = ReturnType<typeof useGetTemplateElementsByPluginLazyQuery>;
export type GetTemplateElementsByPluginQueryResult = Apollo.QueryResult<GetTemplateElementsByPluginQuery, GetTemplateElementsByPluginQueryVariables>;
export const GetTemplatesAvailableForCodeDocument = gql`
    query getTemplatesAvailableForCode($code: String!) {
  templates(filter: {status: {equalTo: AVAILABLE}, code: {equalTo: $code}}) {
    nodes {
      id
      code
      status
    }
  }
}
    `;

/**
 * __useGetTemplatesAvailableForCodeQuery__
 *
 * To run a query within a React component, call `useGetTemplatesAvailableForCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTemplatesAvailableForCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTemplatesAvailableForCodeQuery({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useGetTemplatesAvailableForCodeQuery(baseOptions: Apollo.QueryHookOptions<GetTemplatesAvailableForCodeQuery, GetTemplatesAvailableForCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTemplatesAvailableForCodeQuery, GetTemplatesAvailableForCodeQueryVariables>(GetTemplatesAvailableForCodeDocument, options);
      }
export function useGetTemplatesAvailableForCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTemplatesAvailableForCodeQuery, GetTemplatesAvailableForCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTemplatesAvailableForCodeQuery, GetTemplatesAvailableForCodeQueryVariables>(GetTemplatesAvailableForCodeDocument, options);
        }
export type GetTemplatesAvailableForCodeQueryHookResult = ReturnType<typeof useGetTemplatesAvailableForCodeQuery>;
export type GetTemplatesAvailableForCodeLazyQueryHookResult = ReturnType<typeof useGetTemplatesAvailableForCodeLazyQuery>;
export type GetTemplatesAvailableForCodeQueryResult = Apollo.QueryResult<GetTemplatesAvailableForCodeQuery, GetTemplatesAvailableForCodeQueryVariables>;